---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------28.10.2017 Cumartesi----------------------------------------------------
	C++ 1.ders

	- C++ derleyicisi sadece kodu derlemiyor ayrıca bizim için kod da yazmaktadır.
	- template : derleyiciye kod yazdıran bir araçdır. Özel bir yazdığımız kod ile derleyici bizim yazdığımız koddan
	  faydalanarak kendisi kod yazmaktadır. Derleyici compile time da kodu kendi yazıp sonra derlemektedir.



	- sistem programlama alanında C++ kullanımı vardır. ve giderek artmaktadır.

	- C++'da önişlemci makroları çok nadir kullanılır.(Kısıtlayıcı bir neden yoksa).
	  C' de ki #if #elseif #endif gibi komutlar kullanılır.

	- C++'da makro yerine geçen özel araçlar vardır.

	- Özellikle dinamik ömürlü nesnelerin kontrolünde kullanılan pointerların yerinde burada smart pointer denilen
	  özel sınıf nesneleri kullanılacaktır. Yinede bir çok konunun anlaşılması için pointer konusunun çok iyi bilinmesi
	  gerekir.

	- C++ generic programlama konusunda(türden bağımsız programlama) dünyanın en gelişmiş dilidir. Yani template'lerdir.

	- Ekrana merhaba dünya yazdıran bir C++ programı, C++'ın bütün temel amaçlarını kullanan bir programdır.

	- C++'ın standart başlık dosyaları .h uzantısına sahip değildir.

	- C++'da C'nin başlık dosyalarını başına c gelerek include edilecektir. (cstdio)

	- using namespace std;  //bu bildirim std namespace'i içinde ki isimlerin derleyici tarafından aranması sürecinde nitelenmeden
	  yine de o namespace de aranmasını sağlıyor. eğer biz bu bildirimleri yapmasak cout ve endl için  derleyici arayıp bulamayacaktı.
	  çünkü namelook up sürecinde std namespace'ine bakmayacaktı. Derleyicinin isimleri o namespace de aranması için std::cout // şeklinde
	  kullanılması gerekirdi. böyle isimlere qualified name denir.

	- cout << "Merhaba dunya"<<endl; ile // burada ki bitsel sola kaydırma operatörü kullanılmış ama bitsel işlemle hiç bir ilgisi yoktur.
	  Burada bu atom, operatör overlaoding kapsamında kullanılmıştır. Bu C'de olmayan C++'da olan dilin en önemli araçlardan biridir.
	- C++'da operator overloading denilen mekanizma ile user defined türlerin operatörlerin operandı yapılabilir. derleyici kendisine
      bir vazife çıkarıp cout << "merhaba  dunya" ile kendisi bir fonksiyon çağrısına dönüştürecektir.(cout.operator<<("merhaba dunya"))

	- Burada ki cout bir sınıf şablonundan oluşturulan bir sınıf  türünden nesnedir. cout ostream sınıfı türünden bir nesnenin ismidir.
	  bu nesne standart çıkış akımını kontrol eder. kendi interface'i ile onu kullanmamızı izin veren global bir nesne.

	- cout ostream isimli bir sınıf türünden (fakat ostream bir typedef ismidir. ostream basic ostream isimli şablonun char türünden açılımına
	  verilen bir typedef ismidir.)

	- inheritance, multiple inheritance, vurtial inheritance gibi temel araçlar vardır.

	- cout << ile derleyici bunu cout'ın ait olduğu sınıfın bir member functionına(operator fonksiyonuna) çağrı yapacaktır.

	- C++'da ayrıca function overloading vardır.

	- cout << "merhaba dunya" << endl;  // burada endl bir fonksiyon ismidir  ve C'deki gibi endl bir manüpilatör yani  fonksiyon adresidir. ve endl'yi
	  derleyici endl << operatörünün operandı olduğu için derleyici vazife çıkartarak başka bir left shift fonksiyonu çağırır.

	- o fonksiyonun parametresi de bir function pointer'dır. ostream sınıf nesnelerini alıp onları kullanan ve nesnenin kendisine
	  döndüren fonksiyonlara manipulator denir.

	- bir merhaba dünya yazarken C++'ın 14-15 farklı aracını birleştirerek yazmış oluruz.

	- C++'ın zor tarafı da budur. çok sayıda araç olup fakat iş gören kodlar bu araçları kombine ederek kullanıyorlar.

	- C++'ın nesne yönelimli programlamaya ilişkisi class dediğimiz araçla başlar. Bu C'Deki struct'ların çok dah gelişmiş halidir.

	--- C++ ile C arasındaki temel düzeydeki farklar----

	- C++'da old style funciton definition artık sentaks hatasıdır.
		double func(a, b, c)
		double c;
		int a;
		long b;
		{
		}//sentaks hatasıdır.

	- implicit int'te yoktur.

	- C derleyicilerinde fonksiyonun geri dönüş değeri yokken return ifadesi kullanılmamışsa sentaks hatası değil ama fonksiyon çöp
	  değer döndürecektir.C++'da errordur.

	- main fonksiyonunun geri dönüş değerinin int olması zorunluluktur.

	- C++'da definition'da parametre değişkenlerine isim vermek zorunda değiliz. C'de geçerli değildir. declaration da ikisinde de
	  isim vermek zorunda değilizdir.

	- C'de func fonksiyonunun definition'ı görülmeden func fonksiyonuna çağrılırsa derleyici ismi arayıp bulamazsa implicit int olarak kabul eder.

	- C++'da direk errordur.

	- C'de int f1(); int f2(void); arasında fark vardır. f1'in parametre değişkeni hakkında herhangi bir bilgi yoktur.
	  ama C++'da ikisi de aynı anlama gelir.

	- C++'da if parantezi içinde de bildirim yapabiliriz. C'de yoktur.

	- C++17 ile gelen yeni bir if deyimi vardır. ismi if with initializer

	- for(int i : a)--> bu java c# taki foreach gibidir.// range-based for loop denir. C++11 ile dile eklenmiştir.

	- tür dönüşümleri C'de kontrol bakımından çok gevşektir. C++'da bu kontrol çok katıdır.

	- int x = 10; int *ptr = x; int y = ptr C'de yanlis ama gecerli C++'da gecersiz.


	- C++'da tür dönüştürme işlemleri static cast, const cast, reinterpret cast, dynmaic cast denilen opretörler ile yapılacaktır.(ileride işlenecektir.)

	- C++'da farklı tür adresler arasında da tür dönüşümü yoktur. C'de bu vardır ama legal değildir.

	- T*'dan const T*'a dönüşüm C'de de C++'da legal ve doğrudur. const T *'dan T*'a dönüşüm C'de legal ama yanlış olma ihtimali yüksek(eğer programcı değiştirmeye çalışmaz ise.). C++'da errordur.

	- C++'da void *'dan T *'a otomatik tür dönüşümü yoktur. C'de vardır. Ama öyle kullanımı tamamen hatalıdır(Yani kötü koddur)

	- C'de const bir nesneye ilk değer verilmesi geçerlidir ama yanlıştır. C++'da errordur.
	- C'de bir dizinin ifadesi constant expression olan bir ifadeyi kabul etmezken C++'da bu geçerlidir.

	- bir değişkeni kullanıldığı alanın dışında tanımlamanın her zaman bir getirdiği riski olabilir.
	  buna scope linkage denir.

	- scope linkage'tan korunmak en önemli amaçlarından biridir. Bu yüzden C++11 ile gelen range based for loop ile C++17 ile gelen
	  if with initializer vardır.


	- C++'da global const nesneler static anahtar sözcüğü kullanılmadan bağlantısı internal'dır.(Yani sadece dosya içine özgüdür.)

	- constexpr C++'ın yeni anahtar sözcüğüdür. constant expression'dan kısaltmadır.

	-

	- C++'da ayrıca bool türü vardır. Bir keyword'dur. true ve false'da bir keyword olmasına rağmen constexpr'dır.

	- C++'da bool türünden aritmetik türlere dönüşüm, aritmetik türlerden bool türüne ve pointer'lardan bool türüne tür dönüşümü vardır.

	- C++'da ki bool türü otomatik tür dönüşümü ile double türden bir değişkene bool türünden bir nesne atanabilir.

	- bool'un sizeof'u 1'dir.

	- karşılaştırma operatörlerinin ürettiği değerin türü int değil bool'dır.

	- boolalpha bir manüpilatör'dür.Bir formatlama gibidir. bool türden bir değerin true yada false olduğunu sözel olarak yazdırır(0, 1 gibi değildir.)

	- C'de karakter literallerinin türü int(sizeof('a') == 4), C++'da CHAR'dır(sizeof).

	- bool'dan int'e dönüşüm olması bool *'dan int *'a dönüşüm olacağı anlamına gelmez.(int *'dan bool *'a dönüşüm yoktur)

	- true değeri her zaman 1'e dönüşür.

	- istesek de istemesekte bool türlerde integral promotion'a tabidir.(int altı türlerin int'e yükseltilmesi.)

	- C++11'den önce NULL pointer yerine 0 kullanılıyordu. 11'den sonra ise nullptr anahtar sözcüğü geldi. türü nullptr_t türünden bir constant value'dir.

	- nullptr sadece pointer'lara ve bool değişkenlere atanabilen bir değerdir.

	- C'de enum türü int'tir.

	- nullptr nin türü nullptr_t'dir.

	- C'de enum'ın underlined_type'ı int'tir. C++'da böyle bir zorunluluk yoktur.  Belirtme şekli  enum Color : int {Red,Green,Blue}

	- C++ özel bir sentaks ile programcı enum türünün underlined_type'ını belirleyebilir.(C++ 11 ile gelmiştir.)

	- C++' başka türlerden enum türlerine tür dönüşümü yoktur. ama tersi vardır.

	- C++11 ile  enum class türü eklendi. syntax'ı enum class T{} şeklindedir.

	- C'de iç içe struct bildirimi yapılabilir. Fakat içteki struct'ın scope'ı ile dıştaki struct'ın scope'u aynıdır.
	   Ama C++'da bunu kullanmak için bir özel bir tanım gerelidir. A::B x;(90)
	- İlk değer verme sentaksı çok daha farklıdır.

	- C'de global değişkenlere ilk değer veren ifadeler constant expression olmalıdır.

	- C++'da böyle bir zorunluluk yoktur.
------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------04.11.2017 Cumartesi-------------------------------------------------------------------------------------

	-C++'da formatlı giriş çıkış işlemleri için sınıf nesneleri vardır.
		1- cout(C out)  Standart çıkış akımını kontrol eden nesnedir.(Bunlar C'deki yapılar(struct'lar) gibidir.);
		2- cin (C in) Standart giriş akımını kontrol eden nesnedir.;

		- Bunlar sınıf nesneleridir.
	cout << "Merhaba";



	cout << x << "  " << dval << endl;
		- Burada kaç tane left shift var ise o kadar fonksiyon çağırılır.

	- operatör önceliği burada da vardır. C'de kinin aynısıdır.

	- standart inputtan bir değer cin ile alınır. Bunu almamız right shift ile olur.

	- cin >> x >> y >> d;
	- Giriş işlemlerinde dikkat etmemiz gereken adres göndermememizdir(call by reference'dır.)(117. satır).

	--- REFERANS SEMATİĞİ---

	- C'de call by reference, pointer semantiği ile yapılır.

	- C++' ise pointer semantiğinin yanı sıra referans semantiği de  vardır. Bu pointer'a göre daha yükseltilmiş bir araçtır. Burada & ve * ile uğraşılmaz.
	  Geri planda derleyici gene adresleri kullanır.

	- referans adeta bir nesnenin yerine geçen isim gibidir.

	- referans semantiğinin dile eklenmesi pointer'ları olan ihtiyacı çok azaltmıştır (C'dekinin %20 kadarı kullanılmaktadır.)

	- C'de pointer kullandığımız yerlerin çoğunda, modern C++'da çoğu yerde  referans semantiği yada smart pointer'lar  kullanır.

	Not : Kurs da hoca reference isimlerine r ile verilir. (Genel olarakta kullanılır.).


	Not :  operatörler ifade de olur. decleratörler bildirimde olur.(int *ptr -> burada yıldız bir declaratördür.)

	- smart pointer : kendisi bir sınıf nesnesi olup bir pointer gibi kullanılan, pointer olmamasına rağmen client'lerin pointer gibi kullanıldığı sınıf nesneleridir.

	- int &r = x;  Burada r  x'e bir referansdır.

	- referans'ları initialize etmek zorunludur.(çünkü referanslar top level const'tur(int & const r));

	- r 'deki herhangi bir değişim x dede olur.

	- r1, r2 ve r3 de x'i reference eder.(174)

	- bir reference'a mutlaka bir nesne ile ilk değer vermeliyiz.

	- int x = 10;
	  int *ptr = &x;
	  int &r = *ptr;

	  ++r; // ++x ile aynıdır.(211).

	-int a[] = {1, 4, 5, 6, 2};
     int &r = a[2];
	 ++r; a dizisinin ikinci elemanını bir artırma.

	- reference olarak seçilen tür ile değişkenin türü aynıdır.

	- C++'da dizilere de reference alınabilir.

	- int a[5] = {2, 4, 5, 8, 3};

	- int (&ra)[5] = a;
		ra[k] ile dizinin öğelerine erişebiliriz.(306)

	- burada ra a'ya bir referanstır.




	- bir reference'ın türü ile adresini tutacağı nesnenin türü aynı olmak zorunludur.

	- int x = 10;
	  int y = 34;
	  int *ptr = &x;
	  int *&r = ptr;

	  r = &y;

	  ++*r;// burada y'ye erişiyoruz.(325)

	  - reference'lar en çok call by reference yapılırken kullanılır.

	  - C'de call by reference yapmanın tek yolu pointer parametre'dir.

	  - C++'da 2. bir yol vardır. referans semantiğidir. Bizim hemen hemen her zaman bunu kullanmamız gerekir.

	  void func(int &r)
	  {
		r = 768;
	  }
	  - Burada r fonksiyon çağırısında kullanılan parametrenin yerine geçer.

	  func(x) --> Bu C'de kesilinkle call by value iken C++'da bunu bilemeyiz. (Çünkü burada fonksiyona bakmamız gerekir.)

	  - C++'da burada & operatörünü unutarak call by reference iken call by value yapabiliriz.

	  - swap fonksiyonu referans semantiği ile yazıldı(371).

	  Not : referans semantiği kullanılırken fonksiyonun çağrısından call by value yada call by reference olup olmadığını bilemeyiz.
	  C++'da call by reference referans semantiği ile func(x) şeklinde olabilir.
	  - fonksiyonlardan g call by value iken diğerleri call by reference'dır(406)

	  - C++'da const nesnesinin hayati önemi vardır.

	  - bir reference const olabilir. ve bu nesneyi okumaya yönelik olduğunu gösterir. nesne de değişiklik yapılmaz. (443)

	  int x = 10;
	  const int &r = x;

	  - r'yi değiştirmeye yol açan herhangi bir işlem sentaks hatası olacaktır.(461)
		- const int x = 10;
		  int &r = x; //gecersiz. const int &r olmalıdır. const bir nesneden int &'a dönüşüm hatadır.


		- const int x= 10;
		  int *ptr = &x; // gecersiz. const int *ptr olmalıdır. const bir nesneden int *'a dönüşüm hatadır.



		  void foo (const T *ptr) ile void func(const T &r);

	 - parametresi referans olan bir fonksiyon da ilk sormamız gereken amaç ne.

	 - int &const r = x; //saçma bir kullanım şeklidir. Çünkü reference'lar kendiliğinden  top levelconst'tur.

	 - const int &r = x;

	 - const int x = 10;

	 - int &r = x; //direk hatadır.

    - bir reference bir R value expressiona bağlanamaz.(eğer const reference değilse)

	- int &r = 10; //sentaks hatasıdır.

	- const int &r = 10; sentaks hatası değildir.

	- void func(int &r); gibi bir fonksiyonu r value expression bağlayamayız.

	- eğer yukaraıdaki fonksiyonun parametresi const int &r olursa r value expression ile çağırabilir.(const int &x = 10)
		1- Burada derleyici arka planda kendisi const int türünden bir nesne oluşturup bizim referansımıza da o nesneyi gönderir.
		2- derleyicilerin böyle durumlarda oluşturduğu geçici nesne const'tur. böyle bir durumda const &'a derleyicinin oluşturduğu
		   const nesne ile atama yaparız.

	- C'de bir fonksiyonun nesnenin kendisini döndürmesi yani adres döndürmesidir.


	- C'de fonksiyonlar r value expression olabilir.

	- C++'da geri dönüş değeri referans ise (int &func())  l value expressiondır. Ama fonksiyonun geri dönüş değeri referans değil ise  r value expression'dır.
	  Yani func() = 10; şeklinde ifade olabilir. Burada func'ın geri dönüş değerinin referans olduğunu gösterir.(590, 618)

	- otomatik ömürlü bir nesneye referans ile geri dönülmesi rte'dir.referans ile dönülmesi için
		1- statik ömürlü bir nesne ile
		2- dinamik bir ömürlü nesne ile
		3- client'ten aldığı nesnenin referansı ile dönüş yapabilir.

	- static ömürlü nesneler için dikkat edilmesi gereken birden çok çağrıldığında bütün nesneler en son kullanılan nesnenin değerine sahip olacaktır.(667)


	- referans semantiği ile hayatamıza giren fonksiyonlar.
		1- void func(T &r);
		2- void func(const T &r);
		3- T &foo(/*  */); T*'a dönen fonksiyon.
		4- const T &foo(/**/); const T*'a dönen fonksiyon.

	- nesneye referansın kendisini ok operatörü ile kullanamayız.

	---Referanslar ile pointerların karşılaştırılması
                1- pointer değişkene ilk değer vermeden oluşturabilirken, refaransta ilk değer verme zorunludur..

		2- bir pointer'ın kendisi const olmak zorunda değildir.(Kodun farklı farklı yerlerinde farklı nesneleri gösterebiliriz.). Referanslar her zaman top level const'tur.

		int *const ptr = &x;
		ile int &r = x; aynı anlamdadır. içeriği değiştirebiliriz ama r'yi değiştiremeyiz.

		3- elemanları pointer olan bir dizi varken elemanları referans olan bir dizi yok.int &ra[] = {x, y, z}; şeklinde bir sentaks yoktur.(865)

		4- C'de ve C++'da pointer to pointer aracı varken reference to reference şimdilik yok kabul ediyoruz. int &&r = x; şeklinde bir reference yok kabul ediyoruz(R value reference'ı hariç tuttuk).

		5- C'de NULL pointer semantiği int *p = NULL; şeklindedir. hiç bir nesneye bağlanmayan bir reference yoktur.

			-int *func() şeklinde bir fonksiyon nullptr döndürebilir.
			-int &func() referans semantiğinde böyle bir nullptr döndüern fonksiyon yoktur.(strchr fonksiyonu referans ile dönemez);

		- C++11 ile sağ taraf referansları dile eklenmiştir.(int &&r)

		- int &&r = 10; bir  L value referans değildir. Bunlar R value references.

		- C++11 öncesinde sadece sadece L value references vardı. C++11 ile R value references dile eklenmiştir.

		// move semantics (taşıma semantiği)     bunlar 11 standartları ile dile eklenmiştir.
		// perfect forwarding (mükemmel gönderme)


		- bir &'lı refarans'lar l value reference'dır.
		- iki &'lı refarans'lar r value reference'dır.

		- auto keyword --> 11 standartları ile gelmiştir. Derleyici compile time da ilk değer veren ifadenin türü ne ise o türden bir ifadenin türünü verecektir.

		- auto x = 0; da x'in türü int olur.


		- int * foo();

		  auto x = foo(); x'in türü int * olur.

		- auto x örneği(967);

		- auto keywordu ile declera edilen bir değişkene ilk değer vermek zorunludur.

		- uzun ve kompleks tür isimlerinde çok daha fazla kolaylık sağlamıştır.

		- auto ile türe bağlı değişikliklerde sentaks hatası olmayacaktır.

		- modern C++'da en basit değişkenleri bile auto ile tanıtma eğilimi vardır. auto x = 0;

		- ilk değer verme de C++ da farklı sentaks yapılarıda vardır.
			1- int x = 10; yerine int x(10); kullanılabilir.
			2- int &r = x; yerine int &r(x); kullanılabilir.

		C++11 ile gelenler
			1- int x{ 10 }; // uniform initializer. diye geçer
			2- int a[]{ 1, 5, 65, 7 };
			3- int &r{ x };
			int *ptr{ &x };

		double dval = 5.6;
		int x{dval}; //tekbiçimli ilk değer verme (uniform initializer) kullanılması durumunda
					//daraltıcı dönüşüm (narrowing conversion) sentaks hatası. D
		int y(dval)  // gecerli.
		int x = dval; // gecerli.

	----İŞLEVLERİN VARSAYILAN ARGÜMAN ALMASI---

		- C'de parametre değişkeni sayısı ile fonksiyona gönderilen argüman sayısının birbirine eşit olmaması sentaks hatasıdır.

		- default argüman = fonksyionlar'ın client cod belirli sayıdan eksik argüman sayısı gönderildiğinde eksik argümanlar önceden belirlenen değerler ile kullanılır.

		- tamamen compile time a yönelik bir mekanizmadır. Ve client kodu yazan programcının işini kolaylaştıran bir programdır.

		- programlama domain'lerinin çoğunda böyle fonksiyonlar vardır.

		- varsayılan argüman özel durumları göz ardı edersek tamamen interface'e yönelik bir fonksiyon.

		void func(int, int, int = expr);
			- eğer biz func(25, 50) değerleri ile çağırırsak 3. parametredeki  herhangi bir expression olabilir.(1140'da örnek).
			- bir fonksiyonun bir parametresi varsayılan argüman alırsa onun sağındakilerin hepsi varsayılan eleman olmaz zorundadır.(1182, 1220 ve );
			- func(10, , 20);// gecersiz
			- func(, , 10); // gecersiz

			- varsayılan argüman bir reference, bir pointer da olabilir.(1278)

			int f1(int x = 10, int y = 20);

			int f2(int a, int b = f1());

		- varsayılan argüman'ın değeri bir fonksiyonun geri dönüş değeri de olabilir.

		- varsayılan argümanın örneği(1301).

		- önceden başka bir kütüphaneden eklenen bir fonksiyonun bir argümanını varsayılan argüman yapabiliriz.(1330);

		- önceden başka bir kütüphaneden eklenen bir fonksiyonun 3. argümanı varsayılan argüman iken ikinci parametresine bir varsayılan argüman yapılabilir.redeclaration yapılarak(1360)
			- not : varsayılan argüman'ı yeniden declare edilmez.
			- void func(int, int, int = 15);
			  void func(int, int = 20, int); //func fonksiyonu redeclara edilmiştir. fonksiyonun yeni parametrik hali(int, int = 20, int = 15);'dir.
			  void func(int, int = 20, int = 15) // error, varsayılan argüman redaclara edilmez.

		- sarmalıyıcı bir fonksiyon ile 3. parametre ye gönderdiğimiz parametre ile varsayılan argümanı ikinci parametreye atamak işimizi kolaylaştırabilir.(1397)

	Not : Varsayılan argüman ya bildirimde yada tanımda olmak zorundadır.
		- itoa'yı wrapper ile kendimize göre yazdık(1417).

		- bazen varsayılan argüman kullanılmasının nedeni sadece test amaçlı varsayılan argüman kullanılıp kullanılmadığına bakmak içindir.(1451).
	------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	-------------------------------------------------------------05.11.2017 PAZAR-------------------------------------------------------------------------------------------------

	--- FUNCTION OVERLOADING(fonksiyonların doğrudan yüklenmesi)---

	- Aynı isme sahip parametrik yapıları birbirinden farklı olan fonksiyonlardır.
	- Bütün dillerde düşük seviyelerde vardır.(C'de i1  + i2, d1 + d2).
	- Özellikle yüksek seviyeli dillerde birinci amaç programcının işini kolaylaştırmaktır.
	- Bu mekanizma C'de olmaması çok büyük bir derleyiciye sahip olmamasından dolayıdır.
	- Burada derleyiciyi yoran şey fonksiyonları elemeden geçirmektir. Ve bu derleyici çok fazla yoracaktır.
	- top level const'luk function overload olmaz.

	- top level const = nesne'nin kendisini gösteren const'luktur. Örneğin(const int x, int * const ptr)

	- referans semantiği kesinlikle function overloading

	-- function overload resolution : derleyicinin compile time da n tane aynı isimden fonksiyon varken bunlardan hangisini seçeceğidir.
		- overloaded function' a da biz overload deriz.(Yani burada overload isim olarak kullanılır.)

	- Bu mekanizma standart kütüphanenin çok sık kullandığı bir mekanizmadır. Bu mekanizma kullanıcı rolündeyken çok fazla bilmemiz gerekir.
	- Burada en ufak bir yanlışlık programızı direk hataya götürebilir.

	- Ortada function overloading var mıdır, yok mudur?
	- function overloading programın çalışma zamanına herhangi bir ek yük getirmez.(compile time da getirir.)
	- Derleyici compile time da fonksiyonun ne istediğini belir.
	- Çağırılan fonksiyonun ne olduğunu anlaşılması
		1- compile time da yapılabilir.(static binding, early binding)
		2- run time da yapılabilir.(dynamic binding, late binding) hangi fonksiyonun çağrıldığı run time da anlaşılacaktır. C'de böyle bir karşılığı yoktur.

	Not : rastgele sayı üreticisi run time da yapılan bir işlevdir.

	- runtime polifermizm  : hangi fonksiyonun çağrıldığının run time da belli olmasıdır.

	- ileride overloading'e benzer gibi gözüken overwriting tamamen dynamic binding ile ilgilidir.

	- overloading var mı yok mu ?
		- iki koşul vardır. Bunlar sağlanmıyorsa kesinlikle overloading değildir.
			1- isimler aynı scope da olmalıdır.(farklı scope da bildirilen fonksiyonlar overload etmez.Global scope tan farklı scopelarda vardır.)

			2- imzaları(signature) farklı olacak.
				(fonksiyonun parametre sayısı ve parametrelerinin türü dahildir. Geri dönüş değeri dahil değildir. Yani geri dönüş değerinin aynı yada farklı olması önemli değildir. )
				- imzaları  ve  scopeları aynı, geri dönüş değerleri de farklı ise bu overloading'dir.



	- eğer imzaları aynı ve geri dönüşleri aynı ise bu function redeclarationdır.
		- void func(int);
		  void func(int); //function redeclarationdır.

	- void func(const int);
	  void func(int); //function redeclarationdır. top level const'luk her zaman  redeclaration kabul edilir. ama legaldir.

	 Not : aynı fonksiyon ise derleyici ikisinin ayrı ayrı tanımlanmasına(define edilmesine) izin vermez.

	- void func(const int x); // bu  saçma bir declaration'dır. Zaten otomatik ömürlü olduğundan dolayı değişip değişmemesi saçmadır.

	- void func(int * const ptr);
	  void func(int *ptr); //redeclaration(1617)

	- farklı typedef isimleri overloading yapmaz. Redeclaration'dır(1638).

	- imzaları ve isimleri aynı olup geri dönüş değeri farklı olan fonksiyonlar errordur.Yani redecleration yapmaya çalışmışız. ama farklı geri dönüş değerine sahip olmasından dolayı sentaks hatasıdır.(1664)

	- farklı scope da ki isimler birbirini gizler.

	- refereans semantiği kesinlikle function overloadingdir.(geri dönüş değeri farketmez)(1687)

	- const overloading (eğer const'luk low level const ise function overloading olma ihtimali yüksek. top level const'ta redeclaration'dır.)
		- Bu bir çok yerde karşımıza çıkacak bir yapıdır.

	- void func(int &r);
	  void func(const int &r); Kesinlikle const overloading'dir.

	- void func(int x = 10);// varsayılan argüman alsa da almasa da bir parametrei vardır.
	  void func(); function overloadingdir.(1759)

	- void func(int x, int y= 10);
	  void func(int y);
	  void func(int, ...); üç tane overload vardır.(1772)

	---- **** FUNCTION OVERLOAD RESOLUTION ***** ----

	- Eğer kurallarını iyi bilmezsek beklentimiz ile bir şey yapmaya kalkarsak yanlış sonuçlar alabiliriz.

	- ortada function overloading varken aynı isimli fonksiyonların çağrılmasında sentaks hatası olabilir..

	- C++'da en zorlayan şeylerden biri ortada sentaks hatası verken programcının hatayı bulamamasıdır.
		1- nedeni çok fazla kural olmasıdır.
		2- template : derleyicinin bizim için kod yazmasıdır.

	- function overload resolution ya legal olarak sonuçlanacaktır.

	- illegal olması durumunda iki farklı durum vardır.
		1- ortada n tane fonksiyon varken sizin fonksiyon çağrınız hiç bir fonksiyona uygun değildir.(no match)
		2- derleyici dilin kurallarına göre birini seçmesini gerekirken bir seçicilik yoktur.
		Yani gönderdiğimiz parametreler birden çok fonksiyona uygun olabilir(ambiguity : çift anlamlılık hatası)

	- void func(int)
	  void func(int, int);
	  void func(int, double);

	int main(){
		func(); //soruda overload vardır. ama no match error vardır(1796);
	}


	- void func(int);
	- void func(long double);

	int main(){
		func(10U);//ambigouos call to overload function
		// eğer bunlardan biri tek başına bulunsaydı legal olurdu.
	}

	- eğer bir argüman bir parametre değişkenine aktarılıyorsa, derleyici function overload resolution'ı üç aşamada gerçekleştirir.
		1- derleyici aynı scope içirisindeki bütün isimleri aynı olan overload'ları listeye dahil eder.Bu süreçte imzalarını da alır.
		2- derleyici fonksiyon çağrısındaki argüman sayısı ile fonksiyonların parametre sayısına denk düşmesi gerekecek ve buna göre fonksiyonları seçecektir.
		   (var sayılan argüman  dahil  ve variadic olup olmaması da dahildir)Her bir argümandan her bir parametreye tür dönüşümü de uygun olması gerekir.(uygun fonksiyon)
		   Not : eğer 2. aşamayı geçen fonksiyon yoksa error. Bir tane fonksiyon varsa legal. eğer birden fazla varsa 3. aşamaya geçecek fonksiyon varsa derleyici
		   en uygun fonksiyon vardır. Burada seçim

		3- derleyici bu aşamada argümandan parametreye geçişte 3 farklı yöntem arayacak.
		    - conversion,
		    - user defined conversion,
		    - variadic function'a göre yapılabilir. Burada conversion user defined conversion'dan, oda variadic function'dan daha iyidir.
			- Sık yapılan hatalarda özellikle iki durumunda standart conversion'a göre yapılması yada iki durumunda user defined conversion'a göre yapılmasıdır.
			a) conversion(dönüşüm)
				- Argüman'dan parametre değişkenine aktarım dilin kurallarına göre legaldir.
				- dönüşümü kaliteye göre yapılabilir.
					1- exact match(tam uyum)olabailecek en iyi dönüşüm kategorisidir.
						-argüman olan ifadenin türü ile parametrenin türü bire bir aynı olmasıdır.
						- standartlar aşağıdaki durumların hepsini exact match kabul eder.
							1- L value to R value transformation.
								- Bir fonksiyon'un parametresi bir r value expression'ken  ona L value expression göndermektir.
								  void func(int x); --> fonksiyonu bir nesne ile çağırmak, yada sabit bir sayı ile çağırmak.
							2- const conversion
								- bir fonksiyonun parametresi const int * ise biz onu int * argümanı ile çağırabiliriz.(aksi durum errordur)
							3- array to pointer conversion
								- fonksiyonun parametresi int* iken fonksiyonu dizinin adresi ile çağırmaktır.(1867)
							4- function to pointer conversion(1866 - 1871);
					2- promotion(terfi, yükseltme)
						1- integral promotion(int altı türlerin int'e yükseltilmesi. char,short,unsigned char, bool	 --> int)
							C' deki integral promotion'ların hepsi vardır. Ayrıca boolean türünden int'e de vardır.
						2- float to double promotion
							- sadece floattan double'a olan promotion'dır.

					3- standart conversion
						- Eğer yukarıdaki durumlardan biri değilse normal promotion'dır.
					void func(int);
					void func(doule);

					func(13u); //errordur.(1871)

					func(1.3f); //legal 2. çağırılır(1881);

					bool türle alakalı 2. si çağırlacak(1890);

					Not : C++'da karakter sabitlerinin türü char'dır.


				Not : Çok büyük iki ambiguity error ikisininde
					1- user defined tür olmasıdır.
					2- ikisininde standart conversion olması.

				Özel durumlar :
					1- void func(double);
					   void func(int *);

					   func(0); çağrısı nullptr'e dönüşüm olduğu için error'dur.ambiguity'dir.

				    2- Not : nullptr'in kullanımı burada özellikle gerekir.(nullptr sadece pointer'lara atanabilen bir sabittir.) nullptr'den sadece pointer türlerine dönüşüm vardır.

					3- void func(int x);
					   void func(int &x);
					   //call by value'nin call by reference'a üstünlüğü yoktur.(1929);
					4- const int * türünden int * türüne otomatik dönüşüm yoktur.(1950)
						- int *, const int *'a baskınlığı vardır.(1950)
						- refarans semantiğinde de const overloading vardır. fonksiyon çağrısı const t & ile olursa const t& olan fonksiyon, çağrı t& ile yapılırsa t& olan fonksiyon (1970)

					Not : tür dönüştürme operatörü ile de istediğimiz çağrıyı yapabiliriz. Ama C'deki tür dönüştürme operatörlerini C++'da kullanmamamız gerekir.(1990)

					5- varsayılan argüman ile uyum herhangi bir şekilde dezavantaj değildir. Soruda derleyici ambiguity hatası verir.(c.a.h)(2010)
						- C++11 ile geren bir araç ile fonksiyon delete etmek aracı vardır. Daha sonra görecez.
					6- Bir overload fonksiyon birden fazla parametreye sahip ise seçileblirlik kriteri
						1- en az bir parametre de üstünlük olacak. Ama diğer parametrelerinde de hiç birinde kötü olmayacak(eşit olabilir). Seçim gene yukarıdaki kurallara göre yapılacak.

			b) user defined conversion (programcının bir fonksiyon ile dönüşümü yapması)
				- C'de bir karşılığı yoktur.
				- normalde bir türden bir türe dönüşüm	 yoktur. programcı tarafından yazılan bir fonksiyon ile dönüşüm gerçekleştirir.(1838)
				- dönüşümü legal hale getiren bu fonksiyonun varlığıdır.

			c) variadic functions
				- seçicilik açısından en kötü durum budur.


		- C++'dan C'de derlenmiş bir  fonksiyonu çağırmak için bir önlem almaz isek bu bir hata olur(linker hatası).
			- C'de derlenmiş fonksiyon C++ derleyicisinin derlediği kodun obj isimlendirmesinden kaynaklanmaktadır.
			- extern "C" void func_dec(par1); ile linker'ın bunu bulmasını sağlarız. C++ derleyicisine bunu mutlaka göstermeliyiz.
			- extern "C" {
					void bprint(int);
					void foo(int);
					void func(int);
					void falanca(int);
			} // C' de derlenen fonksiyonları kullanabiliriz.

		#ifdef _cplusplus
			extern "C"{
		#endif
			başlık dosyasında ki bildirimler

		#ifdef _cplusplus
		}
		#endif

		- Başlık dosyasını bunu yapmalıyız.
	-------C++'da tür dönüştürme operatörleri----------------	---

	- C'deki tür dönüştürme operatörü kullanımı (target type= double, int,...)operand şeklindedir.
	- C++'da amacına bağlı olarak farklı operatörler kullanılabilir.
	- Ve tür dönüştürme operatörleri sözelleştirilmiştir.

	Not : veri kaybının gönüllü yapıldığı işlemlerde kullanılabilir.
		- ival = (int)dval; Bu tür dönüşümlere yani int'ten double'a double'dan int'e dönüşümlere static cast denir.
		- C++'da bu kategorideki dönüşümleri yapmak için C++'ın static_cast tür dönüşüm keywordu kullanılır.
		  static_cast<target type>(expression) şeklindedir.

	not : const cast işlemleri : const char * türünden bir türü char *'e cast etmek.strchr'deki durum(2123)

	alt seviyeli c kodlarında tür dönüşümü çok riskli olabilir.

	Student türünden bir nesne char *p = (char *)&s;

	- static_cast --> enum int dönüşümleri de bununla yapılır.


	- her tür dönüşüm operatörünün kendi yapabileceği bir iş vardır.,
	- reinterpret_cast --> yeniden yorumlamak. Farklı türden bir nesneyi değiştirir. Örnepin int *'dan char *'a dönüşüm sağlanır.
	-----------------------------
	- dynamic_cast(C karşılığı yoktur.) Nesne yönelimli progragmlama ile ilgilidir. run time polymorfizmi ile alakalıdır. Yani kalıtım ile


	Yukarıdakiler tür dönüştürme operatörleridir. Ve hepsinin ortak bir sentaksı vardır.

		-static_cast<int>(expression)
			- burada <> parantez içerisine hedef tür yazılır.

		-static_cast ile randomize işlevi : srand(static_cast<unsigned>(time(nullptr))); şeklinde olabilir.(2067)
		Not : unsigned ile unsigned int arasında herhangi bir fark yoktur.
		- Bu uzun diye sakın C'deki type cast'i kullanma.

		- const_cast örneği(2116)
			char * yerine const_cast<char *>(p) şeklinde olur.

		- reinterpret_cast(2142)

		Not : Zorlayacak neden bir yok ise C'deki type cast operatorleri kullanma.

		const int *func();

		int main(){
			reinterpret_cast<char * >(func());//bir hatadır.
			const_cast<char *>(reinterpret_cast<const char * >(func()));
			reinterpret_cast<char *>(const_cast<int * >(func()));    (2163);
		}

		- C++'da da bir nutility.h oluşturuldu.(sl)


		Not : using namespace std; implementasyon dosyaları içindir. Başlık dosyalarında gerek yoktur. Eklenmemelidir.
		--------------------------------------------------------------------------------------------------------------------------------------

	--------------------------------11.11.2017 CUMARTESİ------------------------------------

	Not : dizi boyutunu ifade eden değer constant expression olmalıdır. C++'da bu derleme zamanında belirlenmelidir.(2201)
	- Eğer bir fonksiyonu constexpr keyword ile belirtirsek bunu compile time da derleyici değerin kaç olduğunu bilir.(2201)
	- Ama burada fonksiyona göndereceğimiz değerde bir constexpr olmak zorundadır.
	- constexpr --> const int x = 10; constexptr int x= 10;
	- compile time da hesaplanabilecek bir değer asla run time da (C++11'den sonra ) hesaplanmamıştır.
	- eğer const bir nesneye constant expression bir nesne ile değer verilirse const nesne constant expression sayılır.(const int x = 10)
	- Derleyici bir ifade gördüğü zaman eğer bu compile time da hesaplanabilieen bir ifade ise bunu comple timeda constexpr olarak hesaplar. Değilse zaten runtime da
	  fonksiyona girince hesaplanacaktır.
	-- constexpr keyword:
		1- const ile constexpr farklı bir keyword'dur.const int x = 10; // x burada constant expression'dır.
													  const int x = func() // x burada constant expression değildir.(2201)
		2- constexpr int  x = func();//geçersizdir. constexpr'ye ilk değer verirken constant expression olması zorunludur.
			Not : const bir nesneye ilk değer verilmesi zorunludur.

	Not : constant expression bbir ifadeye ilk değer veren ifade constant expresion olmak zorundadır.

		3- constexpr int x = exp;
			- Burada iki farklı amaç vardır.
				1- okuyucuya bu ifadenin constant expression olduğunu belirtiriz.
				2- ve biz de exp'ının constexpr olup olmadığını biliriz.
		- bir pointer'ın const expression olması için ona verilen adresin statik ömürlü nesne adresi  olmalıdır.()
		int x = 10;
		int main(){
			constexpr const int *ptr = &x;//constexpr yüzünden ptr'yi değiştiremeyiz. ve constexpr gereken bir ifade de kullanılabilir.
			// const ise sadece *ptr'yi okuma amaçlı kullanacaktır.
		}

		- bir ifadenin constexpr olup olmadığını anlayıp anlamak için ya aynı türden constexpr bir nesneye atarız. yada bir dizinin boyutu haline getirilmelidir.
			-const int x = 10;
			 int z = 10;
			 constexpr int y = x; //legaldir.
			 constexpr int w = z; //legal değildir.
		-C++'da sabit ifadesi gereken yerler ileride template'lerde hayati önem taşıyacaktır.

		int main(){
		int x = 10;
		const int *const ptr = &x
		// constant expression gereken yerlerde ptr yi kullanamayız. ptr'nin constant expression olma ihtimali yoktur.

		- constexpr,
		}

		--------------------SINIFLAR-----------------

		not : procedurel programlamada temel yazılım birimi fonksiyonlardır.
		- nesne yönelimli programlama da paradigma da ise bu tamamen sınıflara ayrıştırılarak yapılmalıdır.(ayrıştırmalar class'lara yöneliktir.)
		Not : C++ hem nesne yönelimli programlamaya destek vermektedir. istediğin paradigma da program yazabiliriz. İstersen kombine de edebiliriz.
		- Sınıflar nesne yönelimli program da temel yapıtaşıdır.
		- C'de en yakın karşılığı struct'lardır.
		- Ama C++ daki yapılar da birer sınıftır. C++'daki struct anahtar sözcüğü ile C'deki nin anlamı tamamen birbirinden farklıdır.
		- class C++'da bir türdür.
		- class MyClass {

		}; //Bir definition'dır.

		- class definition'ları client'lar bu türü kullanacaksa kesinlikle başlık dosyasında olmalıdır(Hemen her zaman başlık dosyasında olur). diğer türlü .cpp dosyasında bulunur.
		- implimantasyon kullanacak ise .cpp dosyasında olabilir. Çoğunlukla sınıf ile başlık dosyasının adı aynı isimde olmalıdır.
		- başlık dosyasının ismi de tür ismi ile aynı olabilir.

		- struct Data {

		};
		-  C'deki gibi typedef bildirimi olmadan da bu türün ismi Data'dır.(Struct data gibi değildir.)

		class Data {

		};

		- C'de elemanı olmayan bir yapı sentaks hatasıdır. C++'da ise bu geçerlidir.(ileride öğreneceğiz).

		- C++'da struct'ta olsa class' da olsa ikiside class'dır.iki farklılığı vardır.(Daha sonra göreceğiz.)

		class Data {
			int mx;
			void func();
			typedef int WORD;
		};
		- bu sınıfın içinde bildirim yaparak isim tanımı yapmak mümkündür.Bu isimelere class member denir.
		- 3 çeşit member vardır.
			1- Data member
			2- member function
			3- type member(typedef int Word sınıfın içinde yapılmış olmalıdır.)
		- mx bu sınıfın bir data member'dır.(değer tutan eleman anlamındadır).
		- C++'da bir sınıfın içinde bildirilen fonksiyonlar vardır.func bunlara member function denir.
		- sınıfın içinde bildirilen fonksiyonlar farklıdır. Diğerleri C'deki gibi  globaldir.
		- C++'da global fonksiyonlara(global function yada free function denilir.)
		- member function ve global function arasındaki fark sadece semantik açıdandır.
		- typedef int WORD type member(member type)'dır.(2300)

		- class'lar aynı zaman da bir scope'tur.
			-C++'da class scope denilen kavram vardır.bu scope sınıfın içinde bildirilen isimleri karşılar.

		- C'de member function yoktur.
		- C'de structure scope diye bir scope yoktur. C++'da class scope vardır.

		- class scope'un olması namelook up'ı etkiler.
		- Derleyicinin bir isme ararken sınıfın içine bakması için bazı koşulların gerçekleşmesi gerekir. Bu koşullar oluşmaz ise
		  Derleyici gidip class'ın içine bakmaz

		- global fonksiyonlarda kullanılan bir ismin class'larda aranması için
			1- isim, nokta operatörünün sağ operandı olarak kullanılmışsa
			2- isim, ok operatörünün sağ operandı olarak kullanılmışsa
			3- isim, binary ::(scope resolution operator) operatörünün sağ operandı olarak kullanılmışsa(2315)

		- ismin aranıp bulamaması zaten errordur.
		- isim aramanın başarılı olması ismin kullanıldığı yerde bir sentaks hatası olup olmayacağı farklıdır.
			1- . operatörünün sağ operandı(binary infix bir operatördür. C ile aynıdır.)
				x.y eğer x sınıf türünden bir nesme ise burada y, x'in ait olduğu sınıfta aranacak.
			2- ptr-> y eğer ptr bir sınıf türünden adres ise burada y ismi ptr'nin ait olduğu sınıfta aranacak.
			3- Myclass::x eğer Myclass bir sınıfın ismi ve  x bu sınıfta aranacaktır.

		Not : C'deki yapılardan önemli bir farkı da şudur. PUBLIC, PROTECTED, PRIVATE  kesinlike scope değildir.
			- class scope'taki isimler bulunduktan sonra birde bu kodun bu ismi kullanma yetkisi olup olmadığı kontrolünden geçecektir.
				- Buna access kontrol(erişim kontrolü) denir.
			- sınıfın PUBLIC bölümünde dışarıya açık yani erişim konusunda hiç bir kısıtlama yoktur..
			- sınıfın PRIVATE bölümünde client buraya erişemez.(can not access in PRIVATE). Sadece sınıfın kendi fonksiyonları erişebilir.
			- C'deki bütün yapılarda erişim PUBLIC'dir.
			- Ve bunlar C'de yoktur.
			- PROTECTED C'de olmayan bir araç olan kalıtımdır(inheritance). client buraya da erişemez.
			- PROTECTED kalıtım uygulandığında ancak aktif olabilir. Yani  kalıtım olmaz ise private bölğmden herhangi bir farkı yoktur.
			- Yani PROTECTED bölümü client'lara kapatılmış, ama kalıtım yoluyla elde edilecek sınıflara açılmıştır.


			- C++'da bu keyword'leri bölgesel olarak kullanabiliriz. Herhangi bir memberına verilmez.(örneğin public int x;)
			- class'ların genel erişimi default olarak PRIVATE'tır. struct'larda bu PUBLIC'tir.


			class Data{
			public:
			//
			protected:
			//
			public:
			//
			}

			- burada public: ifadesinden başlayan ifadeler public'tir.ve eğer başka bir sözcük kullanılmamış ise hepsi(2345)
			- protected: kalıtım olmadığında kullanılır.
				class Data{
			public:
				void func();
			private:
				int mx, my;
			}(2360);

			class Data{
				int mx, my; //private
			public:
				void func();
			}

			- eğer bir zorunluluk değilse istediğimiz konvensiyonu kullanabiliriz.

			class Data{
				int mx;
			public:
				double mx;//geçersizdir. Çünkü public, private, protected scope değildir.
			};(2382)


		- erişim hatası(2390)
		- foo'ya erişilirken diğer fonksiyon member'a erişim kapatıldı.(2409)


		- ilerleyen saatlerde data member'ları kendi içinde iki'ye ayıracağız.
			1- non-static data member
			2- static data member

	class Data{
	int mx;//non-static data member
	static int my; //static data member
	};

	- non-static data member C'deki struct'ın nesneleri gibidir.(fiilen sınıf nesnesi içerisindedir.)
	- non-static türünden bir nesne eklemek sizeof'u doğrudan artırır. C'deki structlar  gibi olacaktır.
	- statik veri elemanlar ise C'deik global nesne'ler gibidir. tek farkı scope'ları global nesnelerin file scope iken
	  static veri elemanlarının ise class scope'tur.
	- Sınıfın static veri elemanları fiilen sınıf nesnesi içinde değillerdir. (2440)
	- Sınıfın static veri elemanları kaç tane nesne olursa olsun bir tanedir. Bu sınıflar için ortaktır.
	- Sınıfın statik veri elemanları başlık dosyasında(Sınıfın içinde) değil kaynak dosyada(Sınıfın dışında) initialize edilir.
	- Eğer sınıfın içinde initialize edilecekse nesne const olmalıdır.



	- class bir ismin sözlükteki tanımı gibidir. class bizim domain'imizdeki sorunları çözmek için kullanılan varlıkları ilişkin türlerdir.
	- Yani class bizim için soyut bir nesnedir. Nasıl bir şey olduğunu ve neleri olduğunu anlatır. Ne zamanki bundan bir nesne oluşturursak bu bizim için object,instance yada nesne denir.
	- Nesnelerin data member'ları genel olarak o nesneye ilişkin bilgileri tutar.
	- nesnelerin member'ları specific özellikleri tutar.
	- sınıfların non-static veri elemanları sınıf nesnesinden sınıf nesnesine göre değişebilen elemanlardır.
	- sınıfın static veri elemanları ortada object olsun yada olmasın vardır.
	- object olmadan bir anlamı olmuyorsa bunlar non static veri elemanıdır.
	- elemanların sınıfın private bölümünde oluşturulması
		1- öğrenme yükünü giderir.
		2- eğer bunlar kullanılsaydı bunlarda yapılan değişiklikler beni de etkileyecektir. Bu yüzden private koruması
		bizi korumaya yönelik bir korumadır.Yanlış kod yazma riski de büyük ölçüde elimine edilmiştir.
		3- kontrolsüz bir şekilde veri elemanlarını kullanmamızı engeller.

	- Sınıfın private bölümünü tamamen gizleme olanağıda vardır.(Bunu ileride göreceğiz.)

	Not : global fonksiyonlardan member_function'a geçiş makine kodu düzeyinde herhangi bir değişiklik sağlamaz.

	- Sınıfın non-static fonksiyonlarının hepsi arka planda interface'de gözükmeyen o nesnenin adresini tutacak bir değişken bulunur.
	- non-static bütün fonksiyonlar kaç parametresi var ise arka tarafta bir fazlasına sahiptir. O nesne türünden adres tutan bir pointer'dır.

	- sınıflar'ın member function'ları overload edilebilir.(2486)
	- Sınıfın public, private yada protected bölümü ayrı scope'lar değildir.
	- bizim fonksiyonlarımız çoğunluğu member_function'dır.
	- functionoverloading vardır.(2507)

	- member_function'larda  static yada non-static olabilir.
	- non-static member_func'ların arka planda bir fazla parametresi vardır(pointer türünden bir nesne).
	- örneğin derleyici
	- mydate.set() gibi bir fonksiyonuna aslında parametre görsel olarak gönderilmezken arka planda mydate'in adresi gönderirilir.
	- static member_func'larda fazladan bir parametresi yoktur.
	- çözünürlük operatörünün önceliği 1. öncelik seviyesindedir.(Hatta bu operatör en yüksek seviyeden operatör diyebiliriz.)
	- static member function'ların object(instance) ile hiç bir alakası yoktur.

	- global fonksiyonların gizli bir parametre değişkeni yoktur.
	- global fonksiyonlar'ın C++'da public private protected ayrımı yoktur. Ancak C'de ki bilgilerimiz ile yapabiliriz.
	-  Global fonksiyonlar sınıfın private bölümüne erişemez.
	- C'de ki isim arama kuralları C++'da da vardır. Sadece üye fonksiyonları için isim arama kuralları böyle değildir.
	- üye fonksiyonların tanımları kaynak dosyasında olacaktır. Bildirimi başlık dosyasında bulunur.
	- üye fonksiyonların tanımları kaynak dosyasında belirtilirken void className::func(int x, int y, int z);
	- sınıfların non-static member functionları için adres operatörü kullanma şartı vardır. Myclass::func yanlış bir kullanımdır. &Myclass::func olmak zorundadır.
	- Ama  static veri elemanları için bu kullanıma gerek yoktur

	- üye fonksiyonlar için arama ilk önce blok içerisinde arayacak eğer bulamazsa class içerisinde arayacaktır.
	- //Data.h
		class Data{
			int mx, my, mz;
		public:
			void set(int x, int y, int z);
		}
	// Data.cpp
	void Data::set(int x, int y, int z)
	{
		mx = x;
		my = y;
		mz = z;
	}
	//Burada arka planta &data1->mx = x &data1->my = y &data1->mz = z;

	- bir ismi C++'da global name space'de aramanın unary :: operatörü kullanarak ::mx ile yapılabilir.(2527)
	- eğer mx global alanda bulanamaz ise error verecektir.
	- maskeleme olsa bile her zaman maskelemeyi çözmenin bir yolu vardır.
	- bir üye fonksiyon başka bir üye fonksiyonu çağırdığında ikiside non-static ise aldığı adresi diğer fonksiyona
	  verecektir.
	- Soru direk hatadır. Çünkü func ismini blok içinde arayacaktır. sonra class içinde arayacaktır.(2622)
	- Global fonksiyon ile member fonksiyon function overload olmaz. olsa olsa birbirini gizlerler.
	- üye fonksiyon hem recursive çağrı hemde global fonksiyona çağrı yaptı(2647).

	- Myclass::x ismi Myclass scope'unda arayacaktır. ::x ismi sadece global alanda arayacaktır.

	- member function sınıfın private bölümüne erişebilir.

	void Data::set(int x, int y, int z){
		mx = x;
		Data data1;
		data1.mx = 45;
	}


	//.h
	class Data {

	public:
		void func();
		void foo();
	};

	//.cpp
	void Data::foo(){
		func();//Derleyici foo fonksiyonunu hangi nesne için çağrırsa func fonksiyonunuda aynı nesne için çağıracaktır.
	}



	- ister global nesnelerin private elemanına, ister yerel nesnelerin private elemanına aynı sınıfın member fonksiyonu ile
	  erişim geçerlidir. Yani member function sadece çağrıldığı nesne için değil kendi bloğu içinde tanıtılan herhangi bir nesne için doğrudan private bölüme erişim imkanı sunar(2713)
	- member function'lar için redeclaration edilmez.(2648)
	- access kontrol C++'da her zaman en son yapılır.
	- function overload resolution daha önce yapılır. access control daha sonra yapılır.(2670)
	- derleyici böyle bir func fonksiyonu olmadığı için hata verecektir.(2590)
	- C++'da bir fonksiyonun definition'ı kesinlikle fonksiyonun private'mi public mi olduğunu kesinlikle bunu söylemez.
	- Bir fonksiyonu sınıfın içinde tanımlamak onu inline function yapar.
	- Bunu sadece makrolar ile yapabiliriz.
	#define PUBLIC
	#define PRIVATE
	#define PROTECTED

--------------------12.11.2017	PAZAR---------------------

- const member function
	- const member function, member function'ın nesneyi değiştirmeye yönelik mi okumaya yönelik mi olduğunu gösterecek sentaksdır.
	void func()const == (C'de)void func(const T *ptr);
	void foo() == (C'de)void func(T *ptr);

	- Derleyici const member functionlarda bizim için parametresi const T * olan bir fonksiyon yazacaktır. void func()const; --> void func(const T *ptr); şeklinde arka planda bir fonksiyon olacaktır.


	class Date {
	public:
	void display()const;
	};
	- Date mydate;
	  mydate.display()//display fonksiyonu constbir fonksiyon olduğu için nesneyi okumaya yöenelik bir fonksiyondur.
	- client gözü ile baktığımızda nesnenin öz nitelekleri değiştirilmeyecekse eğer const olmalıdır.
	Not : nesne yönelimli programlama da her zaman interface implementasyondan önce gelir.//ilk olarak başlık dosyaları yazılır. sonra içinin kod yazılır.

	- fonksiyonun const olup olmayacağı tamamen problem domaini içerisinde ki gözlenebilir bir değeri değiştiriyor ise const olamaz.

	- ismi get olan fonksiyonlar çok özel bir durum yoksa const olmaları gerekir.

	- derleyici void func()const; şeklinde bir fonksiyon tanımı görürse bunun gizli  parametresinin
		const T *ptr şeklinde yapar.

	- const bir üye fonksiyonunun içinde onun non-static bir veri elemanını set amaçlı kullanmak sentaks hatası
	  olacaktır.
	- const anahtar sözcüğü imzanın bir parçası olduğundan dolayı bildirimde de tanımda da olmalıdır.

	- const bir üye fonksiyonun const'luğundan dolayı non-static veri elemanını değiştiremeyeceği(2732)

	- C'de const T*	'dan T*'a dönüşüm yanlıştır ama legaldir(Zaten lojik olarak yanlıştır.). C++'da error.

	- const bir sınıf nesnesini  sınıfın const olmayan bir member function ile çağırmak geçersizdir.

	void func(int *p);
	void func(const int *p);
		- böyle bir durumda kendisi const bir nesne ile çağırılır(const int x; ) ise const olan kendisi const olmayan bir nesne ile çağırılır
		ise  const pointer olmayan  fonksiyon çağırılır. Buna const overloading denir.
	------------------------------------------
	class Myclass{
	public:
		void func();//1
		void func()const;//2
	}
	int main()
	{
		Myclass m;
		const Mylcass cm;

		m.func(); ile 1. fonksiyon çağırılır.
		cm.func(); ile 2. fonksiyon çağırılır.
		// bu bir function overloading'dir. standart kütüphanenin bir çok yerde kullanır.
		//ayrıca bir const overloading'dir.
	}
	------------------------------------------

	- bir non-static üye fonksiyon başka bir non-static fonksiyonu çağırırken kendi aldığı adres'i
	çağırdığı fonksiyona iletir.(2905)
	- const bir non-static üye fonksiyon içinde asla ve asla sınıfın const olmayan bir üye fonksiyonunu çağıramayız.(2925)

	- const T*'dan const T*'a dönüşüm yapılmıştır.(2941).
	- Sınıfların const üye fonksiyonları sınıfın başka const üye fonksiyonlarını çağırabilir.

	-class A{
	public:
		void func();
		void func()const;
	};

	void A::func()
	{
		func();//derleyici function overload resolution'dan dolayı recursive call'dır.
	}(2959)

	- gene const T*'dan const T*'a dönüşüm olup recursive fonksiyon olur.(2995)

	- Sınıfın const üye fonksiyonları içinde sınıfın const olmayan üye fonksiyonlarına çağrı yapmak legal değildir.
			class Myclass{
			public:
				void func()const{
					foo();//error
				}
				void foo(){
					func();//legal
				}
			};

	---this keyword---

	- this keyword'u sadece ve sadece sınıflar'ın non-static member function'ları içinde kullanılır.
	- this keyword'u bir pointer'dır.(this pointer denir).
	- this poniter'ı yazmadığımız parametre değişkenini temsil eder. Yani bu non-static fonksiyon hangi nesne için çağırılırsa
	  this o nesne'nin pointer'ıdır.
	- this ile nesnenin adresi aynıdır.
	- bir non static member function'ın içinde nesneye ait mx non-static data member'ı iki şekilde değiştirilir.
		1- mx = 15;
		2- this->mx = 15;
	- Ama burada this->mx kullanılmasına gerekte yoktur.
	- C++'ta gerekmedikçe this keyword'u kullanmayın.(Sınıfın non-static data member'ına erişirken yada sınıfın non-static member function'ına erişirken)

	- this keyword'unu kullanmayı gerektiren bazı senaryolarvardır.
		1- hangi nesne için çağrıldıysa o nesneyi döndürmesi gerekir.
			Myclass &func(){

				return *this;
			}
			- *this bir fonksiyon hangi nesne için çağrılmışsa o nesnenin kendisi demektir.

	- Bir nesne için çağrılıp o nesnenin kendisini döndürmesi çok klasik bir pattern'dir.
	  Buda nesne'nin refereansına geri dönmesi ve *this ile return edilmesi gerekmektedir.

	- bir sınıfın üye fonksiyonu hangi nesne için çağrılmış ise ve nesnenin adresini istiyor ise return this ile geri dönüş yaparız.

	- eğer nesnenin kendisini istiyor ise fonksiyonun geri dönüş değeri referens semantiği ile olup return *this olur.

	- Bir member function nesnenin kendisini geri döndürüyor ise bunun *this ile geri döndürülmesi zorunludur.

	- this default olarak top level const'tur. low level const'luğu ise tamamen const member function olup olmaması ile alakalıdır.

	Not : this her zaman top level const bir pointer'dır.(T *const this);
	-this = nullptr bir //hata verecektir.


	- mutable anahtar sözcüğü : sınıfın bir non-static bir veri elemanı mutable ile tanıtıldğında bu veri elemanının sınıf nesnesinin gözlenebilir değeriyle bir ilgisi yoktur.
	  Bunun değişmesi sınıf nesnesinin değişip değişmemesi ile ilgili değildir. const üye fonksiyonlar da bu nesneyi değiştirebilir.
	-------INLINE FUNCTIONS-------

	- inline expansion(inline açılım)
		- yazdığımız kodun daha hızlı çalışması için derleyicimizin yaptığı bir optimizasyon. Derleyici fonksiyonun
		  giriş çıkış kodlarını direk kendisi üretmesidir.
		- derleyicinin böyle bir optimizasyon yapması için olmazsa olmaz şeyler
		  1- çağırılan fonksiyonun tanımı ile çağıran fonksiyonun tanımı aynı kaynak dosyada olmak zorundadır.
		  2- söz konusu fonksiyonun satır sayısı çok fazla olmamalıdır.
		  ........
	Not : C'de inline fonksiyonlar C99 ile gelmiştir.
		- inline int square(int x){
			return x * x;
		}
		- Derleyici fonksiyonun sadece tanımını görüyorsa geri dönüş değerini inline yapmak.

		- derleyicinin bu fonksiyonun çağrılmasının tanımda ya da bildirimde bir kez inline keyword'u kullanmak
		  yeterli olacaktır.

		- inline expension'dan çokça faydalanmak istiyorsak kodu kısa olup sıkça çağırılan fonksiyonlar tercih
		  edilmelidir.

	- C++'da sınıfların üye fonksiyonlarının da inline function olabilir.
	- C++'da inline function'ların tanımının yeri kesinlikle başlık dosyasıdır.

	- C++'da başlık dosyasında 3 önemli istisna dışında kod olmaz. Bildirimler olur.
		1- inline functions
		2- function templates
		3- constexpr functions

	//date.h
	class Date {
		int md, mm, my;
	public:
		int getMonthDay()const{
			return md;
		};
	};

	- C'de ve C++'da global fonksiyonların inline olması için aynı dosyada olması gerekir. ikisinde de inline anahtar kelimesi hem declaration hem de definition'ın önüne gelebilir. Sadece birisine de konulabilir.

	- C++'da bir fonksiyonun implementasyonunu class içinde yapmak fonksiyonun inline function olmasını sağlar. inline anahtar sözcüğünü koymak zorunlu değildir.

	- fonksiyonun inline olup olmaması fonksiyon çağrı semantiğinde bir değişim göstermez.

	- sınıf içinde inline olarak açılmaması  isim arama kurallarında bir değişiklik yapmayacaktır. İsim arama kurallaro class scope'un heryerinde yapılır(3238)

	- derleyici fonksiyonun kodunu görmemesi durumda derleyicinin bir vazife çıkartıp inline yapması mümkün değildir.

	Not : kodu yazarken optimize etmek hiç iyi bir fikir değildir.

	- data member
	member functions
		const member functions
		const overloading
	access control
	mutable keyword
	this keyword
	constexpr
	inline functions
	-- konuları işlendi


	SPECIAL MEMBER FUNCTIONS
	(ÖZEL ÜYE İŞLEVLERİ)

	constructor // nesneyi hayata getirme
		default constructor
	destructor
	copy constructor
		copy assignment function

	C++11 ile gelen
	move constructor
	move assignment functions

	 - dynamic objects
	 - new / delete operators

	- bir nesnenin bellekteki yerini edinebilmesi başka, o nesnenin  işini görebilecek olabilmesi olması başka bir olaydır.

	- constructor -->özel bir member function'dır.
	- bir sınıf nesnesini hayata getiren işlev sınıfın kurucu işlevidir(constructor).(3284)
	- bir sınıf nesnesi constructor kodunun run time da çalışması bittikten sonra hayata gelmiş kabul edilir.(3286)
	- constructor çalışmadan bir bellek alanı olabilir. ama hayata geldiği söylenemez.
	- constructor  sınıfın ismi ile aynı isimli işlevdir.
	- derleyici constructor olduğunu bu isimden dolayı anlar.
	- constructor geri dönüş değeri diye bir kavram yoktur.
	  Yani burada geri dönüş değeri yerine bir şey yazmayacaz.
		---------------------------------------------------------
		class Fighter{
		public:
			Figter();//constructor. zaten implicit int diye bir şey yoktur
		}

		----------------------------------------------------------

	- C++'da constructor sınıfın static işlevi olamaz. non-static member_function olmak zorundadır.
	- constructor sınıfın const member_function'ı olamaz.
	- kurucu işlevler herhangi bir parametrik yapıda olabilirler.
	- constructor sınıfın diğer member_function'ları gibi overload edilebilirler.
		class Data{
		public:
			Data(int);
			Data(double);
			Data(const char *);

		};

	- bir sınıfın constructor'ları sınıfın public private, protected işlevleri olabilirler.(Ancak çok büyük çoğunlukla public olacaklardır.)
	- sınıfların constructorlar nokta yada ok operatörleri ile çağırılamazlar.

	- bir sınıfın
		a) parametresi olmayan
		b) parametresi olan ancak tüm parametreleri varsayılan argüman alan constructor'larına
		varsayılan constructor(default constructor) dır.

	-Argüman gönderilmeden çağırılabilecek kurucu işlevler
Not : özel fonksiyon
	- eğer bir sınıf için programcı bir constructor yazmamış ise derleyici söz konusu sınıf için
		a)non-static
		b)public
		c)inline bir constructor kodu yazar.

	Not : Ortada hayata gelmiş bir nesne var ise mutlaka constructor çağrılmıştır.

	- Not : bir çok programlama dilinde yerel yada global sınıf nesnesi yoktur.
	- sınıf nesneleri de otomatik, statik ve dinamik ömürlü olabilir.

	- Dil de önce statik ömürlü nesneler hayata gelip ondan sonra main çağrılır.
	Test için g'ye bir constructor ekleyebiliriz.(3337)
	- tanımlanma sırası ile consrtructor'ın çağrılması arasında garanti bir ilişki vardır.
	- önce tanımlanan nesnenin constructor'ı daha önce çağıralacaktır.
	- otomatik ömürlü yerel sınıf nesneleri için constructor programın akışı oraya her girdiğin de tekrar çağrılacaktır.(3388,3442, 3463)
	- statik yerel nesnelerde durum biraz daha farklıdır. burada bir kez çağrıldıktan sonra bir daha constructor çağrılmayacaktır.

	--------------------------------------------------------------------------------------------------------------

	---------------------------18.11.2017 CUMARTESİ-----------------------------

	- Constructor sınıfın ismi ile aynı isme sahip olmasıdır. Geri dönüş değeri yoktur.
	- Constructor static function  olamaz.
	- public protected ya da private olabilir. ama çok büyük olasılıkla public olur.
	- Constructor ismi ile çağırılamaz.(Yani myclass sınıfından üretilmiş bir nesne m.myclass() şeklinde bir çağrı yapılamaz. )
	- Bir argüman gönderilmeden çağırılabilen constructor'a default ctor denir.(Ya parametresi olmayacak ya da bütün parametreleri varsayılan argüman şeklinde olacaktır. )
	- Eğer bir tane bile ctor yazılmış ise derleyici default ctor'ı yazmayacaktır.
	- C++11 ile gelen bir araç ile derleyiciye special  function'ların default edilmesi için kullanılır. Özel fonksiyonlar C++11 ile
	  Myclass() = default; // fonksiyonunu derleyiciye yazıdırırız.
	- Bunu yapmanın kendimiz'in aynı kodu yazması arasında bazı teknik farklılıklar vardır.

	- main.c dosyasının olduğu dosyanın ismi main yada driver adı verilir.
	- Not : mecbur olmadıkça global nesne kullanmayın.
	- Farklı modüller(kaynak dosyalar) de tanımlanmış statik ömürlü sınıf nesnelerinin hayata gelme sırasına ilişkin dilin kurallarının
	  bir belirleyiciliği yoktur.

	Not : Program daha başlar başlamaz run time da çökerse bunun nedeni global nesneler ile alakalıdır.

	Not : C++ gibi bir dil için, C tarzı dizi'ler alt seviyeli kalmaktadır. Kullanılmasında herhangi bir sentaks hatası
		  olmayacaktır. Ama kullanılmaması daha çok tercih edilebilir.
		1- ya vektör veri yapılarını kullanırız.(dinamik bellek yönteminden dolayı fazlaca maaliyeti olabilir.)
		2- yada array isimli bir sarmalayıcı sınıf(Bildiğimiz dizidir. ama sınıf ile sarmalanmıştır.)

	- header file'da asla using name space kullanılmamalıdır.

	- pointer değişken tanımlamak bir sınıf türünden nesne yaratmak anlamında değildir.
	  pointer değişken ile constructor çağrılmaz.

	- referans semantiğinde de aynı durum geçerlidir.(3707)

	- Bir nesne'nin constructor'ının hayata gelmesi için şu yollar izlenebilir.
		- direk olarak nesne oluşturmak(Myclass m);
		- uniform initializer ile(Myclass m{});//C++11
		- constructor'ına çağrı(Myclass::Myclass()) --> geçici bir nesne oluşturacaktır.
		- Nesne'yi Myclass m(); şeklinde initialize edemeyiz. bu bir function declaration olacaktır.

	Not : C'de ve C++'da fonksiyonlar'ın declaration'ları yerel yada global olabilir.

	- default constructor
		- parametresi olmayan yada her bir parametresi var sayılan argüman olacak.
	- eğer default constructor kullanılmayıp nesne çağrılır ise derleyici sentaks hatası verir.

	- uniform initilazier Myclass m1{} ; ile nesneyi default constructor ile hayata gelecektir.

	int x = 10;
	int y(20);
	int z{30};

	- uniform initializer ile veri kaybı olan(double'dan int'e)(narrowing conversion) bir atama yapılması sentaks hatasıdır.

	--- destructor---

	- bir sınıfın sonlandırıcı işlevidir.
	- bir nesnenin hayatı bittiğinde çağrılır.
	- ismi sınıfın ismi ile aynıdır. constructor ile karıştırılmaması için ismin başına ~ karakteri alır.
	- parametresi olamaz. sınıfın destructor'ı parametresi olmayan bir işlev olmak zorundadır.
	- varsayılan argümanıda olamaz.
	- overload edilemez. Yani bir sınıfın yalnız ve yalnız tek bir destructor işlevi olabilir.
	- sınıfın non-static üye işlevi olmak zorundadır.(static üye işlevi olamaz.)
	- public/protected/private olabilir.
	- const member function olamaz.(~Myclass()const{} şeklinde bir uazım yoktur.)
	- geri dönüş değeri kavramı yoktur.

	- ismi ile çağrılması sentaks hatası değildir.(ileride inceleyeceğimiz tek bir durum dışında ismi
	  ile destructor işlevini çağırmayın).
	**- destructor özel bir üye işlevdir.(1.si default constructor'tır. yani bir sınıfın destructor'ı olmak zorundadır).
	    programcı yazmaz ise derleyici ilgili sınıf için
		1-) non-static
		2-) public
		3-) inline
		bir destructor yazar.

	- sınıfların çoğunluğu için constructor yazmamız gerekmektedir. Ama destructor için bu her zaman geçerli değildir.
	  Bu sadece sınıf nesnesinin hayatı bitişinde destructor'ı yazmamız gereken en az bir neden olması gerekmektedir.

	- resource acquisition is initialization(RAII)(Kaynak edinimi ilk değer verme yoluyla olur.)
		- bazı sınıf nesneleri işlerini görebilmek için bazı kaynaklar kullanır.
		- Bu kaynakları constructor nesneye verirken destructor iade edecektir.

	- özellikle yazı tutan sınıflar için bellekte bir yer gerekmektedir. Ve bu dinamik bellek yönetimi ile yapılacaktır.
	  Bu RAII ile yapılackatır.
	- RAII nesneleri için kullanıcının destructor'ı kendisi çağırmalıdır.
	Not : bu fonksiyonlar'ın kodunun hiç birinin inline olma zorunluluğu yoktur.

	- global sınıf nesneleri main çağrılmadan hayata gelip main bittikten sonra hayatı sona erecektir.
	- yerel nesnelerde main çağrıldıktan sonra constructor ve main bitmeden destructor çağırılacaktır.(3934)
	- fonksiyon birden fazla çağrıldığında da aynı işlem olacaktır.(3970, 4010)
	- static yerel nesnelerde ise main bittikten sonra destructor çağırılacaktır.(4070);

	Not : static yerel nesnelerde ise constructor ve destructor bir ekz çağırılacaktır.

	**- eğer hayatta 2 sınıf nesnesi varsa constructor'ı daha sonra çağırılan nesnenin destructor'ı daha önce çağrılır.(4134)

	--- Dinamik ömürlü nesneler -1  ---

	- C++' ta en zor şey dinamik ömürlü nesnelerdir.
	- C++'ta dinamik ömürlü bir nesne hayata geldiğinde bunun hayatının bitirilmesi tamamen bizim sorumluluğumuzdadır.

	- dinaimik ömürlü nesneler istediğimiz zaman hayata getirip istediğimiz zaman hayatını sonlandırabileceğimiz nesnelerdir.
	- Nesnenin hayatının bitmesi de tamamen bizim sorumluluğumuzdadır.(resource leap'le alakalıdır.)

	- dinamik bellek yönetimi dinamik ömürlü nesneyi karıştırmamalıyız.


	- otomatik ömürlü ve statik ömürlü nesnelerin storage'ını compiler elde edilir.

	- kaynak olarak kullanılacak bellek alanına resource denir.
	- örneğin necati ergin stringini gönderdiğimiz bir fonksiyonda necati ergin resource da tutulacaktır.
	  Burada resource ile storage'ı karıştırmamamız gerekir.Resource genel olarak yazıların tutulduğu bellek alanıdır.
	  storage ise bir nesne yaratıldığı zaman o nesne için ayrılacak bellek alanının bulunduğu alandır.

	- kısaca storage bir nesne'nin kaç byte'lık alana ihtiyacı var ise o yerin karşılandığı alana denir.
	- resource ise bir nesne'nin kullanacağı gerekli veri'lerin alınacağı alan ise resources'tır.

	- otomatik ömürlü, statik ömürlü bir nesne için onun storage ihtiyacını compiler karşılar.
	- dinamik ömürlü nesnelerin storage'ı(run time'da elde edilir) default olarak dinamik bellek yönetimi ile elde edilir. Ama bu zorunlu değildir.

	- dinamik bellek yönetmin de iki farklı şey gerçekleşir.
		1- bir storage elde edilmesi
		2- bu elde edilen storage'ın adresini this adresi olarak alıcak bir ctor'ın çalışması


	- Dinamik sınıf nesneleri nasıl oluşturulur.
		- C++ dilinde dinamik ömürlü nesneler operatör kullanımı ile hayata getirilip
		  yine operatör kullanımı ile bunların hayatı sonlandırılır.(4280)

		- Burada hayata getirmek için kullanılan operatörler new operatörleri'dir.(Birden fazla new operatörü vardır.)
		- nesne'nin hayatını sonlandırmak için delete operatörleri kullanılır.

	- operator new bir fonksiyondur.(malloc benzeri bir fonksiyondur. neredeyse aynısıdır.)

	- operator new'in kullanılma sebebei malloc'un exception handling mekanizmasına sahip olmamasıdır.()
	- void *operator new(size_t n);
		operator new(n);

		new Fighter //ile aşağıdaki işlem arkada gerçekleşir.
		(static_cast<Fighter *>(operator new(sizeof(Fighter))))->Fighter();//sadece görünüm amaçlıdır.
	- new ifadesi ile yeni bir nesne oluşturulduğunda
		 - operator new ile sizeof(size_t n); n byte'lık yer ayırıp bu yerin adresini this olarak kullanıp
		 - daha sonra bu this adresi için constructor'ı çağıracaktır.
		 - eğer ilave bir araç oluşturmazsak pointer  kullanmak zorundayızdır.
	Not:  C++'da void * otomatik olarak başka bir türe cast edemeyiz.

	- new Figter 'ın ifadesinin türü Fighter * türünden'dir.
	Figter *p = new Fighter;(4296)

	- Yeni bir C++ kodunda Fighter *p = new Fighter; yerine smart pointer kullanılacaktır.
	- //Fighter *p'ye raw(çiğ, ham) pointer denir.

	auto p = new Fighter; şeklinde kullanarak çok Fighter * ile uğraşılmamış olur.
	- Fighter *p1 = new Fighter;
	- Fighter *p2(new Fighter);
	- Fighter *p3{new Fighter};

	- Fighter *p4 = new Fighter();
	- Fighter *p5 = new Fighter{};
	// her birinde auto kullanabiliriz.
	- Fighter &f = *new Fighter; //şeklinde kullanabiliriz.
	- Bu sentaks açısından legal olsa da özel durumlar dışında kullanmamalıyız.

	- Bu nesnenin hayatını bitirmek yetmez sadece nesne'nin hayata getirilmesi için elde edilen kaynaklar'da geri verilmedir.
	- Burada tek sorun bellek sızıntısı olmayacaktır.

	- İleri zamanlar da dinamik ömürlü  nesneleri yönetmek için  smart_ptr kullanılacaktır. Kendisi de bir sınıf nesnesidir. Ama pointer gibi kullanılır.
	- unqie_ptr, shared_ptr

	- delete p; expression'ı görüldüğü zaman runtime'da
		1- operandı  olan adresin destructor'ına çağrı yapacaktır. (Yani constructor ile elde edilen kaynaklar iade edilecektir.p->~Fighter())
		2- operator delete fonksiyonu ile nesne'nin storage'ını geri iade edecektir.(Bellekteki storage iade edielcektir.)

	----------------------------------------------------------------------------------

	----------------------------------19.11.2017 PAZAR--------------------------------

	- Not : Bir nesne ile işimiz bittiğinde o nesne'nin hayatı bitirilmelidir.

	- nesnenin hayatı bitirilirken gene operatör kullanılır.
	- constructor bir takım kaynaklar elde ettiğini düşünürsek , bu kaynakların verilmez ise bunlar başımıza sorun açılabilir.
	- bu kaynakların geri verilmesi kullanıcı açısından sadece dinamik ömürlü nesneler için geçerlidir. otomatik ömürlü ve statik ömürlü
	  nesneler için derleyici destructor'ı kendi çağıracaktır.

	- eğer ilgili nesne dinamik olmaz ise ortada hiç bir problem olmayacaktır.

	- nesneleri hayatını bitirirken delete operatörü kullanılır.(operandı adres olmalıdır.)
	- delete operand olan adresin destrector'u çağrılmaktadır. Destructor burada kullanılan kaynakları geri vermektedir. resource leap.
	- nesne'nin hayatı bitmiştir. Ama nesne'nin kapladığı storage'ın geri verilmesi içinde operator delete fonksiyonu nu çağırır.// operator delete(p);
	- derleyici new Fighter dediğinde operator new'i çağırıp oradan aldığı adresi this olarak kullanıp operator new ile storage elde eder.
	- new operator'u overload edilemez. olsa olsa, operator new function'ını overload elde edebiliriz.
	- böylece bellek alanı elde edilme işlemi bizim istediğimiz şekilde gerçekleşir.
	- C++'da operator bir keyword'dur.
	Not : C'de anahtar sözcük olmayan bir isim kullanırsak bu C++'da operator, new gibi anahtar sözcüklerinden dolayı hata verebilir.
	- operator keyword'u, operator fonksiyonu dediğimiz fonksiyonların kullanılmasında kullanılır.
	- ismi operator keyword'u ile başlayan fonksiyonlar'a operator function olarak kullanılır. ve operator overload eder.
	- cout << x; ile operator overload denilen mekanizma vardır.

	- operator new ile malloc da aynı işlevi görmektedir.
	- opearator delete == free fonksiyonu aynı amaçı verir.
	- operator new ile elde edilen bellek bloğunu geri vermek için operator delete kullanılır.
	- dinamik olmayan bir nesneyi delete etmek runtime hatasıdır.
	- destructor içinde ki this, constructor içindeki this ve aldığımız dinamik nesne aynı adrese sahip olacaktır.(4764)

	- delete'e verdiğimiz adres yanlış bir adres ise yada çoktan delete edilmiş bir adres ise exception throw etmez. Standart kütüphane
	  eğer operator new başarısız olursa exception gönderecektir.
	- eğer constructor'ın parametreleri var ise dinamik nesneler için
		1-) auto p1 = new Fighter(45);
		2-) auto p2 = new Fighter{56};
		3-) auto p3 = new Fighter{2.3} //yazarsak ve constructor paramteresi int olursa uniform initializer'da tür dönüşümü olmayacağından dolayı sentaks hatası verecektir.

----- M.I.L(member initializer list yada constructor initializer list) sentaksı---

	- constructor'ların sınıf nesnesinin non-static member'ların bunlara ik değer verme için kullandığımız sentaksa denir.
	  (Bir sınıf nesnesi hayata geldiğinde onun non-static member'larını initialize etmektir. )
	- MIL kullanmak olunda zorunda olduğumuz bir sentaks değildir.
	- MIL Sentaksı sadece constructor için tanınan bir haktır.
	- static data member'ların constructor'la herhangi bir alakası yoktur. onlar sınıf nesnesi olmadan hatta main çağrılmadan önce vardırlar.
	class Data {
		int mx, my;

	public:
		Data();
		void display()const;
	}
	//data.cpp'de
		Data::Data() : mx(10), my(20)
		{
			std::cout << "Data::Data()" << std:: endl;
		}
		Data::display()
		{
			std::cout << "mx = " << mx << std::endl;
			std::cout << "my = " << my << std::endl;
		}(4862);
	- constructor'ın parametre'li hali olabilir.(4902)

	- constuctor'ın ana bloğunun için de de atama yapılabilir. ama bu initializer değildir.
	  bu assignment'tır. Ve arada çok fazla fark yoktur. Ama böyle yazmayın.

	- Her zaman MIL sentaksı ile non-static veri elemanlarına aksi bir durum olmadıkça ilk değer verin.

	- Data::Data(int x, int y) : mx(x) ile burada constructor'ın ana bloğuna girilmeden ilk değer verme gerçekleşir.
	{

	}

	- MIL sentaksının kullanıldığı yerde önce sentaksın kodları çalışacak daha sonrasında member'lar hayata gelmesinden sonra constructor'ın ana bloğuna girecektir.
	- MIL sentaksının asıl kulanımı sınıfın veri elemanı başka bir sınıf türünden ise çok sık kullanılacaktır.
	- C++'da önce öğeler hayata gelmesi gerekir. daha sonra constructor'ların ana bloğuna girecektir.
	- Bazı varlıklara ilk değer vermemek sentaks hatasıdır.
		1- reference'lar
		2- const'lar.

	- aynı durum sınıfın non-static data member'ı const olması durumunda da geçerlidir.


		1-) eğer sınıfın non-static veri elemanı reference yada kendisi const data member ise ilk değer verme zorunludur.
		2-) kalıtım(daha sonra girilecektir.)
		3-) composition(daha sonra girilecektir.)

	- constuctor'ı yaptıracağı tek iş ilk değer verme olsa bile fonksiyonun ana bloğu olmak zorundadır.(Boş olsa bile)
	 Date(int d, int m, int y) : mday(d), mmon(m), myear(y){}

Not : Bir başlık dosyasımümkün olduğu kadar az başlık dosyası include etmelidi.
	- C++ 11 ile birlikte uniform MIL'i uniform initializer ile de kullanabiliriz.Hatta genel olarak kullanmalıyız.

	- vexing parse problem : Dilin kuralları gereği derleyici yazanların tam olarak parse ederken hata yapmasıdır.
	  Örneğin bazen fonksiyon bildirimi ile fonksiyon çağırımı olup olmadığını anlayamaz


    - Bütün değerlere ilk değer verme gibi bir zorunluluğumuz yokken const veya reference olanların hepsine vermek zorundayız.

	- MIL sentaksındaki sıranın sınıfın tanımındaki öğelerin bildirimleri sırasıyla birebir aynı olma zorunluluğu yoktur.
	- Burada sınıfın içinde nasıl declara edildiyse o şekilde hayata gelecektir. MIL sentaksındaki kodda bu sıraya göre çalışacaktır.(4968)
	  örneğin
	  class Myclass{
	  int x,y;
		Myclass() : y{6}, x{ y }{}//Bu bir runtime hatası olacaktır. ilk başta  x hayata gelip, y çöp döğeri ile kullanılmıştır.

	  }




Not : C'deki size_t neyse C++'da bu çok daha fazla vardır.
	- runtime hatası. (4994)
	- runtime hatası olmadan kod yeniden yazıldı(5044).

	- struct Data {
		int mx = 12;
		int my;
	}

	- Yukarıdaki örnek C++'da default olarak ilk değer vermektir. Kullanıcı ilk değer verme işlemini unutursa bu değerlerle initalize edilecektir.
	- C++11'den sonra böyle bir ilk değer verme kuralı vardır. Var sayılan argüman olarak almıştır.
	- C'de struct'ın bildiriminde ilk değer verme diye bir kural yoktur.
	- Bununla derleyiciye ona default constructor'ı yazdırıp mx'e MIL ile değer verildiğini var say deriz.
		class Data {
		int mx = 12;
		//Derleyici default constructor'ı Data():mx{ 12 }{} şeklinde yazacaktır.

		}



	- Derleyicinin yazdığı default constructor'a bundan başka bir varsayılan argüman ile değer verdiremeyiz.
	- inclass initializer'da fonksiyon parantezi kullanamazken küme parantezi kullanılabilir.
	- int mx{20}; kullanımı da vardır.
	- //inclass initializer C++11 (5095)

	-class Data {
		int mx{10};
		int my;
	public:
		Data(int a) : my{ a }{} // Derleyici bu ifadeyi Data(int a) : mx{ 10 }, my{ a } {} şekline çevirecektirç

	---- COPY CONSTRUCTOR ----

	- eğer bir nesne hayata değerini kendisi ile aynı türden bir nesneden alarak hayata geliyorsa hayata gelen nesne için copy constructor kullanılır.
	- bu durumun bir kaç farklı senaryosu vardır.
		1-) T x = y; T x(y); T x{y}; // Burada hayata gelen x için 3 durumda da  copy constructor çağırılacaktır.
		2-) void func(int x); // call by value fonksiyon çağrısında da kullanılır.
		3-) Fighter func(){
			return f;
		}//Bir fonksiyonun geri dönüş değeri T türünden ise de copy constructor çağırılır.

	- copy constructor 3. special function'dır. Yani ya olacak ya da olacaktır. Derleyici copy constructor kodunu kendi yazacaktır.
	- Eğer programcı bir sınıf için copy constructor yazmaz ise derleyici ilgili sınıf için
		1-) non-static
		2-) public
		3-) inline bir copy constructor yazar.

	- copy constructor'ın parametresi const &(reference) olmalıdır.
	- Derleyicinin yazdığı ismi Fighter olan sınıf için derleyicinin yazacağı copy constructor'ın parametrik yapısı şu şekildedir.
		- class Fighter{
			int mx, my, mz;
			public:
				Fighter(const Fighter &r) : mx{r.mx}, my{r.my}, mz{r.mz}
				{}
		}//bütün non-static veri elemanlarının parametresi çekilen nesne'nin non-static veri elemanları ile karşlıklı eşleşmesi gerekecektir.

	- Eğer derleyicinin yazacağı copy constructor işimize gelmiyorsa copy constructor'ı kendimiz yazmamız gerekecektir.
	- Bir çok sınıf için copy constructor'ın derleyici tarafından yazılması işimize gelecektir.
	- derleyici n  tane constructor içinde copy constructor olduğunu isiminden ve parametresinden anlar.
	  Myclass sınıfının Myclass isimli constructor'ının parametrik yapısı Myclass(const Myclass &r); şeklinde ise direk copy constructor diyebiliriz.
	- Sınıfın copy constructor'ı yazılmış ise mutlaka default constructor'ı yazılmalıdır. Çünkü derleyici bizim için default constructor'ı yazmayacaktır.
		1-)T x = y için copy constructor gösterildi(5151)
		2-)void func(T x) için copy constructor çağırıldı(5189)
		3-) T func(); için copy constructor yazıldı.()

	------------------------------------------------------------------------------------------------------------------------------------------------
	---------------------------25.11.2017 CUMARTESİ----------------------------

	- vexing parse : programcı bir fonksiyon çağırdığınızı zannederken dildeki anlamı bir fonksiyon bildirimidir. Böyle problemlere denir.
	- copy constructor bir nesne hayata gelirken değerini kendisi gibi aynı türden bir  nesneden alırken çağırılır.
		 1-) açık ilk değer verme sentaksı ile--> Name myname{ myname1 };
		 2-) call by value fonksiyon çağrılarında. Fonksiyonun parametresi bir sınıf türünden. Argüman olan sınıf nesnesi parametre değişkenine ilk değerini verecek. Parametre değişkeni için copy constructor çağrılır.
		 3-) geri dönüş değeri T(T* yada T & değil) türünden olan fonksiyonlar için. fonksiyonun geri dönüş değerini tutacak nesneye yapılan çağrı için tutulur.
	- Eğer copy constructor yazmaz isek derleyicinin bizim için yazdığı copy constructor atanan nesnenin her bir öğesi, hayata gelen nesnenin her bir öğesi ile karşılıklı elemanı ile hayata getirir.(MIL sentaksı ile)

	- Öyle durumlar olacak ki copy constructor yazma zorunluluğu olacaktır.

	- Copy constructor çağrıldığını geri dönüş değeri için gösterdik(5377)

	- copy constructor açık ilk değer verme için gösterildi(5384)

	- call by value fonksiyon çağrısı ile copy constructor(5424)

	- value semantics(iki nesnenin değerleri aynıdır. Birinde yapılan değişiklikten diğerine yansımaz.)
	- uygulanan value semantic ise copy constructor'ı derleyiciye yazdırabiliriz.
	- derleyicinin yazdığı kopyalamaya shellow copy(sığ kopyalama) yada member whise copy(Member'ları karşılıklı olarak kopyalama)
	- öğelerin handle olması durumunda pointer'ları birbirine kopyalamak değil öğeleri birbirine kopyalamak gerekir.(deep copy)
	- Eğer RAII nesneleri söz konusu ise biz kaynakları paylaşmalarını istemiyorsak copy constructor'ını kendimiz yazmalıyız. Kendimiz yazmaz isek rte olur.
	- copy constructor'ın çağrılması duruma göre çok yüksek maaliyetli bir işlemde olabilir.
	- RAII nesneleri söz konusu olduğunda copy constructor'ın çağrılması çok büyük bir maaliyet alacaktır.
	- RAII nesnerlerinin kaynakları ortak olduğundan dolayı eğer bizim yapacağımız bir işlemden dolayı nesnelerden birinin hayatı diğerine göre daha erken biterse
	  bu durumda diğer nesne'nin de kaynakları boşa çıkacaktır. Ve o nesne'nin kullanımı bizim için bir run time hatasına neden olacaktır.(5466, 5515)

	- Biz RAII nesneleri için bir copy constructor yazmak istiyorsak burada kopyalama yapılan nesne için yeni bir kaynak elde etmeliyiz. Biz bu kaynağı elde etmez isek
	  iki nesne aynı kaynakları kullanacak ve eğer nesnelerden biri hayata daha önce veda edip kaynaklar geri iade edilirse hayatta olan nesne ile geri verilen kaynağı
	  kullanmamaız run time hatası olacaktır.

	- bu sınıfı non-copy bir sınıf olarak sunabiliriz. bir kopyalama işlemi runtime değil compile time hatası yaptırabiliriz.
	- ileride öğreneceğimiz tekniklerden dolayı ostream sınıfı kopyalamaya kapatılmıştır.
	- standart kütüphane'nin yaptığı gibi bazı sınıfları kopyalamaya kapatabiliriz.(Ancak böyle yaparak kullanım alanını daraltırız.)
	- Copy constructor'ı private bölümüne alarak ta access kontrol ile erişimi engelleyeibiliriz(5757). Fakat bu yöntemin sınıfın kendi kodları içindeki kopyalamaya engel olamayız.(5787)

Not : sınıfın üye fonksiyonları sınıfın private bölümüne erişebilir.

	- ostrem, istream, unique_ptr sınıfları kopyalamaya kapatılmıştır
	- Bir sınıfın copy constructor'ı yazılırken her zaman parametrik yapısı derleyicinin yazdığı const T & türünden yazılır.
--------------------------------------------------------
	--- işlevlerin default ve delete edilmesi
--------------------------------------------------------

	- C++ 11 ile gelen iki araç vardır. İşlevleri default, ve delete etmek.
	- İşlevlerin default edilmesi special member function'lara tanınan bir özelliktir.
	- delete edilmesini ise herhangi bir  function'a yapabilir.

	- Myclass() = default; // since C++11 ile default edebiliriz.(ileri de daha fazla değineceğiz.)
	- Derleyiciye burada özel olarak default constructor'ı nasıl yazman gerekiyorsa öyle yaz demektir.

	- ileri de karşılacağımız durumlar da derleyici  default constructor'ı yazmayacağı anlamına gelir.Bu sentaks ile
	  de derleyiciye normal koşullarda yzmıyorsun ama şu an benim için yaz isteğinde bulunuyoruz. Örneğin biz copy constructor'ı
	  yazdığımız zaman derleyici default constructor'ı yazmayacaktır. derleyiciye bunu default ettirebiliriz.

	- Bir fonksiyonun delete edilmesi
		- herhangi bir fonksiyona tanınan bir haktır.
		- sentaksı void func() = delete;
		- Burada anlam şu bu fonksiyon var ama bunlara yapılan çağrılar sentaks hatası olsun.(5851)
		- Bu fonksiyon function overload resolution'a katılmaktadır.ve derleyici function overload resolution'ın sonucunu da alır. ama fonksiyon delete edilmiş ise hata verir.
		- Yani bir fonksiyonu belirli bir argüman ile çağrılmasını sağlamış oluruz.

	- Bir fonksiyonu sadece bir tür ile çağırılışına izin verip,  diğer türler ile çağrılmasını engellemek için şablonlar kullanılır.
		template<typename T>
		void func(T x) = delete;

		void func(int x); //Burada fonksiyonu sadece int türden bir nesne ile çağırabileceğiz.
	- fonksiyon şablonu : derleyicinin fonksiyon kodunu yazmasını sağlayan bir meta koddur.

	- standartlar bir fonksiyon şablonuyla beraber bir gerçek fonksiyon aynı scope da bulunursa  gerçek fonksiyon o belirli türden bir argüman ile çağırılablir.(5905)

	- sınıf nesneleri kopyalanmasın istiyorsak copy constructor'ı delete etmeliyiz.(5935)

	- bir sınıfa copy constructor yazmamız gerektiği nasıl anlaşılır
		1-) bir sınıf için destructor yazmamızı gerekteren nedenler varsa, copy constructor'ı da yazmalıyız.
		    eğer destructor yazıyorsak belirli kaynakları geri vereceğimizdendir(RAII sınıfı). copy constructor yazmaz isek de kaynaklar da paylaşılacaktır.

	Not : bir sınıf için destructor yazarsak orada yüzde 90 ya bir copy constructor yazacağız yada non-copy constructable bir sınıf olmalıdır
	      Yani kopyalama yoluyla oluşturulamayan bir sınıf nesnesi oluşturmalıyız.

	- C++'da aynı türden sınıf nesneleri birbirine atandığında yine bir fonksiyon çağrılıyordur.
	- Sınıfın her zaman özel bir fonksiyonu tarafından yapılır. ismi atama operator fonksiyonudur. ama sentaks da ki ismi operator keywordu ve onu izleyen = operatörü.

	- Derleyicinin yazdığı atama operatör fonksiyonunun sentaksı Myclass &operator = (const Myclass &r); Her zaman bu şekildedir.

	- Constructor ile karıştırmamalı. Zaten iki nesne de hayattadır.
	- sınıfın non-static member function'ıdır. Bir nesne * this olarak kullanılacaktır. atama operatörünün sol tarafındaki nesnedir diğer nesne de bu fonksiyona argüman olarak gönderilecektir.(5969, 6042).
	- Bir sınıfın atama operator fonksiyonu olmak zorundadır. Eğer biz yazarsak bir sınıf nesnesine aynı türden başka bir nesne atandığında bizim yazdığımız fonksiyon çalışacak.Bu da gene RAII nesneleri için
	- derleyici iki sınıf nesnesinin karşılıklı birbirine operator sentaksı ile atandığını gördüğünde bunu atamaoperator fonksiyonuna yapılan çağrıya dönüştürür.
	- derleyicinin sınıf için yazdığı atama operator fonksiyonu sınıfın
		1-) non-static
		2-) public
		3-) inline bir function'dır.
	- Atama fonksiyonlarının bir geri dönüş değeri vardır. Constructor gibi değildir. Ve bu geri dönüş değerini bir çok durumda kullanacağız.
	- derleyicinin yazdığı atama fonksiyonun geri dönüş değeri sınıf türünden & döndürecektir.
	- hatta fonksiyon *this döndürecektir. Yani  a = b  gibi bir ifadenin değeri a'nın kendisidir.

	- derleyicinin yazdığı atama operator fonksiyonu *this'in her bir öğesine argüman olan nesnenin ilgili elemanının atanmasıdır.(6042)

	- Class türünden olan iki nesne a, b için a = b; ataması ile a.operator=(b);  aynı işlemi yapmaktadır.

	- eğer ortak kaynak kullanımı söz konusu olacak ise atama operator fonksiyonunu yüksek ihtimal ile kendimiz yazmamız gerekecektir.
	- derleyici atama operator fonksiyonun geri dönüş değerinin üzerinde bir kısıtlama koymamaktadır.
	- çok özel durumlar dışında atama operator fonksiyonu *this döndürsün.

	- kendi kaynağını kullanmayacağından dolayı o kaynağı geri  vermesi lazım. bu yüzden delete ile bu kaynaklar geri verilmelidir.(6132)

	- bir sınıfın destuctor'ını yazmak için ortada bir neden varsa çok büyük olasılıkla copy constructor'ın ve atama operator fonksiyonun(assignment operator function) yazılma gerekliliği de vardır.(Big three deniliyordu.)
	  çok istisnai durumlar haricinde biri yazıldığında diğerleri de yazılmalıdır. Bunlar çok istisnai durumları sayılmaz ise hep bir arada olan fonksiyonlardır
	- Big three(destructor, copy constructor, assignment opeartor function)
	- big three önceden kullanılan bir terim olup. artık big five denilen ayrıca iki tane daha fonksiyonu yazmamızı gerektirecek durumlar olacaktır. üçü kesin olarak yazılacak ve iki tane daha yazılacaktır.
	  C++11 ile gelen iki fonksiyondur.(destructor, copy constructor, assignment operator function, move constructor, move assignment function)
	- C++'11 in en büyük semantik farklılığı bu fonksiyonlardır.

	- aynı nesneyi birbirine atamaya self assignment denir. self assignmet'ı biz doğrudan yapmasakta bir fonksiyona argüman olarak gönderildiğinde fonksiyon bunu kendisi arka planda  yapabilmektedir.

	- C++'ta bir çok fonksiyon birden fazla parametreye sahiptir ve birden fazla nesne'nin kendisini almaktadır. Bu fonksiyonlar bazı işlemleri yapabilmek için parametreleri birbirine atıyor. bizde bu fonksiyonların
	 farklı parametlerine aynı nesneyi geçmemiz gerekir. Burada self assigment doğar. gene raii nesnelerinde atama operator fonksiyonunun işini dzügün yapabilmesi için içeride adresleri kopyalamalıyız.

	- self assingment bir lojik hata olmak zorunda değildir.

	- Yazdığımız sınıflar'ı bir self assignment'a tabi tutulduğunda bir run time hatasına girmemelidir. Yani ortada bir kaynak kullanımı olup biz self assignment'a karşı bir tedbir almaz isek sonu rte olur.

	- bunu engellemek için self assingment olup olmadığını kontrol ederek işlemimizi yaparız.(6211->6239)

	- atama opretator fonksiyonun kodu genel olarak şöyle yapılabilir. release source ve ardından deep copy(öğelerin handle olması durumunda poniter'ların değil öğelerin birbirine kopyalanmasıdır).


	- copy and swap idiomu da atama operator fonksiyonunun yazılması için kullanılabilir(ileride göreceğiz).

	- atama operator fonksiyonu special member function'dır. atama operator fonksiyonu dışındaki(<, >, <=, >=) gibi operator fonksiyonlar special member function değildir.
	- sınıfın atama operator fonksiyonları derleyici tarafından yazılan tek fonksiyondur.
Not : operator fonksiyonları member function olmak zorunda değildir.

	---------- move semantics(taşıma semantiği)---------
		- bir dilin verimini etkilyen çok büyük bir araçtır.
		- bir nesnenin hayatının bitmesi ile boşalacak bellek alanının geri verilmesi yerine onun başka bir nesne tarafında kullanılmasıdır.
		- C++11 öncesi gereksiz kopyalama işlemleri derleyicinin belirli bir kısıtta kodu optimize etmesi ile yapılmaktadır.
		- derleyici dilin kurallarına göre  hayatı bitmekte olan bir  nesnenin başka bir nesneye kopyalandığı yada atandığını görse sınıfın özel bazı fonksiyonlarına çağrı yapmaktadır.
		  bu fonksiyonlar kaynağı geri verip yeni kaynak edinmek yerine sadece handle'ları kopyalıyorlar.
		  bu fonksiyonlara move constructor denilir(Taşıyan kurucu işlev denir).
		- eğer atama yolu ile kopyalama yapılır ise ona da (move assignment operator function denir).

		- C++11'den sonra bütün standart kütüphane taşıma semantiğini destekleyecek şekilde değiştirilmiştir.

		- dile yeni eklenen R value reference'lar vardır(&&r).  Eklenmesinin asıl sebebi taşıma semantiğini implemente edilmesidir.
		- R value reference dilin temel sentaksına yapılan çok önemli bir eklemedir.eklemenin yapılmasının nedeni 2 tanedir.
			1-) dilin sentaksı kopyalama yapılacaksa kopyalama kodunu taşıma yapılacaksa taşıma kodunu seçmesine izin veriyordu. R value reference ile
			    dil taşıma semantiğine kavuşmuştur
			2-) iki tane C++11 öncesi desteklenmeyen yapının desteklenmesini mümkün kılmak için R value reference dile eklenmiştir.

		- T x; T &r = x; burada ki reference lvalue reference'dır.
		- sağ taraf referansı ise T &&r =x; şeklinde implemente edilir.

		- ister sol ister sağ referansı olsun ikisi de nesne'nin yerine geçer.

		- sol taraf referansı lvalue expression olan bir nesne'nin yerine geçerken sağ taraf referansı rvalue olan bir nesnenin yerine geçer.

		- C++' da rvalue, lvalue tanımı C'ye göre tamamen farklıdır. bazı başka kategoriler vardır.(örneğin xvalue(ölmekte olan bir rvalue nesne için kullanırlır))


		- sağ taraf referansına sol taraf ile ilk değer vermek sentaks hatasıdır.


		-  bir fonksiyon t türüne geri dönüyorsa, r value expression'dır. Ama reference döndürüyor ise l value expression'dır.
		   Myclass func();// R value expression döndürür
		   Myclass &foo();// L value expression döndürür



		- Bir fonksiyonun parametresi const T & ise bu fonksiyon R value expression ile çağırılabilir.
		  copy constructor bir R value expression parametresini kabul etmektedir.
		  Myclass(const Myclass &r);//copy constructor
		  Myclass(Myclass &&r);

		- t &&(r value) ile const t &(const l value ref)'e  paremetresine sahip iki farklı fonksiyonun r value reference ile çağrılması ambiguity hatası değildir.
		- r value ref'in const l value ref'e seçiçiliği vardır.(6583)
		- sağ taraf referansı ile belirtilen bir nesnenin hayatı bir süre sonra biteceğine işarettir.
		- bu yüzden de copy constructor ve move constructor'ın bir arada olması sentaks hatası olmayacaktır.(6616);

		- Yani ölmekte olan bir nesneden aktarım yaptığımızda move constructor kodunu hayatı devam eden bir nesneden aktarım yapıldığında copy constructor çağırılır.
		- aynı şey atama operator fonksiyonu içinde geçerlidir. eğer atama operator fonksiyonun sağ operandı R value expression ise move assignment operator function
		  L value expression ise copy assignment operator function çağırılır. Eğer R value expression ile çağırılıp move assignment function yazılmamış ise
		  copy assignment funct3-ion çağırılacaktır.
		- eğer kopyalamaya maaliyeti taşıma yoluyla azaltılabilecek bir sınıf ise taşıma constructor'ı yazılmalıdır.

		- R value ref'in function overload'de l value ref'e üstünlüğü olduğu için bunu sınıfın içinde de kullanabiliriz. Burada r value ref ile yazılan constructor'a move constructor denir.


		- Myclass(const Myclass &r);//copy constructor;
		- Myclass(Myclass &&r);//move constructor;
		- Myclass& operator=(const Myclass &r)//copy assignment
		- Myclass & operator=(Myclass &&r)// move assignment

		- move constructor'ı yazmamız gene öncesinde destructor yazılmış olmalı.(Yani kaynak kullanımı gereklidir.)

		- Bir kaynak kullanımında destructor'da kaynakları çalınan nesne'nin.(6758->destructor kodu)

		-

	------------------------------------------------------------------------------------------------------------------------------------------------

	---------------------------26.11.2017 PAZAR--------------------------------

	- Bir fonksiyona argüman gönderirken referans semantiği işimizi görüyor ise her zaman referans smeantiğine göre implemante etmeliyiz.
	- Eğer fonksiyon herhangi bir neden ile bir nesneyi kopyalayak değerini alacak ise o zaman(l value reference bir nedenden dolayı olmuyorsa ikinci bir şans vardır.)
		1- fonksiyonun parametresi sınıf türünden olsun demek(void func(Myclass x))
		2- sağ taraf refereansı yapmak;(void func(const Myclass &r); yada void func(Myclass &&r))

	- r value reference bir r value expression'ı gösterir.
	- l value reference bir l value expression'ı gösterir.
	- l value nesne'ler r value reference'a bağlanamaz.
	- r value ile hem r value reference hem de l value reference parametresine sahip fonksiyonlar çağırılabilir.

	- Not : ilk değer verme ile karıştırılmaması lazım. r value reference'den l value reference'a, l value reference'den l value reference ilk değer verilmez

	- ilk değer veren nesne

	class Myclass{
		Myclass(const Myclass &r); //copy ctor
		Myclass(Myclass &&r); //move ctor
		Myclass &operator=(const Myclass &r); //copy assingment;
		Myclass &operator =(Myclass &&r);//move assignment;
	};
	Myclass func();

	int main(){
		Myclass m1 = func();//Burada move ctor vardır.
		Myclass m2 = m1; //Burada copy constructor kullanılır ise

	}

	- bir fonksiyonun geri dönüş değeri sınıf türünden ise o fonksiyon bize R value expression gönderir. reference  ise l value expression gönderir.

	- taşıma senaryolarının %99'ında kaynağı çalınan nesne'nin birazdan hayata veda edecektir.

	int main(){
		Myclass m1;

		Myclass m2 = m1; //m2'yi m1'in kaynağını çalarak hayata getirmek için(move constructor çağırılır.Yani taşıma yapmaya zorlamak istiyoruz.)
	}

	- öyle yerler var ki bir nesneyi hayata getirmek için l value bir nesne'nin kaynaklarını çalarak hayata getirmek gerekiyor.
		Myclass m1;
		Myclass m2{m1}; // burada copy ctor değil move ctor'ın çağrılmasını istiyoruz.
	- Buradaki asıl amaç dilin kuralları biz taşıma yapmak istesekte l value bir nesne için her zaman cpoy ctor'ı çağıracaktır.
	  Bu durumda derleyiciyi taşıma yapmaya zorlayacağız.
	- move fonksiyonu, kendise argüman olarak gönderilen l value bir nesneyi r value'ye döndürür.

	- Myclass m2 = move(m1);
	- copy constructor değil move constructor çağrıldı(6792).

	- Normalde dilin sentaksına göre copy constructor çağrılacağına yerine kopyalama için kullanılacak nesnenin kaynak kodlarına çalarak move constructorı çağırabiliriz.
	- move fonksiyonu run time daçalışan bir fonksiyon değildir. Tamamen compile time a bağlı bir fonksiyondur.
	- move fonksiyonu l value expression'dan r value expression'ına cast yapar.
	- move fonksiyonuna l value expression gönderdiğimiz zaman fonksiyon aynı nesneyi r value reference  olara	k geri döndürür.

	- move fonksiyonu runtime da çağırılan değil compile time da çağrılan bir fonksiyondur.
	- C++'da eş isimler(alias) using ile kullanılır.(C'deki typedef gibi) using Word = int; // C++'ta böyle typedef yapmalıyız.
	- using Fcmp = int(*)(const char *, const char *);//strcmp'nin adresinin türünü fcmp'ye veriyoruz.
	- İleri de öyle eş isim yapıları  gelecek ki using ile yapabiliriz. Fakat typedef ile yapamayız.

Not : C++'ın öteden beri olan sentaksından dolayı enum türünden bir nesneye başka hiç bir türden otomatik tür dönüşümü yoktur. Yani sadece ve sadece enum türünden bir nesne yada onun enumarator'lerinden birini atayabiliriz.
	- C++'dan enum'dan diğer türlere dönüşüm vardır. ancak enum class'lardan da diğer türlere dönüşüm yoktur.


Not : incomplete declaration(class Myclass; Yani implimentasyonu yoktur.) kullanılan yerler de incomplete declaration kullanarak bir başlık dosyasını include etmekten kurtulabiliriz.
	- Derleyicinin o türün, bir tür olduğunu biliyor ama o tür hakkında bütün bilgileri elde etmemiştir.

	- incomlete type ile pointer tanımlayabilirsiniz.
	- C'de de C++'da da enumarator'lerin scope'u enum türünün scope'dır. Global enumarator isimleri global scope'u kirletmelerinden dolayı sıkıntı olur.

	- bu çakışmayı önlemek için C++'da ilk yol olarak isimleri özelleştirebiliriz. ikinci yol olarak bunları bir class içine alarak class scope'una dahil edebiliriz.

	- enum class  C'de olmayan C++ için de 11 standartları gelen bir türdür.
	-1.si eski tip enum(unscope enum) 2. si 'de enum class(scope) isminde iki farklı scope vardır.

	- enum class ScreenColor {White, Yellow, Gray};
	  enum class TrafficColor {Red, Yellow, Green}; // burada herhangi bir isim çakışması olmayacaktır.

	  Screen color = ScreenColor::Yellow;
	  TrafficColor tcolor = TrafficColor::Yellow; // böylece scope problemi tamamen çözülmüştür.

	Not : enum Status {Off, On, Hold, Standby};
		Status s = Status::Hold; //Normalde Status'un herhangi bir scope'u olmamasına rağmen bu kullanımı da legal kılmışlardır. Ama koddan asla bunun bir enum class olduğunu düşünmemeliyiz.
		Yani burada Status::Hold ile Hold demek arasında hiç bir farklılık yoktur.

	- enum class ile birlikte diğer aritmetik türlerden enum türüne dönüşümün legal olmadığı gibi, enum class türünden diğer türlere otomatik tür dönüşümü yoktur.
	- Burada tür dönüştürme operatörelini kullanarak ancak tür dönüşümü yoktur.

	- bir yeni gelen özellikte enum türlerinin underlined type'ını kendimiz belirleyebiliriz.Bu hem enum class olsun yada C'den gelen(convensional enum'lar) olsun underlined type alabilirler.

	 enum Color: unsigned int{Black, Blue, Purple};
	  // Bunun storage'la ilgisi olabilir. Yani bellek tasarrufu söz konusu olabilir.

    - Underlined'ın type'ın ne olduğunun programcının belirtmesi storage ile ilgili nedenlere dayanabilir. Asıl önemli faydası forward declaration'ı mümkün kılmasıdır.

	-

	- C'de R value expression ancak C++'da L value expression olan ifadeler.
	  1-) ++x;
	  2-) (x, y);
	  3-) (flag ? x : y)

	  if (x > 10)
		a = y;
	  else
		b = y;
		- if deyimi  ile aşağıdaki iki deyim aynı anlama sahiptir..
		(x > 10 ? a : b) = y;// C++'da L value expression'dır.
		*(x > 10 ? &a : &b) = y; // C'de yukarida ki kodun yazılma şekli bu olacaktır.

		//cpp reference'ta value categories'i oku
		// thomas becker r value reference
		- cpp'taki expression'lar
		- l value
		- r value
		- x value(expiring value)//Hayata sona erecek olan nesneler
		- prvalue (pure r value)//

		- C'deki sağ taraf değeri dediğimiz fadeler pr value'nin karşılığıdır.
	--- conversion constructor---

	- Sınıfların tek parametreli constructor'larına conversion constructor denir.
	- Sınıfın tek parametli constructor'ları parametresinin türünden bir değeri   bu sınıf türüne dönüştürebilir.

	- m = 12; // derleyici burada  atama yaparken geçici bir nesne oluşturacaktır.  ifade bittikten sonra geçici nesne hayatına veda etmektedir.
	- Derleyici burada atama operatörünün sol operandını tarafını sınıf türünden sağ operandını int türden olduğunu belirleyip ve derleyici bu türden
	  bir sınıf oluşturup bununla atama yapar.Yani derleyici m = 12; için ilk başta Myclass tmep{12}; && m.operator=(temp) şeklinde bir koda dönüştürür.

	 - Derleyicinin bu duurumlar için oluşturduğu nesnenelere geçici nesne denir.
	 - Geçici nesnelerin ömrü onların gerektiği yerdeki ifade gerçekleştikten sonra ömrü sona erecektir.
	 - Geçici nesneler r value expression'dır.
	 - ortada taşıma semantiği varsa taşıma semantiği devreye girecektir. Yoksa kopyalama semantiği devreye girecektir.

	 - Bazı yerlerde conversion constructor'ın olması istenen bir şeydir.(özellikle String sınıfında)
	 - string sınııfının const char * parametreli bir conversion  constructor'ı vardır.

	 - class Counter {

	 };
	- Dilin kuralları conversion constructor'ın devreye girmesi gereken yeri programcıya bırakmamaktadır.
	- DErleyici bir user defined convertion'ı dilin normal conversion'ı  izlediğinde bunları yapmak zorundadır. Yada normal conversion'ı user defined conversion izlediği zaman bunu yapmak
	  zorundadır.
		örneğin:
			void func(Myclass m);
			func(char c);// Myclass sınıfının int parametreli conversition constructor'ı çağırılacaktır. Öncelikle char türünden int türüne, int türünden de Myclass türüne dönüşüm
			gerçekleşir.
	- Derleyici atama durumunda hiç bir zaman ard arda iki defa user defined conversion yapmaz. Yani iki defa conversion constructor'ı çağırmayacaktır.
	- Conversion consturctor'ın kullanılması tipik bir user defined conversion örneğidir.
	-

	- Yani ard arda iki kez arka arkayae user defined conversion yapamaz.
	- A-----> B--->C // C = A; ile bu dönüşümü yapmak mümkün değildir.Buradaki durum bir atama durumudur bunu asla ilk değer verme ile karıştırma
	- Standart kütüphanenin kullamında örneğin bu konu bilinmez ise hiç beklenmedik senaryolarla karşılaşılanabilir.


	- Derleyicinin otomatik olarak conversion constructor'a çağrı yapmasını istemiyorsak bunu engellemenin bir yolu vardır. Bunun için explicit keyword'u kullanılır.
	  Bunu yapmamızın nedeni tamamen hiç beklenmedik bir şekilde hata ile karşılaşabiliriz. Bu konuda ki araca explicit constructor denir.
	- explicit constructor explicit keyword'u ile belirtilen constructor'dır.

	- C++'da bazı anahtar sözcükler var ki bildirim de de, tanımda da kullanılmak zorundadır. explicit anahtar sözcüğü tanımda kullanılamaz.
	- explicit ile belirtilen constructor'ın otomatik tür dönüşümlerinin bu constructor'ın kullanılamayacağını belirtir.
	- explicit keyword'unun kattığı anlam fonksiyonun tür dönüşümü yapacağı ancak tür dönüştürme operatörü ile tür dönüştürme yapacağını belirtir.
	  örneğin:
			Myclass'ın int parametreli bir conversion constructor'ı explicit key word'u ile belirtilsin.
			Myclass m = 12; gibi bir legal olmamakla beraber ancak ve ancak Myclass m = static_cast<Myclass>(12) şeklinde yapılabilir.
- explicit conversion = açık dönüşüm anlamına gelir. derleyici arka planda kendisi otomatik dönüşüm yapmaz.Sadece açık bir şekilde dönüşüme izin verir.

- derleyicinin durumdan vazife çıkarıp otomatik olarak yaptığı tür dönüşümlerine implicit conversion.
- tamamen programcı tarafından açık bir şekilde yapılan dönüşümleri explict coversion denir(tpe_cast operatörleri iledir).
	- bunu otomatik tür dönüştürme operatörü ile yapabiliriz.()
	- çok özel bir durum değilse conversion costructorları explicit yapmak iyi bir fikirdir.
	- conversion constructor bir special member function değildir. Bunu yazacak isek convertion constructor'ın kodunu kendimiz yazmalıyız.

	- Counter z = 45; derleyici 45 ifadesini geçici bir Counter nesnesini dönüştürür. Sonra da oluşturulan bu nesneyi move constructor ile z ' ye ata;(Counter temp(45); Counter z(temp); ifadesine dönüştürür.)
	- Counter z = 45; ile derleyici aslında Counter z(45); ifadesi olur. Eğer convertion constructor explicit ise bu durum sentaks hatasıdır.Bu durum üsttekine ek olarak
	  derleyicinin optimazyonu ile ilgilidir. Neredeyse bütün derleyiciler bu optimizasyonu yapar ve hiçbiri de burada copy ctor'ı çağırmayacaktır.

	- Counter z = 45; sentaksın geçerli olması için sınıfın ilgili constructor'ının explicit olmaması gerekiyor. Burada atama yok. Bir nesneyi initialize ederken. daha ileri araçlar kullanılmalıdır.

	- tek parametreli olmayan bir constructor'ın explicit keyword'u ile bildirilmesini sentaks hatası olarak görmez.

	- Tek parametreli olmayan constructor'ların explicit olması çok marjinal durumlar için geçerlidir.

Not : Smart pointer'lar kopyalamaya tamamen kapatılmış pointer'lardır. Hiç bir zaman dinamik nesne'nin iki sahibi yoktur. Ama taşıma semantiğine açıktır.
	- unique_ptr<T> C++'da en çok kullanılan smart pointer sınıfıdır. Varlık nedeni exlusive owner ship(tek sahiplik) ilkesini implemente etmek için kullanılır.
	- Bir kaynağın tek bir sahibi olur. Aynı zaman da iki sahibi olamaz. Kaynağın sahibi olan nesne öldüğünde, kaynak ta geri verilir.
	- unique_ptr sınıfının kullanılma nedeni dinamik nesnelerin kontrolü içindir. Dinamik nesneyi yönetmek te kullanacak unique_ptr nesnesinin hayatı bittiğinde
	  dinamik nesneninde hayatı bitecektir. uniqu

	- Derleyicinin primitive türler için oluşturduğu geçici nesneler her zaman cosnt kabul edilir.

	- Derleyicinin oluşturduğu geçici nesnelere ilişkin kullanım alanı, geçici nesnenin oluşumunu sağlayan ifadenin yürütümü bitene kadar
	  nesne hayata devam eder.
	  Bir fonskiyon çağrısına gönderilen geçici nesne için fonksiyon işlevini bitirtikten sonra geçici nesnenin hayatı biter.e
	--------------------------------------------------------------------------------------------------------------------------------------------------------
	------------------ 02.12.2017 CUMARTESİ---------------------
	Myclass m2(10);
	Myclass m2{12};
	Myclass m3 = 20; //eğer conversiton ctor explicit ise bu gerçekleşmeyecektir.

	void func(const Myclass &r);

	int main(){
		func(flag) //flag bir boolean türden bir değişken olmak üzere eğer func fonksiyonunun double türden bir standart conversion'ı varsa burada otomatik dönüşüm ve user defined türden bir dönüşüm olacaktır.
	}

	- conversion constructor'ın exlicit olmamasının verebileceği bir logic hata. (7301)
	- unique ptr'nin constructor'ı da explicit'tir.
	- unique ptr nesnesi olan nesnenin scope'u bittiğinde nesneyi yok edecektir.
	-  convertion ctor'un explicit olması Class türünden bir nesneye otomatik dönüşüm ile değer vermeye izin vermemeişlerdir.

Not : C++'da fonksiyon tanımında da parametre nesnemizin bir ismi olmak zorunda değildir. Function overloading sağlanması içindir.(7390)

	- bir class türünden nesne hayata geliyor ise mutlaka ctor çağrılmıştır.

	- conversion constructor class türünden bir nesneye, class türünden olmayan bir nesne ile atama yapıldığında yada ilk değer verildiğinde  çağırılabilir. Derleyici bizim için bir  geçici bir nesne oluşturacaktır.

	- Myclass(12) için derleyici sadece bu ifadenin yürütülmesi için bir geçici nesne oluşturdu(7429).

	-	string h1(const string &s)
		{
			return "<h1> + s + "</h1>";

		}

		int main()
		{
			h1("Necati"); // ile çağrılmasında ctor explicit ise bir hata verecektir.

			h1(string("poyraz")); //ile derleyici bir geçici bir nesne oluşturur. Ve derleyicinin oluşturduğu bu geçici nesneler r value'dir.
		}

	- derleyicinin oluşturduğu geçici nesneler r value reference'dır.

	- geçici nesne oluşturma sentaksı ile bir geçici nesne oluşturmak zorunlu bir sentaksdır. Bu nesneyi bir kere kullanacağımız zaman geçici nesne oluşturmalıyız.

	Not : Özel bir durum yoksa uniform initializer ile ilk değer vermeliyiz.

	- initializer list bir ifade içinde küme parantezi kullanarak bir fonksiyona bir değerleri argüman olarak geçmemizi sağlar.

	- eğer intializer list ile beraber int gibi bir parametreye sahip fonksiyon overload edilirse öncelik intializer list parametrenindir.
	 vector<int> vec1(12); // derleyici int parametreli değil initalizer list olan fonksiyon devreye girer.

Not : L value expression sağ taraf referansına bağlanamaz.sentaks hatasıdır.const Myclass & parametresine sahip bir fonksiyon parametresini sağ taraf referans ile çağırabiliriz.(7517)

	- bir fonksiyonun geri dönüş değeri referans ise l value expression, sınıf türünden ise r value expression'dır.
	- hayatta olan bir nesnenin kaynaklarını çalmak istiyorsak l value to r value fonksiyonu olan move fonksiyonu çağırmamız gerekecektir.

	- void func(string s) --> böyle bir fonksiyonu l value ile çağırırsak kopyalama kesin olacaktır. r value ile çağırırsak derleyici kopyalama yapmayıp optimizasyon yapacaktır.

	--- STATIC VERİ OGELERİ AND STATIC MEMBER FUNCTIONS ---

	- C++'da static anahtar sözcüğünün kullanımı çok daha fazla genişletilmiştir.
	- non-static data members bir sınıf nesnesinden bir sınıf nesnesine değişikşlik gösterebilen verileri tutar. Bu veriler sınıf nesnesinin içinde kullanılır.
	- sınıf'ların ortak kullandığı verilere de static data member denir.
	- Bunlar C'dekş global değişkenler gibidir. Farkı 3-4 tanedir.
		1-) scope// sınıfın static veri elemanları class scope içindedir.
		2-) access control//

	- namespace{
		int gx = 10;
	};//unnamed name space(c'deki static globaller gibidir. Ama her şeyi buraya koyabiliriz.fonksiyon, typedef)

	- gömülü sistem programlama da global değişkenler'in kullanımı çok daha sıktır.

	- sınıfın diğerr veri elemanlarından farklı olarak statik veri elemanlarında  mutlaka kaynak dosyaların birinde tanımı olmalıdır.

	- statik veri elemeanlarının hayata gelmesi main çağrılmadan öncedir.
	- statik veri elemanları sınıf nesnesinin sizeof'u ile aalakası yoktur.
	- client kodların statik veri elemanlarını class scope içinde aramalıdır.
	- özellikle aritmetik türden veri elemanları için mutlaka ilk değer vermeliyiz.
	- statik anahtar sözcüğü tekrar edilemeyen sözcüklerdendir. sadece bildirim de olmalıdır.
	- bir statik data member'ın bildirimini yaptığımız gibi tanımınıda yapmalıyızdır.
	//myclass.h
		class Myclass{
			int mx1, mx2;
		public:
			static int msx;
		}
	//myclass.cpp
	int Myclass::msx = 0;(7620);

	- Bir sınıfın non-static veri elemanı kendi türünden olamaz.nedeni incomplete type olduğundan dolayıdır. ama incomplete type'dan bir statik veri elemanı olabilir.(7627)

	- forward declaration : bir türün bildirimini derleyiciye haber verip tanımını vermemizden dolayıdır.

	- bir sınıf başka bir sınıf türünden veri elemanına sahip olacaksa bu sınıfın başlık dosyası diğer sınıfı include etmek zorundadır. Eğer veri elemanı statik veri elemanı
	olsaydı başka bir dosyayı include etmemize gerek kalmadan sadece bildirimini görmemiz yeterli olacaktır.

	- bir başlık dosyasının başka bir başlık dosyasını inlcude etmesi gerek yokken çok büyük bir sorumluluktur.

	- sınıfın veri elemanı pointer yada referans ise bunun için complete type olması zorunluluğu yoktur.
	- global değişkenler gibi sınıfların statik veri elemanları main çağrılmadan hayata gelmektedirler. Bunlar'ın varlığı için ortadaki bir sınıf objesi olmasına gerek yoktur.
	- farklı kaynak dosyalarının include edilmesi sonucu statik class member'ların hangisinin daha önce hayata geleceği için bir standart yoktur. ve bu runtime'a sebep olabilecek bir koddur.(7752);

	- sınıfın statik veri elemanlarının MIL sentaksı ile hiç bir  ilgisi yoktur. dolayısı ile ona yönelik bir kod yazmaya çalışırsak sentaks hatasıdır.(7778)
	- MIL sentaksı constructor ile ilgilidir. Ve constructor da sınıfın non-static veri elemanlarını değiştirmeye yönelik bir fonksiyondur. Ama sınıfın herhangi bir üye fonksiyonu
	  sınıfın statik veri elemanını kullanabilir.
	- const üye fonksiyonları static veri elemanlarını değiştirebilir. ve const üye fonksiyonu çağırılan fonksiyonun değerlerini dğeiştirmemeye yöneliktir. static veri elemanı ile hiç bir il ilgisi
	  yoktur.
	- sınıfın statik üyelerine nokta opeatörü yada ok operatörü ile de erişebilir.(public ise). Ama bu okuyana sanki nesne ile bir alakası olduğunu gösterir.

	- class scope'da kullanılmış bir member function'ın çağrılması için bir nesne olması eğer statik bir member function değilse zorunludur.(7855)
	- statik veri elemanlarına ilk değer veren ifade de ilk başta class scope'a bakacaktır.(7901)


	------ static member functions -------
		- bir sınıf nesnesinin adresi ile çağrılmayan, dolayısı ile bir instance ile ilgisi olmayan fonksiyonlardır.
		- global fonksiyonların yerine geçmeye çalışan en büyük aday static member functions
		- sınıfın private bölümüne erişim hakkına sahipler. Global fonksiyon sınıfın private bölümüne erişim yapamazlar.
		- sınıfın static member function'larını private public yada protected yapılabilir.
	Not : instance -> bir sınıf nesnesinin oluşumu, hayatta oluşu

		- inline olarak tanımlanabilir.
		- inline olarak tanımlanmayacak ise tanımın sınıf türüne nitelenmesi gerekir. void Myclass::func(int x);
		- static keywordu tanımda kullanılamaz.
		- static keyword'unun this pointer'ı yoktur.(7987)
		- sınıfın constructor'ı private iken bu sınıfın kendi statik üye fonksiyonları ctor'a erişebilirler.(8058)

		- static üye fonksiyonlarını const, non-const diye bir şey yoktur. const kullanımı geçerszidir.
		- buradaki üye fonksiyonun const olması *this'i değiştirip değiştirmeyeceği olmalıdır.
		- sınıfın static üye fonksiyonu doğrudan sınıfın non-static üye fonksiyonunu doğrudan çağıramaz.(8093)
	--------------------------------------------------------------------------------------------------------------------------------------------------------

	------------------ 03.12.2017 PAZAR----------------------
	- static üye fonksiyon'un this pointer'ı olamaz.
	- static üye fonksiyon const olamaz.
	- static üye fonksiyon içinde sınıfın non-static data member'ı ismiyle kullanamaz.
	- static üye fonksiyon içinde sınıfın non-static member function'ına erişemez.
	- non-static member function, static member function'una çağrıda bulunabilir.
	- Hayatta olan nesnelerin sayısını saymak çok sık kullanılan bir temadır.(static int instance_count;)
	- Constructor private yapılırsa ne otomatik ömürlü ne statik ne de dinamik ömürlü nesne oluşturamayız.(8272);
	- eğer constructor private ise bir nesne yaratmak için static T *'a geri dönen bir member function yapmalıyız.
		daha sonrasında copy constuctor ile otomatik ömürlü yada static ömürlü bir nesne oluşturabiliriz.
	- en çok kullanılan tasarım kalıplarından biri singletan(tek nesne).

	- sınıf nesnesi ile sınıfın non-static fonksiyonu çağırmak yerine sınıfın static member function'ını çağırırsak derleyici hiç bir hata vermeyecektir.

	- C++'da static yerel sınıf nesneleri ilk çağrıldığında hayata gelecektir.
	------ meyer singleton ----

		static Counter &getInstance(){
			static Counter c;
			return c;
		}
	--------------------------------
	- Sınıfın static veri elemanlarını sınıf içinde nitelereyek  kullanan coderlar vardır.
	--------------------------------------------------------------------------------------------------------------------------------------------------------

	------------------ 09.12.2017 CUMARTESİ----------------------

	- pimple idiom ile bir başlık dosyası ile client'ların ilişkisi kesilebilir.(şimdilik öğrenmemiz için çok erkendir.)
	- eski c++'da Taşıma semantiği olmadığı için kopyalama maaliyeti çok fazla kaçınılıyordu. Modern C++ ile taşıma semantiği geldiğinden dolayı bunları rahatça
	yapabiliriz.

	- en sık yapılan vector işlemlerinden biri, container'da belirli öğeye sahip bir öğeyi silmemiz gerekebilir.
	- Bir container'da belirli bir değere sahip ilk öğeyi silmek ve tamanını silmek arasında farklar vardır.

	- remove arrays = bir sequence container'da belirli öğelere sahip öğelerin tamamını silmek için remove arrays idiomu kullanılır.
	- her container sınıfının container'da belirli bir öğeye sahip öğesini silmek için kullanılan bir sınıf vardır.
	- range based for loop => for( : ) iki noktanın sağ tarafına dolaşmak istediğimiz veri elemanı yazılır.

	- int a[]= {12, 24, 24, 24, 25, 67, 85};
	  for (int i : a );//burada referans semantiği yoktur.(döngü değişkeninin refereans semantii olarak kullanmak istersek int &i kullanmaktır.)(8755)
      for (const int &i : a); // container'ı salt okuma amaçlı kullacanağımızı belirtiriz.
	- range based for loop auto keyword'u ile kullanılabilir.

	- for (auto x : c);//burada kopyalama semantiği vardır.
	- for (auto &x : c); // burada x container'daki öğenin yerine geçen referans isim  ve set amaçlı kullanacağımızı gösterir.
	- for (const auto &x : c); // salt okuma amaçlı kullanma referansı.

	- range based for loop her zaman container'ın tamamını dolaşmak içindir.

	- range based for loop örneği(8816)
	- range based for loop taşıma semantiğin de de kullanılabilir. for(auto &&r : c);
        - derleyici for(auto x : c) gibi bir ifadeyi gördüğü zaman bizim yerimize
          for(auto iter = c.begin(); iter != c.end(); iter++)
                   x = *iter; // gibi bir ifade haline getirir.
	-1'den 100'e kadar sayıları ekrana yazdıran bir C++ kodu yazınız(döngü yazmadan)(8875)

	- bir container'ı baştan sona dolaşırken begin ve end fonksiyonları kullanılırken sondan başa doğru dolaşırken rbegin ve rend fonksiyonları kullanılır.

	------ arkadaşlık bildirimleri ------

	- sınıfın private bölümleri sınıfın kendi kodları hariç sınıfın implementasyonunu client'lara kapatılır.

	- öyle kodlar var ki siz seçilmiş bazı kodlar için sizin private bölümününe erişim sağlanacaktır. Bu araç özel durumlarda kullanılacak bir araç olacaktır.

	- kodsal bir problemin en kolay çözümü seçilmiş bir koda sınıfın private bölümüne yetki vermektir.

	- C++'da arkadaşlık bildirimi 3 farklı kategoriye ayrılır.
		1- global bir fonksiyona arkadaşlık vermektir.(9033)
		2- bir başka sınıfın bir üye fonksiyonuna friendlik vermektir.//Bu yapı çok daha az kullanılan bir yapıdır.
		3- bir sınıfa komple arkadaşlık vermektir.

	- bir class içerisinde friend keyword ile bildirilmiş bir fonksiyon bildirimi o fonksiyonun direk global olduğunu gösterir. ve derleyicinin foo işlevinin bildirimini daha yuakrıda görmesi gerekmez.Çünkü sınıfın kendi fonksiyonlarına arkadaşlık veremez(9033)


	- friendlik bildirimin de ilginç bir nokta daha vardır. friendlik bildirimi ile bildirilen bir fonksiyonun tanımını sınıfın içinde inline olarakta yapabiliriz.

	- friendlik bildirimi sadece private bölüme erişim yapmak zorunda kullanılmak zorunda değildir.

	- bir friendlik bildirimini kendisinin sınıfın public yada private bölümünde yapılmasının bir farkı yoktur.


	- class Myclass{
		void foo();
	public:
			friend class A;
	}
        class A{
        public:
                void f1(){
                     Myclass m;
                     m.foo();
                }
        };

	- Burada A sınıfının complete bir type olma zorunluluğu yoktur.

	- A sınıfının B'ye arkadaşlık vermiş ise B'nin kodları içinde A'nın private bölümüne erişilebilirken B sınıfı A'ya arkadaşlık vermeden A sınıfı B'nin private bölümüne erişemez.
	- A sınıfı B'ye B sınıfı C'ye arkadaşlık verdiğinde C'den A'ya direk erişim yoktur.
        - Kalıtım yoluyla elde edilen bir nesne içinde taban sınıfın arkadaşlık verdiği sınıflar taban sınıfın private bölümüne erişebilirken bunu taban sınıftan türetilmiş sınıflara yapamaz

	----------------------------operator overloading(işleç yüklemesi)------------------------------

	- C'de yapı nesneleri sadece 4 tane operatörün operandı olabilir. &, ., sizeof, =

	- C++'da bir sınıf nesnesinin diğer operatörlerin operandı olması da mümkündür. Biz bir nesneyi opeartörün operandı yapmış gibi gözüksekte derleyici compile time da
	bunu fonksiyon çağrısına dönüştürüyordur.
	- operatörlerin primitive  türden veriler için sunduğu interface'i sınıflara da taşıyarak client kodlara yardımcı olmayı sağlamaktır.

	- date1 = date2++;
          derleyici bu kodu  şöyle bir  koda  çevirmiştir
          date1.oparator=(date2.operator++(int))

	- bu mekanizmanın herhangi bir runtime maaliyeti yoktur.

	- programızın çalışma hızı ile operator oveloading'in herhangi bir alakası yoktur.

	- C++'ın çok büyük standart kütüphanesi operatör overloading'e dayanır.

	- overload edilen bir opearatör'ün operandı olması durumda global bir fonksiyonun çağrısına dönüşüyorsa buna global operatör fonksiyonları denir.
	-  overload edilen bir opearatör'ün operandı olması durumda class member functionın bir fonksiyonun çağrısına dönüşüyorsa operatör member function denir.
        - Böyle fonksiyonları STL'i kullanmak için oluşturmalıyız.
        - kaç tane operator fonksiyonu olursa olsun bunların runtime'a yönelik herhangi bir ek maaliyeti yoktur.
        - basit bir örnek olarak string nesnesinin += operator'u bir operator overloading örneğidir.
        - operator overloading aracı kendi içinde iki kategoriye ayrılır.
          1- bir operandı sınıf nesnesi olan bir ifadeyi derleyici global bir fonksiyona yapılan çağrıya dönüştürür.
          2- sınıf nesnesinin bir operandı olan bir ifadeyi derleyici bir sınıfın üye fonksiyonuna yapılan çağrıya dönüştürür.
	---işlek yüklemesi olmak için---
		1-) bir operatör yüklemesi olması için en az bir operandın sınıf türünden olması gerekir.
			- örneğin i1 ve i2 int türden nesne olmak üzere i1 = i2 için bir fonksiyona yapılan çağrıya dönüştürme olanağı yoktur.

		2-) dilin kurallarına göre overload edilemeyen operatörler vardır.
			- koşul operatör(ternary operator)
			- nokta operatörü(nokta op.)
			- :: operatörü
			- .* operatörü (C'de olmayan C++'da vardır.)
			- sizeof
			- new
			- delete
			- typeid

		Not : operatör new ve operatör delete fonksiyonları function overload edilebilir.

		- bazı operatörler yalnızca üye operatör fonksiyonu olabilir.(sadece member function olmak zorundadır.)
			- işlev çağrı operatörü
			- ok operatörü
			- köşeli parantez operatörü

		3-) operatör overloading mekanizmasında operatörlerin arity'sini değiştiremeyiz. Operatörlerin arity'si  binary operatörleri binary olarak unary operatörleri unary olarak overload edilmesidir.
			- binary bir operatör member operatör fonksiyonu olarak çağrıldığında burada her zaman sol taraftaki operandı *this olarak alınır.binary operatörün sağ operandı da
			parametre değişkenine gönderilen argüman olacaktır.
			- binary bir operatör member function olarak yüklendiğinde 1 parametresi olmak zorunda global ise 2 tane parametresi olmak zorundadır.
			- unary bir operatör member function olarak yüklendiğinde fonksiyonun parametresi olmayacak, global ise bir tane parametresi olmak zorundadır.
               - +, -, &, * bunlar hem uniry olarak işaret + ve - için işaret operatörü,& için adres operatörü, * için içerik operarötürüdür.
               - uniry olarak kullanımında ise toplama, çıkarma, bitsel ve, çarpma şeklindedir.
---------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------10.12.2017 PAZAR---------------------------------------------------
		OPERATOR OVERLOADING genel kuralları
	1- Ortada bir operator ovelraoding olması için mutlaka bir sınıf nesnesi olmalıdır.
	2- operatör olmayan bir atomu bu mekanizma da kullanma şansımız yoktur.
	3- bazı operatörler overload edilemez.
		- koşul operatör(ternary operator)
		- nokta operatörü(nokta op.)
		- :: operatörü
		- .* operatörü (C'de olmayan C++'da vardır.)
		- sizeof
		- new
		- delete
		- typeid
	4- bazı operatörler için sadece member function yazılabilir.
		- işlev çağrı operatörü
		- ok operatörü
		- köşeli parantez operatörü

	5- Bu fonksiyonlara keyfi isim veremeyiz. isimleri operator keywordu ve keywordu hangi operatör takip ederse o operatör kullanılarak verilmelidir.
		RET.TYPE operator+()const;//işaret operatörü
		RET.TYPE operator+(const Myclass &r)const;// toplama opreatörü
		RET.TYPE operator()();// fonksiyon çağrı operatörü

	6- operator new ve operator delete dışında hiç bir operator fonksiyonu static olarak yazılamaz.

        - çok özel durumlar dışında operatörleri isimlerini çağırarak kullanmamıza gerek kalmaz.
	7- class Myclass{
		public:
			bool operator>(const Myclass &r);
			// yada friend bool operator>(const Myclass &r1, const Myclass &r2);
	};

	8 - fonksiyon çağrı operatörü-->()  hariç hiç bir operator fonksiyonu varsayılan argüman alamaz.

	9- operatör öncelik seviyesi ve yönünü değiştiremeyiz.
		bool f = m1 * m2 +m3 > m4;
		//eğer operator fonksiyonları global ilse
		bool f= operator>(operator+(operator*(m1, m2), m3), m4);
		//eğer operator fonjsiyonları member function ise
		bool f = m1.opeator*(m2).operator+(m3).operator>(m4);
		// > member function olup gerisi global olursa
		bool f = operator+(operator*(m1, m2), m3).operator<(m4);
        - C++'ın önceki standartlarından binary operatör fonksiyonlarının (logic operatörler hariç) geri dönüş değerleri sınıf türünden'dir.
        - friend Matrix operator+(const Matrix &t1,const Matrix &t2);
          // yada Matrix operator+(const Matrix &rhs)const;
        - C++11 öncesi taşıma semantiği olmadığı için türe geri dönme çoğunlukla kopyalama ile yapılır ve çok fazla maaliyete neden olurdu.
	- endl bir member function ismidir.Dolayısı ile adrese dönüştürülür.
	m1.operator<<(endl); //'de argüman olarak function pointer gönderilir. Burada çağırılan operator <<'in parametresi function pointer'dır.

	- binary operatörleri overload edilen operator'ın sol operandı sınıf nesnesinden ise sol operand için fonksiyon çağırılır. eğer sol operand
	sınıf türünden değil ise ve sağ operand class türünden ise global bir operator function çağırılması gerekir.
        - cout << mydate gibi bir ifadenin glboal fonksiyon olmasının nedeni(operator<<(cout,mydate)) cout sınıfının const mydate &r gibi bir parametreli fonksiyon olmaması ayrıca
        bizimde standart kütüphaneye böyle bir fonksiyonu ekleyemeyeceğimizden kaynaklıdır.
        - binary simetrik operatörler global yapılmalıdır.
        - binary simetrik olmayan operatörler member function yapılabilir.(+=, -= ...)
        - *this'i değiştiren bütün operatör fonksiyonlarını member operator function yapılmalıdır.
        - yan etkisi olan herhangi bir operatör sınıfın member function'ı yapılır.
        - operator overloading kurallarına göre bir operator fonksiyonu static olamaz.
	- operator fonksiyonlarının geri dönüş değeri problem domaini yada logic yapısına göre değişir. reference yapısı olup olmamasıda tamamen logic yapı ile
	  ilgilidir.

        - primitive türden bir class görülmesi, örneğin int türden bir class--> class Integer gibi
          primitive türün yapamadığı bazı özellikler yaparız.
	- operator'un ürettiği değer l value expression olacak ise fonksiyonun döndüreceği değer reference olmalıdır.
	- operator'un ürettiğin değer r value expression olacak ise fonksiyonun döndüreceği değer const reference olabilir. Yada r value döndürmesi gerekir.

	- fonksiyon çağrılarında gereksiz kopyalamaktan kaçınmak için bir fonksiyonun parametresi sınıf türünden değil sınıf türünden referarans olacaktır.
        - iosfwd --> giriş çıkış sınıflarının forward declaration'larını koymuşlardır.
        - std::istream operator >>(std::istream & is,...) --> sınıfa özel giriş fonksiyonları için kullanılır. Burada fonksiyonun ikinci parametresi kesinlikle const olmayacaktır.
	- stl user defined türler sözkonusu olduğunda karşılaştırma operatörlerinden  < ve == operatörleri en önemli operatörlerdir. Bu iki operatörün stl'de özel anlamı vardır.
          Bir çok şablon şablonda kullanılacak türün bu iki operatör fonksiyonunu desteklediği varsayılır.

Not : C'de de C++'da da işaret operatörleri r value expression üretirler.
        - binary simetrik operatörler global yapılması gerekir.

	- parametresi olmayan bir operator ++ bildiriirse bu prefix(++x) olarak bildirilecektir. // C++'da ++x l value expression'dır. & türden yapılır
	- int türden parametresi olacak bir operator ++ bildiriirse bu postfix(x++) olarak bildirilecektir.//C++'da r value expression'dır. Türden yapılır.

	- yani prefix için Integer& operator++(); //prefix
	  yani postfix için Integer operator++(int);//postfix olur.

	Not : C++'da operatör fonksiyonları friend'in en fazla kullanıldığı yerlerdir.

	- çok sık kullanılan bir kodlama idiomumda  karşılaştırma operatörlerini < operatörünü kullanarak yazmaktır.

	 - sınıfın karşılaştırma operatörlerinin hepsini < operatöründen türetebiliriz.
           r1 < r2
           > operatorü  --> r2 <  r1
           <= operatörü --> !(r2 < r1)
           >= operatörü --> !(r1 < r2)
           == operatörü --> !(r1 < r2) && !(r2 < r1)
           != operatörü --> (r1 < r2) || (r2 < r1)
           - aritmetik operatör fonksiyonların en iyi yazılma şekli öncelikli olarak örneğin += fonksiyonu yazmak daha sonrasında ise + fonksiyonunun bu fonksiyonu kullanması şeklindedir.
           - + operator fonksiyonu işin += fonksiyonunu çağırarak görecektirç
           friend Integer & operator +=(const Integer &r1){
                  mval += r.mval;
                  return *this;
           }
           friend Integer operator +(const Integer &lhs, const Integer &rhs){
                  return Integer{lhs} += r2;// geçici nesne kullanıldı.
           }

           - Bu durum sadece + ve += için değil diğer fonksiyonlar içinde geçerlidir.
 ---------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------16.12.2017 CUMARTESİ---------------------------------------------------
        - özellikle stl kullanımı açısından, bir çok container sınıfının kullanılabilmesi için < operator fonksiyonun yazılımı gereklidir.
        - algoritmalar açısından baktığımızda == fonksiyonun olması gerekmektedir.(global find fonksiyonu)
        - küçüktür fonksiyonu özellikle set, multiset container'larında sınıf türünden öğelerin tutulması için geçerlidir.
       - == fonksiyonu özellikle find gibi fonksiyonların implementesi edilmesi için kullanılır.
        - global friend operator fonksiyonlarının tanımı sınıfın içinde inline olarak tanımlanabilir.

	- += fonksiyonu ve + fonksiyonu yazılırken ilk önce += fonksiyonu member function olarak yazılır. + fonksiyonu ise global olarak yazılıp içinde += fonksiyonunu
	  çağırmalıdır.

	- ön ek konumları(++x) l value expression'ken son ek konumları(x++) r value expression'dır.

	- Integer& operator++()//onek
	  {
		++mval;
		return *this;
	  }
          Integer operator++(int) //sonek
          {
                Integer temp {*this};
                ++*this;
                return temp;
          }

	- son ek operator ++ fonksiyonun dummy parametresi olacak.(Yani var olacak ama kullanılmayacak).

	- Not: son ek ++ operatörü *this'i artırmak için önek ++ fonksiyonunu çağıracaktır.

	---- inserter & extractor
        - inserter çıkış akımına veren formatlı yazım fonksiyonu.<<
        - giriş akımından aldığı byte'larlar nesneyi set eder.>>

        - kesinlikle global operatör fonksiyonu olur. friend olabilir.
        - çıkış akımını kontrol eden sınıfların taban sınıfı ostream'dir. Yani standart output'a yazılacak nesneler için doğrudan ostream sınıfı türünden nesneye ihtiyaç vardır.
        - Ama dosyaya yazılacak bir nesne için ostream'den türüyen fstream sınıfları türünden nesneye ihtiyacımız vardır.
        - Belleğe yazacak isek ostringstream sınıfı türünden nesneye ihtiyacımız vardır.

	- friend std::ostream &operator <<(std::ostream &os, conset Integer &i)
	  {
	       return os << "(" << i.mval << ")" <<endl;
	  }

        - burada fonksiyon os sınıfı kendisine gelen parametreye göre(cout gönderilirse cout) yazdırma işlemini yapar.
        - yukaridaki kodda ostream sınıfının << operatörü *this'i geri döndürmektedir. return fiadesi sadece os nesnesini geri döndürür.

	- frined std::istream &operator>>(std::istream &is, Integer &i){
                 return is >> i.mval;
          }

	 - cout << c1++ << "  " << ++c2 << endl;(9620)
	   //operator<<(operator<<(cout,c1.operator<<(0)).operator<<("   "),c2.operator++()).operator<<(endl);
         - Herhangi  bir sınıfın operatör fonksiyonunun member function'mı friend function'mı olup olmadığını anlamak için T.operator==(const T &) geçerli ise member değilse friend function'dır.

         - operatör overlaoding olsa dahi operatörlerin öncelik seviyesi herhangi bir şekilde değiştirilemez.
         - cout << 3 < 5 << endl; // gibi bir ifade sentaks hatası verecektir. Çünkü << operatörünün öncelik seviyesi < operatörünkinden daha yüksektir.
         Derleyici cout < 5 << endl; ifadesine çevirecekti. Bu durumda ostream sınıfının < operatörü olmadığı için derleyici hata verecekti.
				-------- özel operatörler ---------

	- dilin sentaksı ve kullanımı açısından özelliği olan bazı operatörlerdir.( [], *(içerik operatörü), ->, tür dönüştürme operatörleri, ()işlev çağrı operatörü)

	1-) köşeli parantez operatörü
                - operatör overloading kesinlikle intiutive olmalıdır.
                - söz konusu sınıfın dizi benzeri bir sınıf olmalıdır.
		- member function olmak zorundadır. p[n] biçimde yazılan bir ifadenin fonksiyon ile çağrılması p.operator[](n) ile yazılımı aynıdır.

                - köşeli parantez operatör fonksiyonunun parametresi size_t türündendir.

                - C'de de C++'da da köşeli parantez operatörü l value olmama ihtimali yoktur.
                - köşeli parantez operatör fonksiyonu referans döndürmelidir.
		- Bir sınıfın const'luk dışında aynı sınıfa ait function overload'u olabilir.
			- char &operator[](size_t idx);
			  const char &operator[](size_t idx)const;
		- köşeli parantez operator fonksiyonları için hemen hemen her zaman const overload olarak yazılır.const nesneler için fonksiyonun geri dönüş değeri const yapılır.

		- Name sınıfı için büyük beşli köşeli, parantez operatörü ve standart giriş  ve çıkış fonksiyonları yazıldı.(9780)
                - Map sınıfı container sınıflarının en önemli sınıflarından biridir. Sınıfta değerler key value ilişkisine bağlı olarak tutulur.
Not : x bir map nesnesi olmak üzere eğer x["asdasd"]; eğer böyle bir associative array yok ise map nesnesine ekleme yapılacaktır.


	2-) *(içerik operatörü)
		- *ptr --> ptr.operator*();
		- member function olarak yazılacaktır.
                - *ptr ifadesi bir sol taraf değeri ama ptr'nin kendisi bir pointer değildir.
                - böyle sınıflara smart pointer denilir.
                - smart pointer sınıfları dinamik nesnelerin kontrolünde kullanılır.
                - operator* fonksiyonu geri dönüş değeri referansdır.
                - *ptr ifadesi ptr hangi nesneyi göstreiyor ise o nesnenin kendisi olacaktır.
                - basit bir smart pointer sınıfı örneği myclass sınıfı türünden bir parametreli ctor'u olacak hayatı bittiğinde de destructor'ı myclass sınıfı türünden nesneyi delete edecektir.
                - Dinamik nesneyi delete etmek scope'la yapılacak.
                - Bir garbage collector mekanizması yapılacak.
                class Myclass {};

                class Myclassptr{
                public:
                        explicit Myclassptr(Myclass *pd);
                };



	3-) ->(ok operatör fonksiyonu)
		- ok operatörü binary bir fonksiyon iken unary bir fonksiyonmuş gibi görülür
                - member function olmak zorundadır.
                - bu operatörün normal kurallar ile implemente şansı yoktur.
                - a->b demek a.operator->()->b; demektir. ok operatörü T türünden pointer döndürür.
                - kesinlikle parametresi olmayacaktır.
                - fonksiyondan elde edilen geri dönüş değeri gene ok operandının soluna koyulur.
                - a.operator->()->b ifadesi fonksyion çağrıldıktan sonra (T *)->b ifadesine dönüşür.
                - bir sınıfın ok operatör fonksiyonu başka bir sınıfın ok operatör fonksiyonunu çağırabilir.
                - dinamik nesneleri MyclassPtr gibi sınıf nesnesinden bir nesneye bağlayarak hayatını sonlandırabiliriz(10133);
                - Bir fonksiyon'un birden çok değer döndürmesi için pair template'i kullanılır.C'de bunu yapmamız için bir yapı oluşturmamız gerekir.
        4-) tür dönüştürme operatörleri
        5-) () işlev çağrı operatörü
	class template örneği(10220);
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------17.12.2017 PAZAR---------------------------------------------------
	- unique_ptr nesnesine ilk değer verme zorunluluğu yoktur.
        - if parantezi içinde lojik bağlamda kullanılabilir.Eğer bir nesneyi gösteriyor ise lojik olarak doğru, aksi taktirde yanlıştır.
        - atama semantiği tamamen yasaklanmıştır. değer vermek istersek sınıfın fonksiyonları ile, yada ilk değer vererek yapmalıyız.
        - unique_ptr nesnesi kopyalama ve atamaya kapalı, sadece taşımaya izin verilir.
        - otomatik ömürlü yada static ömürlü bir nesne ile değer vermek sentaks hatasıdır.
	- dinamik bir nesne ile ilk değer vermeliyiz. Varlık nedeni bundan kaynaklıdır.
	- unique ptr sınıfının constructor'ı explicit'tir.
	- bu sınıfın ömür ilişkisin de scope vardır. garbage collector gibi kullanılır. Sınıfın hayatı son bulduğunda tuttuğu dinamik nesnenin hayatı da son bulur.
	- unique_ptr nesnesinde dil bize dinamik bir nesnenin tek sahibi olma imkanını verir. Dinamik nesneyi gösteren pointer  öldüğü zaman dinaik nesnenin hayatı da son bulur.
        - nesnenin sahipliği ancak taşıma semantiği ile bırakılır.
        - bütün container sınıfları reference yöntemiyle değil kopyalama yöntemi ile çalışır. Nesnenin kendisi değil, kopyası container da tutulur. nesnenin kendisinin tutulması için pointer yapısının kullanılması gereklidir.
        - Dinamik nesnelerin kullanılması söz konusu olduğunda ise nesnenin vector tarafından delete edilmesini sağlamak içib unique_ptr kullanılır.
        int main(){
            vector<unique_ptr<string>> us_vec;
            us_vec.push_back(unique_ptr<string>new string{"myvec1"});
        }
        // yukarıdaki örnekte vector container'ının ömrü bittiği zaman dinamik nesnenin de hayatı bitecektir.
        - smart pointer'ların en önemli kullanıldığı yerlerden biri exception handling'dir.
	- reference counting : reference sayımı, belirli bir T anında nesneyi gösteren kaç tane pointer olacağını gösterir.


	- shared_ptr bir nesnenin birden fazla sahibi olabilir. yani  kopyalama semantiği geçerlidir.
        - içerik operatörü, ok operatörü smart_pointer sınıfları için uygulanır.

        --- fonksiyon çağrı operatörünün implemente edilmesi ---

        - Fonksiyon çağrı operatörünün overload edilmesi asıl olarak şablonlarla birlikte kullanılır.

        - C'de func(); ifadesi
          1- bir fonksiyon ismidir. Fonksiyon çağrı operatörü olarak kullanılır.
          2- bir function pointer'dır. Function pointer'ın değerine sahip adresdeki fonksiyon çağrılır.
          3- bir makrodur.

        - C++'da bu ifadenin çok daha fazla anlamı olabilir.
          - 3'ü yukarıdaki ile aynıdır.
          - func bir sınıf nesnesi olabilir. Bu sınıf için fonksiyon çağrı operatörü overload edilmiş ise çağırılır. Derleyici sınıfın bir üye fonksiyonu çağrılmaktadır.
            Fonksiyon çağrı operatörü üye fonksiyon olmak zorundadır.
          - func bir lamda olabilir.
          - func bir bind nesnesi olabilir.
        - Bir ifade fonksiyon çağrı operatörünün operandı olduğunda öyle yada böyle bir fonksiyon çağrılıyorsa böyle ifadelere callable denir.
        - fonksiyon çağrı operatörünün implemente edilmesi RET.TYPE operator()(); şeklinde olur.
        - fonksiyon çağrı varsayılan argüman yazılabilen tek operatör fonksiyonudur.
        - operator tür dönüştürme  fonksiyonları ile sınıf türünden bir nesneye dönüşüm sağlanabilir.

	- operartor tür dönüştürme fonksiyonlarının geri dönüş değeri türü yazılmaz. Bu constructor gibi değildir.
	  zaten hedef tür yazılacağından dolayı geri dönüş değeri türünün yazılmasına gerek kalmaz.

	- operator tür dönüştürme fonksiyonu operator int()const; şeklindedir.

	- int mx = c; // derleyici bu ifadeyi aşağıdaki ifadeye dönüştürür.
	  int mx = c.operator int(); şeklindedir.(10699)
	  int mx = static_cast<int>(c);(C tarzı tür dönüştürme operatörü de kullanılabilir.)
	  int mx = (int) c;
          derleyici her biri için sınıfın operatör int fonksiyonunu çağıracaktır.

        - tür dönüştürme fonksiyonları global function olamaz.
	- derleyici arka arkaya iki tane user defined tür dönüşümü yapmaz.Derleyici ya bir otomatik conversion'ı takip eden user defined conversion, yada tam tersini yapabilir.

	- sınıfımıza kontrol etmek amaçlı operatör tür dönüştürme fonksiyonlarınıda explicit keywordu ile belirtebiliriz.C++11 standartları ile bu operasyon implemente edilebilir.
        - Bu derleyiciye otomatik dönüşümü kapatmamız için gereklidir.
        - Bunun amacı constructor'ı explicit yapmamız ile aynıdır. Tamamen derleyicinin otomatik olarak dönüşümü sağlaması değil bunu programcıya ait bırakmalıyız.

        - string s;
          s = "mustafa"; gibi bir ifade sınıfın const char * parametreli sxplicit olmayan bir conversion ctor'u olduğunu gösterir. Bu sınıfın atama operatör fonksiyonunun const char * parametreli olabileceğini de gösterir.
	- string sınıfının en önemli fonksiyonlarından biri c_str'dir. string sınıfı türünden bir nesneyi const char * türüne dönüştürür.

	- yani string sınıfından const char *'a otomatik tür dönüşümü yoktur. Bu yazıyı okuma amaçlı kullanmak zorundayız.

        - string literali --> çift tırnak içinde yazılan yazılar.
        -
	- C++'da sınıf türlerinden bool türüne otomatik dönüşüm yoktur. Yani logic yorumlamayı sağlayacak bir operatör fonksiyonu yazmak doğrudur.

	- bir sınıfın herhangi bir tür dönüştürme fonksiyonunu bool'in türüne dönüşüm için kullanabiliriz. Ama böyle bir kullanımın zararı çok olabilir.

	- modern C++ ile bir sınıfa operator bool yazılıp bu fonksiyon explicit yapılırsa başka türe otomatik tür dönüşümü yasaklanmış olur. logic bir problem domaininde
        kullanılması durumunda ise bu dönüşüm otomatik olarak yapılır.(11001)
        - istream ostream sınıflarının operator bool fonksiyonları var olup fonksiyon explicit'tir.

        - Fraction sınıfı için
          1- sınıfın   2 tane int parametresine sahip ctor'u olacaktır.
          2- sınıfı
---------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------23.12.2017 CUMARTESİ----------------------------------------------------------------

	-----------NESTED TYPES------------
	- sınıfın type member'ları vardır.(type members);
		1- bir türün bildirimi sınıfın içinde yapmak ile sınıfın dışında yapmak arasında fark vardır.(Bu class scope'da ki bir türdür.);
		2- en sık karşımıza çıkan nested types'lar typedef bildirimleri, bir sınıfın öğesinin başka bir sınıf olması, enum'lar.
	- nested type'lar da access kontrol yapılmaktadır.Yani client'ın bu bildirimlere erişebilmesi için sınıfın public bölümünde olmalıdır. isim aranacaksa sınıfın her yerinde aranmamaktadır. Class definition'dan bulunduğu yere kadar arama yapılır.
	  bütün class scope'u içinde aranmaz.
        - Eğer bir typedef isminin bütün sınıfı etkilemesini istiyorsak sınıfın en başına yazmalıyız.

	- class Word{
		public:
		void foo();
	  }
	  class Myclass{
		public:
			Word mword;//Bu Word sınıfı türünden bir nesnedir.
			typedef int Word;
	  }

	- fonksiyonun inline olması isim arama kurallarını değiştirmemektedir. Bir sınıf'ın member function'ında tanımlanan bir isim önce tanımlandığı fonksiyonun içinde
	  sonra bütün class scope'da aranacaktır.//bütün class scope sadece kendi bulunduğu yer değildir.(11541);
        - Bir sınıf kendisine ait type member class'ın sadece  public bölümüne erişim sağlayabilir.
          Eğer kapsayan sınıfa type member class'ın içinde friend'ilk verirsek private bölümüne erişebiliriz.
	  - pimple idiyomu - client'tan başlık dosyasının gereksiz include edilmesini sağlar. sadece bununla kalmayıp client'ten sınıfın private bölümünü gizleriz.
	  yani sınıfın öğelerini sınıfın veri elemanı yapmak yerine  pimple isminden bir yapının veri elemanları haline getirebiliriz.

          - iterator sınıfları sınıfın type class member'larıdır. Her bir container'ın iterator type'memberı vardır. basic bir implementasyonu aşağıdaki  gibidir.
          class List{
          public:
                class iterator{
                public:
                        int & operator*();
                        int *operator->();
                        iterator & operator++();
                        iterator operator++(int)
                };
                iterator begin();
                iterator end();
          };

          - Buradaki dikkat edilmesi gereken begin ve end fonksiyonları container'lara ait fonksiyonlardır. ve iterator türüne yani type member class türüne geri dönerler.
          - iteratorler
            1- string::iterator
            2- string::const_iterator
            3- string::reverse_iterator
            4- string::const_reverse_ iterator şeklinde container'lar için 4'e ayrılır.

          - iterator begin ve end fonksiyonları sadece member function olarak değil ayrıca global function olarak ta tanımlanıştır.
	 ----------------------------STANDART STRING CLASS--------------------------------

	 - string bir template sınıfın açılımının typedef isminden başka bir  şey değildir.
         - basic_string<char,char_traits<char>,allocator<char>> string sınıfı bu açılımın typedef
           bildirimidir.
	- template < typename A, typename B, typename C > //typename A--> template	type parameter.
       - string sınıfının assign fonksiyonunun 8 tane overload'ı vardır. Bunlar
         string (1)  string& assign (const string& str);
         substring (2) string& assign (const string& str, size_t subpos, size_t sublen = npos);
         c-string (3) string& assign (const char* s);
         buffer (4) string& assign (const char* s, size_t n);
         fill (5) string& assign (size_t n, char c);
         range (6) template <class InputIterator>
                           string& assign (InputIterator first, InputIterator last);
         initializer list(7) string& assign (initializer_list<char> il);
         move (8) string& assign (string&& str) noexcept;

       - string sınıfının iki farklı uzunluk döndüren fonksiyonları vardır. bunlardan biri size diğeri length'tir.
       - size bütün container sınıfları için kullanılırken length kodun okunulabilirliği için daha çok string sınıfında kullanılır.
       - string sınıfının empty fonksiyonu sınıf türünden veri elemanının boş olup olmadığını döndürür.
       - container sınıflarının önemli fonksiyonlarından biri olan pop_back fonksiyonu sondaki öğeyi container'dan çıkarır.push_back fonksiyonu ise sona ekleme yapar.

       - container sınıflarının erase fonksiyonu container'dan silme yapar. fonksiyon belirli bir range'i yada uzunluğu siler. yada tek bir iterator bölgesini siler.
         3 adet overlaod'u vardır.
             sequence (1) string& erase (size_t pos = 0, size_t len = npos);
             character (2) iterator erase (const_iterator p);
             range (3) iterator erase (const_iterator first, const_iterator last);

       - string sınıfının initialize ederken dikkat etmemiz gerekir.Örneğin
                string s(35,'A'); sınıfın int parametreli ctor'una çağrı yapıp s 35 tane A karakterinden oluşur.
                string s{65,'A'} ise sınıfı initializer_list'in char parametreli ctor'una çağrı yapılır. s ise sadece iki tane A karakterinden oluşur.

       - string sınıfının constructorları
       default(1) string();

       copy (2) string (const string& str);

       substring (3) string (const string& str, size_t pos, size_t len = npos);

       from c-string (4) string (const char* s);

       from buffer (5) string (const char* s, size_t n);

       fill (6) string (size_t n, char c); // string'i n adet karakter ile doldurur.

       range (7)  template <class InputIterator>
                          string  (InputIterator first, InputIterator last);

       initializer list (8) string (initializer_list<char> il);

       move (9)  string (string&& str) noexcept;

       - string'in capacity fonksiyonu

       - bir sınıfı öğrenirken öncelikli olarak nested type'lara bakılır
---------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------24.12.2017 PAZAR--------------------------------------------------------------------
       - bir  sınıf öğrenirken mncelikli olarak nested type'larını, sonrasında sınıfın public static elemanları olup olmadıığına bakılır.
       - iteratörler container'lardaki öğelerin konumun tutan varlıklardır.
       - C++'ta yazının bir karekterinin adresi doğrudan bizi ilgilendirmektedir. Yazının karakterleri index ve iteratör yolları ile erişilir.
       - string sınıfının nested type'ları
         1- string::size_type(size_t'nin typedef ismidir.)  // tane adet türlerinde karşımıza çıkar. Yazının uzunluğu bu türlerde tutulur. string sınıfının indexinin türü size_type'tır.
            -Arama fonksiyonlarının hepsi string::size_type'ını döndürür.silme,
         2-


	iterator
		string::iterator
		string::const_iterator
		string::reverse_iterator
		string::const_reverse_iterator
		gibi 4 farklı iterator nested type'ı vardır.
        - bunlar pointer gibi interface'i sahiptir. Tüm stl'e ait bir arayüzdür.

        - stl'in 3 önemli sınıfı vardır.
          1- container
          2- iterator
          3- algoritmalar
	- iterator semantiği bir container'da ki tutulan öğelerden her bir öğenin konumunu tutmak için kullanılır. container'daki her bir öğenin konumunu tutan nesnelere iterator denir.
        - C++'da range ifadesi iki tane konumdan oluşmaktadır.C++'da range ifadesi [begin,end) şeklinde gösterilir.
        - global begin fonksiyonu referans parametreli bir fonksiyon olup bizim gönderdiğimiz parametreyi alıp gönderdiğimiz sınıfın begin fonksiyonunu çağırır.
        - bir string'in tuttuğu yazının 10'unu da null karakter olabilir
	- modern c++ öncesi iterator veren fonksiyonlar sadece member function'lardı.

	- container'da tutan bir öğenin iterator'unun değerini sürekli artırırsak belirli bir noktada end fonksiyonunun gösterdiği iterator'a kadar devam edecektir. Yani bütün container'ı dolanacaktır.

	- eğer string sınıfının bir üye fonksiyonunun parametresi const char * ise sizden bir c-string(sonunda null karakter olan) istiyor. Bu durumda yazının son karakterinin null character olması tamamen bizim sorumluluğumuzdadır.

	- eğer const char *' a eşlik eden bir size_t parametre var ise, bu bir adres ve o adresden başlayarak kaç karakter alacağını gösterir.(buffer parametre)

	- iki adres isterse onu da range olarak kabul etmektedir.(range parametre). 1. iterator konumu dahil, ikinci iterator konumu hariç.

	NOT : buffer parametreye çok dikkat edilmesi gerekmektedir.

	- fill(doldurma) parametre. karakterden kaç tane olduğu ilk parametresi size_type n, ikinci parametreis charT türünden karakterdir.

	- parametresi string, size_type, size_type ise string'in i. indeksinden başlayarak n tane karakter kopyalayacak.

	- container'ın tamamını silen fonksiyon clear'dır. container'ı silmenin birden fazla da yolu vardır.
        - container'daki öğeleri silen fonksiyonun ismi remove değil, erase'dir.
	- string s1(35,'A');

	- string s2{35,'A'}; //initializer_list_ctor //bu constructor ile yukarıdaki constructor birbirinden farklıdır. sınıfların initalizer list constructor'ı var ise bunun önceliği vardır.

	- raw string literal(Sadece yazıma ilişkin bir notasyondur.) R"()" ile kullanılır.//c++11

	- R"--()--" ile de delimeter olarak da yazılabilir.

	- string sınıfı için ayrılan yer iki şekilde belirtilir. biri capacity diğeri length yada size.
          capacity, length ve size'a göre daha fazla bir yer alanı olup sınıfa eklenebilecek eleman
          sayısını gösterir. length capacity'e eşit olduğu zaman reallocation yapılır.
        - (capacity - size) değeri bize reallocation olmadan insert edilebilecek değeri gösterir.

        - reserve fonksiyonu baştan belirlediğimiz miktarda bir capacity'i bize sağlar.
          s.reserve(200000) // 200.000 byte'lık bir kapasiteyi baştan ayarladık.
        - Bu bize runtime'da realloc gibi bir fonksiyonun yeniden çağrılmasından oluşacak maaliyetten bizi kurtarır.
        - size'a dahil olmayan bir yere ulaşmak run time hatasıdır. Örneğin reserve fonksiyonu ile elde edilen bir yer size'ın dışında kalmış ise bu  alana erişmek runtime hatasıdır.
        - böyle bir isteğimiz olacak ise size'ı büyütmemiz gerekir.
        - size'ı büyütmenin yolları
          1-insert()
          2-assign()
          3- =
          4- +=
          5-push_back()
        -stringin size'ı büyür.

        - sınıfın resize fonksiyonuda nesnenin size'ını büyültmek için kullanılır. ayrıca fonksiyonu ile sınıfın size'ı küçültülebilir.
        - size'ı küçültmek için
          resize()
          erase()
          assign()
          =
          clear()
          pop_back()

        - resize daha çok container sınıflar için kullanılır. ekleme durumda iki tane overload'ı vardır.
        1.'si null karakter eklemek --> s.resize(20);
        2. si bizim belirttiğimiz karakteri ekleyecek s.resize(20,'A');

        - container'lardaki silme işlemleri sonucu önceden elde edilen bellek alanı(capacity) otomatik olarak geri verilmez.
          Yeri geri vermek için shrink_to_fit fonksiyonu kullanılır.
        - sınıfın back fonksiyonu son karakterini return eder.
	--------string::npos------

	- string sınıfının  const static, public bir  veri elemanıdır. türü size_type'dır.
        - bir string size'ı  unsigned int'in en yüksek değeri olur.

	- bir string'in olabilecek en uzun yazı sayısını gösterir. Yani bir yazı da geçerli bir indeks olarak kullanılamaz.

	- npos'un sık kullanılan yerlerinden biri arama fonksiyonlarının başarısızlık değeri'dir.
        - npos'un iki tane temel kullanım alnı vardır.
          1- arama fonksiyonları
             - C'den gelen interface, arama yapılan fonksiyon başarısız sonuçlanırsa nullptr döndürür.başarılı olursa bulunduğu yerin adresini döndürür.
             - iterator interface'ine göre arama yapan standart algoritmalar, bir range'i alıp aranan öğenin konumunu bulursa konumunu döndürür, eğer bulunamaz ise end iteratörünü döndürür.
             - string'in kendi arama fonksiyonlarında aranan  değer bulunursa hep index, eğer bulamaz ise npos değerini döndürür.
          2- npos'un ikinci kullanım alanı örnek verecek olarsak erase fonksiyonunun interface'inde
3. parametre olarak default parametre olarak kullanılır.
          s.erase(5,string::npos) // 5. karakter dahil olmak üzere  yazının sonuna kadar silecek.

        - string sınıfında arama işlemlerinde yazının içinde birden çok aynı karakterden var ise
string sınıfı arama fonksiyonları bize sadece ilk karakterin index'ini döndürecektir.
          bütün karakterleri dolaşmak için döngüsel bir yapıda, index'e göre arama yapılan idx'den sonra yeniden arama yapılmalıdır.

---------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------06.01.2018 CUMARTESİ--------------------------------------------------------------------

        - string sınıfının operatör fonksiyonları
          1-[] // vector,deque,string sınıflarının operatör fonksiyonları const overloading'e tabi
            tutulmuştur.Sınıfın verilen indexteki öğesine erişim sağlanır. sınıfın at fonksiyonu
            da verilen index'teki öğeyi döndürür. aralarındaki tek fark at fonksiyonu geçersiz index durumunda
            exception throw ederken, [] operatör fonksiyonu exception throw etmez,direk RTE'ye sebep olur.
            eğer sınıfın bu fonksiyonları olmasa idi([],at(),front()) öğelere erişim iterator yolu ile yapılacaktı.


        - string sınıfında son karakterine erişmek için
                 s.back();
                 s[s.length() - 1]
                 *--s.end();
                 *prev(s.end())
        - iterator fonksiyonlarından prev bir önceki öğenin konumunu verir.
        - stl'de container'larda bir iterator konumu geçersiz ise, iterator'u dereference etmek
          exception throw etmeyecektir.

        - sınıfın begin ve end içeren fonksiyonları her zaman iterator döndürür.
        - sınıfın begin ilk öğeye iterator verir. begin fonksiyonunun geri dönüş değeri index verir.
	- bir container sınıfının aralığını sınıfın begin ve end fonksiyonları ile belirleyebiliriz.

	- bir yazının ilk karakterine erişmenin yolu s.front() , s[0], s.begin() fonksiyonun geri dönüş değeri olan iter'i dereference etmektir.

	- bir yazının son karakterine erişmenin yolu s.back(), s[s.length() - 1], *--.end() = yada bunun yerine *prev(s.end()) ile yapılabilir.

	- C++11 ile global begin ve end fonksiyonu eklenmiştir.
		begin(s); // end(s)

	- her iterator sınıfının hem const iterator(string::const_iterator), hemde iterator nested type'ı vardır. eğer bir range'i okuma amaçlı dolaşmak için kesinlikle const_iterator'u kullanmalıyız.

	- cbegin ve cend fonksiyonları const_iterator döndürür.

	- modern c++'da bir container'ı okuma amaçlı dolaşmanın yöntemi şöyledir.

		- for(auto citer = svec.cbegin();iter != svec.cend(12654); ++iter)//örneklerde ki kodda hata var.doğrusu burası
				// sadece container'ı okuma amaçlı kullanılabilir.

	- global cbegin ve cend fonksiyonu da vardır.
        - C++11 ile iterator sınıflarına const iterator döndüren cbegin, cend fonksiyonları eklenmiştir.
        - global cbegin ve cend fonksiyonları da vardır.
	- reverse iterator : öyle bir iterator ki  artırılırken iterator azalarak gider. Sondan başa doğru dolaşmak içindir.

	- rbegin verdiği değer son öğenenin konumudur.
		string::const_reverse_iterator iter = s.rbegin();

	- vector, deque, string, array iteartorlerine sahip sınıflar ile pointer'larla yapılan bütün işlemleri gerçekleştirebiliriz.

	- range based for loop ile derleyici iterator kodu yazma kısmını derleyiciye bırakmış oluruz.

        range based for loop for(char c : s) //Burada c otomatik ömürlü bir nesnedir.  Burada kopyalama olacaktır.
	for(char &c :S )// Burada ise referans semantiği yapılacaktır. c' de yapılan herhangi bir değişiklik container'daki nesneyi de etkileyecektir.

	- for(auto x :c) ile container'da tutulan öğede herhangi bir değişim söz konusu olmayacaktır.

	  for(const &x : C) ile öğenin yine kendisi ama sadece okuma amaçlı kullanılır.


	for (auto x : c)-> yi derleyici
	for(auto iter = c.begin();iter != ivec.end(); ++iter){
		int temp = *iter;
		++iter şeklinde bir kod üretir.
        }// haline getirir.
	// Ama bunun herhangi bir ek maaliyetini çok fazla olduğunu söyleyemeyiz. Derleyicinin optimize etmesinden dolayıdır.
        for( auto &x : c)->yi ise derleyici
        for(auto iter = c.begin(); iter != c.end(); ++iter){
                 int & temp = *iter;
                 ++iter;
        }//haline getirir

        - STL tamamen range mantığı ile çalışır.

        - string sınıfının sort veya reverse fonksiyonu yoktur. bunlar algorithm başlık dosyasında declara edilmiş global fonksiyonlardır.

         - auto iter = find(svec.begin, svec.end(),"sinan"); find fonksiyonu bir range başlangıcı, ve sonu ister. ve aranacak değeri 3. parametre olarka alır.
      geri dönüş değeri iterator cinsindendir.
	- arama fonksiyonları

	- string sınıfınun find fonksiyonları
		- hepsi member function'dır. ilk parametresi ne aranacağı. ikinci parametresi arama yapılacak index
		- geri dönüş değeri size_type türündendir. eğer arama bulunursa index'i döndürür. bulunamazsa string::npos döndürür.
		 string s {"polat alemdar"};

		 auto idx = s.find('a');//3

		 auto idx = s.find('a', 4);//6
		 auto idx = s.find('a', 7);//11
	- string sınıfı yazının uzunluğundan fazla bir idx'i bir fonksiyona parametre olarak göndermek herhangi bir rte değildir.legaldir.C++11 ile gelmiştir.

		- rfind -> aramayı sondan başlatır.(12902)strchr ile strrchr gibi

		-find_first_of --> strpbrk gibi verilen karakter setinde olan karakterlerden ilkini bulacak
		-find_first_not_of --> girilen karakterlerden biri olmayan ilk karakteri bulacak.
	bunların tam tersi
		- find_last_of aramaya sondan başlayacaktır.
		- find_last_not_of --> girilen karakterlerden biri olmayan aramaya sondan başlayarak yapar.

----------------------substring------------------
		- str.sub_str(4,5) ilk parametre indeksi 2. parametre kaç tane karakter alacağını yazarız.
		- eğer fonksiyonun  2. parametre geçmez isek yazının sonuna kadar alır.
		- herhangi bir argüman göndermeden çağırırsak c'deki strdup gibi yazının bir kopyasını elde etmiş oluruz.


	- silme işlemleri (erase fonksiyon);
                - silme işlemleri hangi indexten başlayarak kaç karakter sileneceğini gösteriririz.
		- erase(13025)

                - index parametreli erase fonksiyonuna ikinci parametreyi geçmez isek verdiğimiz idx'ten başlayarak geriye kalan bütün yazıyı siler.
                - yazıdan sadece bir karekter silmek için str.erase(1,1);
                - string'in index parametreli erase fonksiyonları sadece string'e ait fonksiyonlardır.
                - bütün container'ların ortak erase fonksiyonları iterator ile çalışır.
                    1- bir iterator alıp o iterator'deki öğeyi siler.
                    2- range parametreli, iki tane iterator fonksiyon alıp arasındaki öğeleri siler.
		- str.erase(str.begin() +1 , str.end() - 1) ile ilk ve son harfi hariç hepsini siler.
		index parametreli fonksiyon
			- 1. parametreden başlayarak 2. parametre'deki kadar yazıyı siler.
			- 2. parametreye argüman geçilmez ise 1. parametreden başlayarak bütün yazıyı siler.
			- iterator girilerek(bütün container'lar için geçerlidir) o iterator daki nesne siler.
			- hiç bir argüman geçmez isek bütün yazıyı siler.
                - eğer iterator konumunu aritmetik operatör'ler kullanarak belirtmek istemiyorsak C++11 ile gelen global prev ve next fonksiyonlarını kullanabiliriz.
	--- insert fonksiyonları ---
                - atama yaparak s = "mustafa"; //gibi değiştirebiliriz.
                - str.resize(size_t n, char c = '\0') // büyültebiliriz.
                  str.resize(20); // str'nin uzunluğu 20'den az ise null character ile 20'ye tamamlar.
                  str.resize(20,'A') // null character yerine 'A' ile tamamlar.
                - sondan ekleme ile yapılabilir.
                  str += 'X';

                - push_back ve append fonksiyonları ile sona ekleme yapılırken, insert fonksiyonu ile herhangi bir yere ekleme yapabiliriz.
                  str.append(10,'X'); // yazının sonuna 10 tane X karakteri ekler.
                  str.push_back('A') // yazının sonuna A karakteri ekledi.vectorun ortak interface'idir.
		- insert fonksiyonlarında iki tane ayrı interface vardır.(iterator ve index interface'leri)
		- index interface'i ile çalışanların yani index parametreli olanların hepsinin geri dönüş değeri *this'dir.
                - str.insert(size_type pos,size_type n,char c); // verilen pozisyona kaç tane karketeXr ekleneceği
                - str.insert(size_type pos,const string &s);// verilen pozisyona string'i ekleme

		- iterator interface'i ile çalışanlar index döndürür.
                - insert fonksiyonlarında index yolu ile çalışanlar
                 string (1)	string& insert (size_t pos, const string& str);
                 substring (2)	string& insert (size_t pos, const string& str, size_t subpos, size_t sublen);
                 c-string (3)	string& insert (size_t pos, const char* s);
                 buffer (4)	string& insert (size_t pos, const char* s, size_t n);
                 fill (5)	string& insert (size_t pos, size_t n, char c);

                - iterator ile çalışanlar
                  fill  iterator insert (iterator p, size_t n, char c);// n tane karakter ekler
                   single character (6) iterator insert (iterator p, char c);// sadece bir tane karakter ekler
                   range (7) template <class InputIterator>
                                iterator insert (iterator p, InputIterator first, InputIterator last);//belirtilen iterator aralığını ekler.
                   initializer list (8)	string& insert (const_iterator p, initializer_list<char> il);
        - erase fonksiyonlarında dikkat etmemiz gereken bir konumdaki nesne silindikten sonra o konuma başka bir nesne gelmektedir. buna bağlı olarakta kodumuzda index'i geri götürmemiz gerekebilir.
        - insert fonksiyonlarında ise bir sebeple bulunan harfin konumuna ekleme yapılaacaktır. buna bağlı olarakta indexi artırmamız gerekebilir.

	- replace fonksiyonaları
		- iki tane ayrı interface vardır.(iterator ve index interface'leri)
		- bütün replace fonksiyonları *this döndürür.
          string (1)
          basic_string& replace (size_type pos,     size_type len,     const basic_string& str);
          basic_string& replace (const_iterator i1, const_iterator i2, const basic_string& str);

          substring (2)
          basic_string& replace (size_type pos, size_type len, const basic_string& str,
                       size_type subpos, size_type sublen = npos);

          c-string (3)
          basic_string& replace (size_type pos,     size_type len,     const charT* s);
          basic_string& replace (const_iterator i1, const_iterator i2, const charT* s);

          buffer (4)
          basic_string& replace (size_type pos,     size_type len,     const charT* s, size_type n)
          basic_string& replace (const_iterator i1, const_iterator i2, const charT* s, size_type n)

          fill (5)
          basic_string& replace (size_type pos,     size_type len,     size_type n, charT c);
          basic_string& replace (const_iterator i1, const_iterator i2, size_type n, charT c);

          range (6)

          template <class InputIterator>
          basic_string& replace (const_iterator i1, const_iterator i2,
                        InputIterator first, InputIterator last);


          initializer list (7)
          basic_string& replace (const_iterator i1, const_iterator i2, initializer_list<charT> il);


---------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------07.01.2018 PAZAR--------------------------------------------------------------------

        - container nesnelerini primitive türden nesneleri takas eder gibi etmemeliyiz.Bunun için
          sınıfların kendi swap fonksiyonlarını yada global swap fonksiyonunu kullanabiliriz.
        - tüm container sınıflarının swap isimli fonksiyonu vardır.
        - sınıfın swap fonksiyonu ile global swap fonksiyonu hemen hemen aynı kodu üretir.

        - büyük projelerde cpp ve c kütüphanelerde kullanılıyor. Bu yüzden string sınıfının c_str() isimli fonksiyonu string'i bir const char *'a dönüştürür.
        - c_str() fonksiyonunu asla set amaçlı kullanmamalıyız.
        - okuma amaçlı bu yazıyı bir fonksiyona göndermemiz de hiç bir sakınca yok
	- bir string sınıfı türünden nesneyi sadece okuma amaçlı kullanırsak nesnenin adresinde herhangi bir değişiklik olmayacaktır.

	- ama nesneye  uygulanan büyültme yada küçültme  işlemleri sonucu nesnenin adresinin aynı kalacağı hakkında kesin bir bilgi veremeyiz.

	-  KARŞILAŞTIRMA OPERATÖRLERİ

	- iki farklı karşılaştırma şekli vardır.
		1-) operatör overlaoding ile gelen karşılaştırma operatörleri
		2-) C tarzı strcmp
	geri dönüş değerleri int türündendir.

	string s1{"bu yil kis gelmedi"};

	string s2{"burasi mecidiyekoy"};

	s1.compare(s1.size() -5, 5,s2,s2.size() -5,5);

        string (1)
        int compare (const string& str) const noexcept;

        substrings (2)
                   int compare (size_t pos, size_t len, const string& str) const;
                   int compare (size_t pos, size_t len, const string& str,
                       size_t subpos, size_t sublen = npos) const;

        c-string (3)
                 int compare (const char* s) const;
                 int compare (size_t pos, size_t len, const char* s) const;

        buffer (4)
               int compare (size_t pos, size_t len, const char* s, size_t n) const;

        - algoritmalar her zaman iterator ile çalışır.
        - iterator birer pointer olabilir. Ama dil bu garantiyi vermemektedir.
	- iterator'ler konum tutan  nesnelerdir.
        - iterator'un türüne bağlı olarak, ++ veya -- operatörlerini kullanarak geri yada ileri doğru hareket ettirebiliriz.
        - örneğin string sınıfının iteratoru random access iteratördür. Yani poninter'lar ile yaptığımız her türlü işlemi bu iteratör ile de yapabiliriz.(iter += 2);
        - azaltma her iteratörün interface'inde olan bir işlem değildir.(tekli bağlı listede yoktur.)
        - iterator'lerin türleri aynı olmasa bile bir algoritma farklı iki container üstünde işlem yaptırabilir. örneğin vector de ve list'te tutulan iki string'i birbirine atanabilir.

        - iterator'ler ile yapılamayacak işlem, iterator'un gösterdiği nesneyi container'dan silemeyiz. iterator bizi container'a değil, container'da tutulan değere eriştirir.
        - iterator parametreli bir fonksiyon ilgili container'a bir ekleme yada silme yapamaz.
	- STL algoritmaları hiç bir zaman bir container'a ekleme yada container'dan silme işlemi  yapamaz. çünkü silme yada ekleme işlemini sadece container sınıfının member function'a yaptırabiliriz.

	- STL' deki silme algoritmaları silme yapamaz ancak  lojik silme işlemi yapabilirler.(remove)
        - remove fonksiyonunun geri dönüş değeri bize bir iterator verir. verilen iterator bize lojik silme yaplımış yerin konumu döndürür.
        - bu konumu container'ın erase fonksiyonuna argüman olarak gönderebiliriz.st
          str.erase(std::remove(str.begin(),str.end(), char c), str.end()); // silme işlemini yapar.
        - remove algoritması belirli değerlerdeki öğeleri silmek için kullanılır.
        - remove_if algoritması belirli özelliği sağlayan algoritmaları silmemizi sağlar.3. parametresi function poniter'dır.

	----------------------COMPOSITION---------------------


        - composition yapmak için bir çok yol vardır.
        - sınıflar arasında en çok kullanılan ilişki biçimi composition ve inheritance'dır.

	- en fazla karşımıza çıkan biçim bir sınıfın başka bir sınıf türünden öğeye sahip olması şeklindedir.

	- iki sınıf arasındaki composition ilişkisine bir nesne başka bir nesnenin sahibi olupu olmadığı anlamınagelir.
        - ingilizce de ye bu ilişkiye (has a) ilişkisi denir.

	- string sınıfı  compositionda en çok kullanılan sınıftır.



	- bir sınıfın başka bir sınıf türünden nesne içermesi çok normal bir durumdur. composition ile sahip olunan nesnenin interface'ini ele almıyoruz.


	- access control:
	- scope


	- bir sınıfın non-static veri elemanı incomplete type olamaz. static veri elemanı içinse incomplete type olması yeterlidir.

	- bir sınıfın başka bir sınıf türünden nesnesi olması fiziksel olarak ta olduğu anlamındadır.(sizeof içerisindeki nesne kadar atar.)



	- başka bir sınıf türünden elemena sahip olması eleman olan sınıfın private yada protected bölümüne erişim hakkı yoktur.
	- Bir composition da private bölüm kapalıdır.
	- Bir Car türünden x nesnesi hayata geldiğinde onun içindeki Engine türünden eng nesneside hayata geliyor. ilk hayata gelen eng nesnesidir.(13655)
        -  Derleyici member'ları her zaman default ctor ile hayata getirir. Eğer member'ların parametreli ctor'ları var ve default ctor'ı yok ise derleyici otomatik olarak
           çağrı yapmaz.

        - member'ların hayata geliş sırası tamamen bildirim sıralarına göredir. MIL sentaksı ile herhangi bir alakası yoktur.

        - derleyici eğer composition'a ait sınıfın constructor'larında sahip olduğu nesneyi hayata getiren bir constructor göremez ise derleyici bu constructor'ın kodunu kendisi ekler. Buda default constructor'dır.
          Eğer sahip olduğu nesnenin default constructor'ı yok ise bu sentaks hatası olacaktır.
          Bunu sağlamanın tek yolu ise mil sentaksı ile kodu kendimiz yazmamızdır. Yada sahip olunan nesneye default ctor'u eklememiz gerekir.
          class Engine{
          public:
                Engine(int);
          };

          class Car{
                Engine eng;
          public:
                Car(){}//Error. Engine can not be created;
          };
///////////////////////////////////////////////////////////////////////7
          class Trader{
                std::string m_name;
          public:
                Trader()= default;//m_name default construct edilecek. m_name uzunluğu 0 olan bir yazı
          };

        - composition olan öğenin(yukarıdaki Car,Engine örneğindeki Engine), her zaman construct edilmesini kendimiz yapmalıyız.(default ctor olacaksa bile);
	--------COMPOSITION AND INTERFACE--------

	- composition'da  öğe olarak aldığımız sınıfın interface'i o öğeye sahip sınıfın interface'ine eklenmiyor.
	- yani composition bir interface devralma ilişkisi değildir. Eğer böyle bir şey istiyorsak bu kalıtımdır.
        - Örneğin car sınıfının engine sınıfı türünden bir öğesi olsun. engine sınıfının fonksiyonlarının aynısı car sınıfının fonksiyonu olduğu anlamına gelmez.
        - Kalıtım ise bir interface devralma ilişkisidir.

        - Ama varolan bir sınıfın interface'ini daraltarak yada özel bir şekilde biçimlendirerek client'lere vermek istiyorsak bunun yolu compesition'dır.


        - Composition'da ömrü biten bir nesne için destructor'ı sahip olunan nesne için çağıracak.
          Car sınıfı örneğine baz alınırsa
          ~Car(){
                /////
                ///// eng.~Engine();
          }
        - Hayatının son bulmasında da daha sonra hayata gelen daha önce hayata veda edecektir. İlk olarak car engine nesnesi hayata geldiği için engine nesnesi daha sonra hayata veda edecektir.

        - örnek bir composition
        template<typename T>
        class Stack{
              std::vector<T> mvec;
        public:
              void push(const T & val){
                   mvec.push_back();
              }
              void pop(){
                   mvec.pop_back();
              }
              T & top(){
                  if(mvec.empty())
                        throw new Exception;
                  return mvec.front();
              }
              bool empty(){
                   if(mvec.empty())
                        throw new Exception;
                   else
                        return mvec.empty();
              }
              size_t size(){
                   return mvec.size();
              }
              void clear(){
                   mvec.clear();
              }
        };
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------13.01.2018 CUMARTESİ--------------------------------------------------------------------

	-------- COMPOSITION VE COPY CONSTRUCTOR ----------

	- class Engine{
	public:
		Engine() = default;// ileri de göreceğiz.
		Engine(const Engine &c)
		{
			std::cout << "Engine::copy ctor" << std::endl;
			//Herhangi bir şekilde copy construct edildiğinde bu fonksiyon çağırılacak.
		}

	};

	class Car{
		Engine e;
	public:
		// Car() = default;
		// Car(const Car &c){
			std::cout << "Car"
		}
	}

	int main(){
	Car c1;

	Car c2{c1}; //c2 için copy constructor yazılacak. Ve Engine nesnesi için de copy constructor çağırılacak.

	}

	- Bir nedenden dolayı sınıfa yazılan copy constructor için ayrıca default constructor'da çağırılacaktır.
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	class CrtptoTrader {
		std::string mname;
		Date mbdate;
	public:
		CrpytoTrader(const std::string &name,const Date &d) : mname{name}, mbdate{d}
		{}

		void display()const
		{
			std::cout << "(" << mname << ", " << mbdate << ")" << std::endl;
		}
	}

	int main(){
		CryptoTrader ctp{"lorem ipsum", Date{4,7,2002}};

		ctp.display();

		CryptoTrader ctp2{ctp};
	}

	- Bir sınınf için bir nedenden dolayı ctor yazılıyor ise bütün öğeleri copy constructor etmek tamamen bizim sorumluluğumuzdadır. Eğer
	  yapmaz isek derleyici diğer sınıf nesneleri için default constructor'ı yapacaktır.

	- modern C++'da const char * istenen yerde mutlaka string kullaılmalıdır.

	- adres dönüşümleri hiç bir zaman static cast değil reinterpret cast'tir.
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------14.01.2018 PAZAR--------------------------------------------------------------------

	- hiç bir constructor bildirmemek 6 tane özel fonksiyonu derleyiciye havale etmektir.

	- Bir fonksiyona yazma görevi derleyiciye havale etmiş ve derleyici bu fonksiyona çağırması geçersiz sayılıyorsa
	  derleyici bu fonksiyonu deleted olarak kabul eder.

	-   class A{
			A();
		}

		class B{
		public:
			B();
		}

		int main(){
			B bx;//attempting to deleted function. yukarıdaki duruma örnektir.
			// Bu sadece olabilecek örneklerden biridir.
		}

	- derleyicinin yazması gereken kopyalayan fonksiyonlar, deleted olma durumuna düşerse move member not declared(hiç bildirilmemiş olarak)
	  ele alınır.

	- bir sınıfın taşıyan kurucu işlevi yok ise onun yerine copy constructor çağırılacaktır.

	- sınıfların her zaman olması gereken bir fonksiyonu copy ctor ve copy assingment'tır.

	- bir sınıfa move ctor yazmak istersek her bir member için de move fonksiyonu çağrılmalıdır.

	---------- 2. Bölüm için Önemli konular-----------

	1-) Kalıtım(10'a yakın alt başlığı var)
	2-) Exception Handling(olağan dışı durumların işlenmesi)
	3-) İsim alanları(Namespace)
	4-) Dinamik ömürlü nesneler
	5-) Şablonlar(Templates)
	6-) Lambdalar
	7-) STL
	8-) Giriş çıkış işlemleri(belleğe, dosyaya, formatlı ve formatsız okuma)
	9-) Uygulama pratiğinde önem taşıyan STL'in sınıfları

	---------- KALITIM(INHERITANCE) ----------

	- nesne yönelimli programlamanın olmazsa olmaz bir aracıdır.

	Not :
		- Bir sınıfın veri elemanı pointer ise copy ctor ve copy assignment'ı yazmalıyız. eğer unique_ptr kullanmazsak.
		- eğer sınıfımızın öğesini başka bir sınıf türünden yapmış olursak

		- template <typename T>
		  void func(T) = delete;

		  void func(int);

		- Bir fonksiyon şablonu ile aynı isimli bir fonksiyon var ise exact match olduğu durumlarda derleyici şablondan herhangi bir fonksiyon
		  kodu üretmez.

	- is a relation : bir sınıfın, başka bir sınıfın tamamen interface'ini kullanmaya denir.

		class Engine{
		public:
			void start();
		}

		class Car{
			Engine eng;
		public:
		}

		int main(){
		Car a2;
		a2.start();// kalıtım tam olarak böyle bir kullanım örneğidir.
		}

	- eğer interface'i kontrollü olarak ele almak istiyorsak bunu composition denir.

	- kalıtım da ise interface'i tamamen ele almamız gerekecektir.

	- kalıtım 3 kategoriye ayrılır. (private in, protected in, public in)

	- protected ve private inheritance composition'a alternative'dir.(Bu ikisi daha sonra istenecektir.)

	- programlama dillerinde genel kalıtım C++'da public inheritancedır.

	- multiple inheritance :
		1-) çoklu kalıtım'dır.
		2-) tek bir kalıtım işlemi birden fazla sınıfın interface'ini devralma işlemidir. Gerekirse bu interface'i genişletecek yeni bir sınıf türütmektir.



---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------20.01.2018 CUMARTESİ--------------------------------------------------------------------

	- kalıtım :
		1-) 1. amacı eskiden olan kodların bir daha kullanılması değildir.
		2-) Kod yazmayı çok daha kolay hale getirmektedir. Ayrıca eski kodların yeni kodları kullanabiliyor olabilmesidir.

	- Kalıtım'da interface'i tamamen devralacağız.
	- Kalıtımın kullanıldığı sınıfa super class yada parent class denir.
	- Kalıtım ile elde edeceğimiz sınıfa sub class, yada child class denir.
	- C++'da kullanılan terimler de parent class yerine Base class nedir. child class yerine de derived class denir.
	- Yani base class denildiği zaman is  a ilişkisi olmak zorunda değildir.(public, protected - private(composition tarzı)).
	- Genelde kalıtım bir hiyerarşi sistemi üzerinde olacak.
	- Kullandığınız programlama dili ne olursa olsun, base class'ın member function'ları tipik olarak üç kategoriye ayrılır.
		1-) interface veren ve implementasyon verecek(Yani benim verdiğim interface'i ve implementasyonu kullanacak.)

		2-) interface veren ve default implementasyon veren(Yani beinm interface'i verecek ve implementasyon olarak kendi verdiği implementasyonu kullanıp kullanma
		    ması tamamen client'e bağlı olacaktır.(overrride->ezmek))
	polyformic class : eğer bir sınıfın 2. kategoride bir sınıfı varsa buna çok biçimli class denir.

		3-) interface veriyor ama implementasyonu hiç vermiyor(Eğer parent class'tan kalıtım ile elde edilecek sınıflar implementasyonu tamamen kendi yapacaktır.)
			abstruct class->soyut sınıftır.

	- C++'da bir class ya soyut class'tır. Ya da somut class'dır.
	- Sınıfların protected bölümleri kendi client'lara kapalı ama o sınıftn kalıtım yolu ile  elde edilmiş sınıflarına açıktır.


	- C++'da kalıtım sentaksı :
		- kalıtım da super(base) class olarak kullanılacak sınıfın mutlaka complete type olmalıdır.

	- class Der : public Base {};(14568) --> burada public türetme sözcüğüdür. burada kullanılan sözcüğe göre public, private, yada protected keyword'u inheritance'ı kullanılmıtır.

	- Hiç bir keyword kullanılmaz ise default'u private inheritance'tır.(14581)

	- C'de ki struct'lar C++'da class'dır. struct anahtar sözcüğü kullanırsak default erişim bölgesi public'tir.(struct Der : Base{})
	  struct anahtar sözcüğü ile kalıtım yapılırsa default'ı public inheritance'tır.
	- Yukarıdaki  özelliklerin aynısı multiple inheritance içinde geçerlidir.

	- kalıtım da isim arama :
		- immediate base class : doğrudan tabanlı bir sınıf D sınıfı C'den, C sınıfı B'den, B sınıfı A'dan türetilmiştir.
		  C sınıfı D sınıfı için base class'tır.

		- D sınıfı türünden bir nesne için isim arama ilk olarak D sınıfı içinde yapılır. D' de bulunamazsa C'de bulunamazsa B'de bulanamazsa
		  A'da aranacaktır.

		- türemiş sınıf nesneleri taban sınıftaki bir nesneyi kullanabilir.

		- taban sınıfın ismi ile türemiş sınıfın ismi aynı scope içinde değildir. Yani doğrudan function overloading yoktur.
		- taban sınıfın aynı isimli fonjksiyonu ile türemiş sınıfın aynı isimli fonksiyonu birbirini overload etmez.
		- class Base{
		public:
			void func(int);
		}
		class Der : public Base{
			void func();
		}

		int main(){
			Der myder;
			myder.func(23) // sentaks hatası
		}

	- access kontrolü her zaman en sonda yapılır.

	- C++'da inheritance'da  function overload'ı yapabilme imkanımızı sağlayan using bildirimi aracı ile yapabiliriz.

	- üye fonksiyonunun içinde isim arama ise isim ilk önce blokta, aranan isim daha sonra kapsayan bloklarda eğer gene bulunamazsa
      türemiş sınıfın içinde gene bulunamazsa taban sınıflarda arayacaktır.

	- Fiziksel olarak kalıtımda bir sınıfın içinde başka bir sınıf türünden nesne vardır.
		class Base{
			int mx, my, mz;
		public:
		};

		class Der : public Base{
			int mx;
		public:

		};

		int main(){
			using namespace std;
			cout << "sizeof(Base) = "<< sizeof(Base) << endl;//8
			cout << "sizeof(Der) = "<< sizeof(Der) << endl;//12
		}

	- composition'da da aynı durum vardır.

	- Böyle durumlarda composition söz konusu ise B sınıfının A türünden bir öğesi vardır.(embedded object denir)
	  A'nın interface'i B'ye eklenmemiştir.

	- Kalıtım söz konusu ise B sınıfı A türünden türetilmiştir.(base class object denir)
	  A'nın interface'i B'ye eklenmiştir.

	- Her zaman composition'ı kalıtıma tercih edin.

	- upcasting : yukarı doğru dönüşüm. türemiş sınıftan taban sınıfa doğru yapılacaktır.

	- herhangi bir neden ile A'dan B'ye dönüşüm yapılmak isteniyorsa down casting denir.

	- taban sınıfın private kısmı her durumda diğer sınıflara kapalıdır. Herhangi bir şekilde kalıtım yapılmış ise bile.

	- public kalıtımında taban sınıfın  public interface'i tamamen bizim sınıfın interface'ine dahil edilmiştir.

	class Base{
		void pri_func(){};
	public:
		void pub_func(){};
	protected:
		void pro_func(){};
	};

	class Der : public Base{
		public:
		void derfoo(){
		pro_func();
		pub_func();
		}
	};

	int main(){
		Der myder;
		myder.pub_func();
		myder.pro_func();//geçersiz
		myder.pri_func();//gecersiz
	}(14715)


	- Yani public kalıtım yoluyla elde edilmiş bir sınıf türü protected bölümüne erişim vardır. public kısmına zaten vardır.
	  private kısmına zaten yoktur.
	- client'ler sadece türetilmiş sınıf türünden bir nesne ile sadece taban sınıfın public bölümüne erişim yapılabilir.
	- türetilmiş sınıf ise taban sınıfın protected bölümüne erişim yapılabilir.

	- bir kalıtım yolu ile türetilmiş bir sınıftan bir nesne ile taban sınıfından bir nesneye atama yapılabilir.referans yada pointer ataması yapılabilir.(upcasting.)(14751)

	- her ne kadar bu durum geçerli olsa da ileride anlayacağımız nedenlerden taban sınıfından bir nesneye doğrudan türemiş sınıf türünden bir nesneye atama istenen bir atama
	  değildir.object sliding(nesne dilimlenmesi). hemen her zaman bu aktarımlar pointer yada referans yoluyla yapılır.(mybase = myder//ama legal değil)(14772
	  )

	- taban sınıf nesnesinden türemiş sınıf nesnesi türüne aktarım doğrudan, pointer ve referans semantiği ile yasaklanmıştır.

	- türemiş sınıf nesnesi ile taban sınıfın bir fonksiyonu çağırılır ise derleyici türemiş sınıf nesnesinin içindeki taban sınıf türünden nesnesinin
	  fonksiyonunu çağıracaktır.

	class Base{
		int mx, my;
	public:
		void setbase(int x, int y){
			mx = x, my = y;
		}
	};

	class Der : public Base{
		int ma;
	public:

	};

	int main(){
		Der myder;
		myder.setbase(); // ile Der nesnesi içindeki Base nesnesi'nin adresidir. setbase fonksiyon'a gelen this adresi de bu türemiş sınıf'ının içinden taban
		//nesnesi gelecektir.
	}

	- baseptr = derptr// ile derleyici baseptr'ye derptr'nin içindeki der nesnesinin adresini gösterecektir.

	- void carGame(Car * ptr); // ile burada Car *ptr yerine Car sınıfı türünden türetilmiş bir nesne de gönderilmiştir.

	- ok operatoru yada nokta operatoru ile ilgili nesne'nin bir fonksiyonu çağırılırsa mutlaka isim arama o class scope'da aranacaktır.(14845)

	---- Kalıtımda özel işlevlerin durumu----

	- eğer kalıtımda olsa composition da olsa bir sınıf nesnesi içinde başka bir sınıf vardır.

	- önce taban sınıf alt nesnesi hayata gelecektir. ondan sonra türemiş sınıfın constructor'ı hayata gelecektir.

	- türemiş sınıf türünden bir nesne yapıldığında işi derleyiciye bırakma durumunda derleyici her zaman taban sınıfın constructor'ına bıracaktır.(14911'den önceki örnek)

	-  eğer base sınıfının default constructor'ı yoksa Der sınıfı türünden bir nesne oluşturulması sentaks hatası olacktır.(14911)

	- class Base{
	public:
		Base(){
		std::cout<<"Base::Base()"<< endl;
		}
		Base(int ){
		std::cout<<"Base::Base(int)"<< endl;
		}
		Base(double){
		std::cout<<"Base::Base(double)"<< endl;
		}
		Base(int, int ){
		std::cout<<"Base::Base(int, int)"<< endl;
		}
	};

	class DerA : public Base{
	//default ctor
	};
	class DerB : public Base{
		DerB() : Base(0)//int ctor
		{


		}
	};
	class DerC : public Base{
		DerC() : Base(1.)//double ctor
		{


		}
	};
	class DerD: public Base{
		DerD() : Base(1, 5)//double ctor
		{


		}
	};

	int main(){
		DerA x;// default ctor çağrıldır
		DerB x;// int param. ctor çağrıldır
		DerC x;// double param. ctor çağrıldır
		DerD x;// int, int param. ctor çağrıldır

	}

	- bir sınıf nesnesinin hayatı bittiğinde onun içindeki taban sınıfının nesnesi de hayata bitecektir.
	- önce türemiş sınıf türünden sınıfın nesnesi hayatı bitecektir. sonra taban sınıfının ki bitecektir.
	- türemiş sınıfın nesnesi destroy edildiğinde taban sınıfın alt nesnesini kullalıyor olabilir.

	- önce taban sınıf alt nesneleri sonra member'lar hayata gelecektir.
	---- copy ctor for inheritance----

	- eğer türemiş sınıf copy construct ile elde edilmiş ise derleyici taban sınıf için copy ctor'u çağırır.
	- eğer türemiş sınıfının copy ctor'ını kendimiz yazıyor isek taban sınıfının copy ctor'ını kendimiz yazmalıyız.

	- eğer türemiş sınıfın copy ctor'ı yazılıp mil sentaksı kullanılmamış ise taban sınıf için default ctor çağırılacaktır.(15090)

	- eğer türemiş sınıfın copy ctor'ı yazılıp mil sentaksı kullanılır ise taban sınıf için copy ctor çağırılacaktır.(15131)

	- eğer iki türemiş sınıfından biri hayatta ise ve biri diğerine atama yapılıyorsa türemiş sınıf için ve taban sınıf için atama operator fonksiyonu
	  çağırılacak.

	- eğer türemiş sınıfın copy assignment ctor'u yazılmış ise taban sınıf için atama işlemi tamamen programcının sorumluluğundadır.()

	- derleyici hiç bir zaman atama operator fonksiyonlarına kod eklemez.

	- derleyiciye taban nesnenin atama operator fonksiyonunu çağırma işlemini programcı yaptırmalıdır.(15180, 15214)

---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------21.01.2018 PAZAR--------------------------------------------------------------------

	- Derleyicinin ürettiği kodda hangi sınıfın fonksiyonunun çağırılacağının run time da belli olmasıdır.Derleyicinin derleme zamanında
	  hangi kodun çalışacağını bilmemesidir. runtime poliformizmi denilen özellik kabaca budur.

	- Derleyici hangi fonksiyonun çağırılacağını derleme  zamanında biliniyorsa erken yada statik bağlama, bilmiyorsa   geç ya da dinamik bağlamadır.

	- virtual anahtar sözcüğü ile geç bağlama denilen olay gerçekleşir. Fonksiyona hangi sınıf nesnesinin adresi geldiğini run time
	  da o sınıfın fonksiyonları çağırır.

	- virtual anahtar sözcüğü : bir fonksiyonun bildirimin de taban sınıf da virtual anahtar sözcüğünü ekleyerek  bunu kalıtımın ikinci kategorisini yapmış oluruz.(interface veren default implementasyon var.)

	- virtual void start(){
		//default implementasyon verilmiştir. Taban sınıfta olmalıdır.
	}

	- taban sınıfının virtual anahtar sözcüğü ile bildirilen fonksiyonlarına taban sınıfının sanal fonksiyonları denir.

	- C++'da base class'ın fonksiyonlarının kategorizasyonu şöyledir.
		class Base{
		public:
			void f1(); //1.kategori
			virtual void f2();//2. kategori. virutal function denir. ya f2'nin benim sağladığım implementasyonu kabul edeceksin. yada yazıdğımız sınıftaki fonksiyon ile bunu override edebiliriz.
			virutal void f3() = 0; //3. kategori. pure virutal function denir. Burada  override etmeye mecbur bırakıyordur.
		}

	- eğer taban sınıftaki fonksiyon sanal fonksiyon ise eğer türemiş sınıftaki aynı parametrik yapıda aynı imza ya sahip bir fonkyion bildirilirse taban sınıfın fonksiyonunu  override(ezilimş) edilmiş olur.

	- eğer taban sınıftaki sana lfonksiyondan farklı imzalı bir fonksiyon bildirirsek bu override yada function overload ile hiç bir alakası yoktur. Ama legaldir.

	- eğer imzası aynı olup geri dönüş değeri farklı bir fonksiyon bildirirsek bu sentaks hatası olur.

	- aynı imza aynı geri dönüş değeri override etmek.
	- farklı imza aynı geri dönüş değeri yeni bir fonksiyon.
	- aynı imza farklı geri dönüş değeri sentaks hatası.

	- bir taban sınıf pointer'ı yada referansı yoluyla taban sınıfın sanal bir fonksiyonu çağırıldığında sanallık mekanizması devreye girer. run time'a yönelik bir mekanizmadır.(15415)

	- sanallık mekanizmasının devreye girebilmesi için çağrının mutlaka taban sınıfın  referansı yada pointerı yoluyla yapılması gerekmektedir.(15460)

	- türemiş sınıf taban sınıfın sanal fonksiyonunu override ettiğinde ister virtual anahtar sözcüğü kullanılmış olsun ister kullanılmasın türemiş sınıfın fonkiyonu da sanaldır.

	- class Base{
	public:
		virtual void func(int);
	}

	class Der : public Base{
	public:
		virtual void func(int);//burada virtual yazılmasa bile bu fonksiyon sanal fonksiyondur.
	}

	class SDer : public Der{
	public:
		void func(int); // bu fonksiyon da Der fonksiyonun func fonksiyonunu override etmiştir.
	}

	- virtual anahtar sözcüğü türemiş sınıflar için virtual anahtar sözcüğünü yazmama eylemi daha fazladır.

	- 1. tipik hata seneryaso override edilmek istenirken yeni bir fonksiyon yazmıştır.

	- 2. tipik hata senaryosu taban sınıfta sanal olmayan bir fonksiyonunu sanal zannedip override etmeye çalışmaktır.

	- 3. tipik hata ise taban sınıfta yapılan bir imza değişikliği bütün override değişikliği yapılan fonksiyonlar düzenlenip yeniden derlenmelidir.

	- C++ 11 ile gelen override keywordu ile bu üç hataya da çözümü olmuştır.türetilmiş sınıflarda kullanılır.

	  class Car{
	  public:
		  virtual void collide(int);
	  }

	  class Mercedes : public Car{
	  public:
		  void collide(int)override;//
	  }

	 - bir taban sınıfın sanal  fonksiyonu override ediyorsak  override sözcüğünü eklemenin hatalardan kaçınmak için eklenmesi çok önemlidir .

	 - bağlamsal anahtar sözcük(context join keyword) : belirli bir bağlamda kullanıldığında keyword özelliği taşıyan sözcüklerdir.override böyle bir keyword'dur.

	 - nesne yoluyla çağrı yapıldığında sanallık mekanizması devreye girmez. Sanallık mekanizmasının özellikle devreye girmesini istemiyorsak çözünürlük operatörlüğü
	   ile sanal fonksiyonu çağrı yapmaktır(15689).

	 - Bir kalıtım hiyerarşisin de her hangi bir kademe de bir fonksiyonu override edebiliriz.

     - türemiş sınıf nesnesi taban sınıfın sanal olmayan bir üye fonksiyonu ile  sınıfın sanal olan bir üye fonksiyonunu çağırdığı zaman  türemiş sınıf nesnesinin adresi ile çağrıldığı için
	   türemiş sınıfın sanal fonksiyonunu çağırılır.Ama sınıfın sanal olmayan fonksiyonu ctor ise taban sınıfın sanal fonksiyonu çağırılır.
	   Bunun nedeni de taban sınıfın ctor'ı türetilmiş sınıftan daha önce hayata geldiğinden dolayıdır.

	 - C++'da ctor içinde yapılan sanallık mekanizmasını devreye sokacak çağrılar sanallık mekanizmasını tetiklemez. nedeni ise türemiş sınıfın nesnesi hayata gelmeden türemiş sınıf nesnesinin
	 override'ı türemiş sınıfın nesneleri hayata gelmeden  onları kullanarak rte'ye neden olacağındır.
	 - bu destructor için de geçerlidir. nedeni de türemiş sınıf nesnesinin sanal fonksiyonu taban sınıfın nesnelerini kullanabileceğinden dolayıdır. Buda rte'ye neden olur

	 - sanallık mekanizması tamamen non-satic member function'ları için geçerlidir.

	 ------Sanallık mekanizmasının devreye girmediği yerler

	 1-) Sanal işleve çağrı taban sınıf nesnesi ile yapılırsa(object sliding)
	 2-) Sanal işleve çağrı çözünürlük operatörü ile yapılırsa
	 3-) Sanal işleve çağrı taban  sınıf ctor'u  içinde yapılırsa
	 4-) Sanal işleve çağrı taban sınıf destructor'ı içinde yapılırsa

	 - ctor hariç sınıfın non-static üye fonksiyonları  sanal olabilir.

	 - hangi türden nesnenin hayata gelmesi gerektiğini run time'da belirli olması durumunda (15830)

	 - clone idiom or virtual ctor idiom: taban sınıfın bir sanal fonksiyonu ile hangi türden nesne gelirse o türden dinamik bir nesne oluşturmaktır.

	- #include <string>
	 class Car{
		std::string m_color;
		int m_age;
	public:
		Car(const std::string &color, int age): m_color{color}, m_age{age}
		{}
		virtual Car *clone() = 0; // implementasyon verilmeyecek.
		virtual void *speed()const = 0;
		void display()const
		{
			std::cout << "renk : " << m_color << std::endl;
			std::cout << "yas : " << m_age << std::endl;

		}

	 };
	class Bmw : public Car{
	public:
		Bmw(const std::string &color, int age): Car::{color, age}
		{}
		Car *clone()override
		{
			return new Bmw{*this};
		}

	 };
	class Mercedes: public Car{
	public:
		Mercedes(const std::string &color, int age): Car::{color, age}
		{}
		Car *clone()override
		{
			return new Mercedes{*this};
		}

	 };
	class Volvo: public Car{
	public:
		Volvo(const std::string &color, int age): Car::{color, age}
		{}
		Car *clone()override
		{
			return new Volvo{*this};
		}

	 };()

	- davranışa esas tür dinmaik tür,

	- bir sanal fonksiyonu sınıfın private bölümünde override etmenin herhangi bir access kontrolü içermez.(dinamik türler için)

	-  varsayılan argüman kontrolü tamamen statik türe göre yapılır.

	- access kontrolü her zaman statik türe göre yapılır.(15914)

	- typeid operatoru hem dinamik türe göre hemde statik türe göre çalışır.
	- polyformic bir tür ise dinamik türe göre değilse statik türe göre çağırılır.

	- bir türün polyformic tür olması için ya kendisinin  en az bir sanal fonksiyonu yada bir başka türden kalıtım yolu elde edilmiş bir sınıf olması gerekir.


---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------27.01.2018 CUMARTESİ--------------------------------------------------------------------

	- Bir sınıfın en az bir tane saf sanal fonksiyonu varsa, yada abstract bir sınıftan kalıtım yoluyla edecek ya da taban sınıf olarak kullanılan sınıftan en az bir abstract fonksiyonunu override etmeyecek
	  böyle sınıflara abstract class(soyut sınıf) denir. Bunlar polyformic işlemlerde kullanılırken bu sınıf türünden  nesne tanımlanamıyor.

	- statik yada global fonksiyonlar doğrudan override etmenin bir aracı yoktur.

	- operator fonksiyonunun, constructor'ın sanal olmasına sentaks izin vermez. Ama sanal constructora ihtiyaç çok fazladır.

	- destructor sanal bir fonksiyon olabilir. Ve bir kalıtım hiyerarşisinde çoğu zaman kullanılır.

	- bir sınıf türünden nesne oluşturmaya instantiate denir.

	- kalıtım da istisnasız bütün sanal fonksiyonları override etmesi gerekmektedir. Yoksa türemiş sınıf abstract sınıf olur. Sadece o türden pointer yada referans tanımlayabiliriz.

	- polymorfic olmayan sınıflarda sınıf nesnesinin sizeof'u öğelerinin sizeof'una eşittir. polymorfic sınıflarda  4 byte kadar fazladır.

	- virtual table pointer : Bir polyformic sınıf nesnesinin hangi türden olduğunu gösteren pointer'dır.

	- (carptr->vfunc());
		1-) derleyici burada ilk başta vfunc() statik tür mü değil mi kontrolü yapıyor.
		2-) sanal fonksiyonu olduğunu anlarsa bu fonksiyonun adresinden bir index elde ediyor.

	- virtual destructor : ctor sanal olamazken destructor sanal olabilir.

	- Sanallık mekanizmasının devreye girebilmesi için bir referans ya da pointer gerekmektedir.

	- elimizde bir taban sınıf pointer'ı yada referansı varsa, taban sınıf pointer'ı yada referans'ı yoluyla bir sanal fonksiyon çağırılır ise
	  sanallık mekanizması devreye girer.

	- runtime polymorphismminde türemiş sınıf nesnelerine taban sınıf pointer'ı ile manipüle ederiz.

	- Dinamik bir türemiş sınıf nesnesini taban sınıfıyla kontrol edersek sanal destroctur burada gereklidir.

	- delete operatoru ile sınıfın statik türüne ilişkin destructor çağırılır.

	- eğer  polyformic davranış gösterecek bir sınıf hiyerarşisi var ise  destructor'ını sanal yapmamız gerekir.

	- derleyici delete ifadesinde kullanılan adres taban türünden ise burada hangi sınıfın destructor'ının çağırılacağını taban sınıfın pointer yada refereansının
	  gösterdiği nesneye göre belirli olacaktır. Buda run time da belirli olur.

	- eğer destructor sanal değilse pointer'ın statik türü ne ise her zaman  o destructor'ı çağıracaktır. Eğer dinamik türün destructor'ını çağırmak istiyorsak mutlaka
	  destructor'ı sanal yapmamız gerekir.

    - eğer polyformic bir hiyerarşi gösterecek sınıf var ise destructor'ı mutlaka sanal yapılmalıdır.

	- eğer bir sınıfın destructor'ı sanal yapılmış ise dökümantasyonuna bakılmaksızın polyformic bir yapı için yazılmış bir sınıftır.

	- Bir sınıfın kalıtım için oluşturulduğunu sınıfın protected bölümünü olmasından(olmak zorunda değil), yada destructor'ın sanal olduğundan anlayabiliriz.

	-

	- taban sınıfın protected bölümünü kendi public bölümümüze using bildirimi ile katabiliriz. ama private için bu geçerli değildir.

	- final keyword : Kalıtım hiyerarşisi içinde kalıtım yolu elde edilmiş sınıftan artık yeni bir sınıfı kalıtım yolu elde etmeyeceğimiz
	  için kullanılır.

	- iki farklı kullanımı var :
		1-) sınıfın kendisini final yapmak : bu sınıftan bir daha kalıtım ile başka bir sınıf elde edilemeyeceği
		2-) sınıfın sanal fonksiyonunu final yapmak : final yapılan fonksiyonun bir daha override edilemeyeceğini gösterir.

	- sentaksı
		1-) sınıf için ---> class Der final: public Base {}();
		2-) sanal fonksiyon için ---> void func() final override;

---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------28.01.2018 PAZAR--------------------------------------------------------------------


----------- multiple inheritance -----------

	- Birden çok sınıftan kalıtım yoluyla elde edilmiş bir sınıf durumudur.

		class Base1{
		public:
			void func1();
			void foo1();
			void g1();
		}
		class Base2{
		public:
			void func2();
			void foo2();
			void g2();
		}

		class Der : public Base1, public Base2{

		};

	-  taban sınıfın private bölümü her zaman türemiş sınıflara da kapalıdır.

	-  taban sınıf alt nesneleri kalıtımda belirttiğimiz sıra ile hayata gelecektir.

	- çoklu türetmede isim arama ilk başta class türünden nesne içinde alınır. çoklu türetme de fonksiyonlar için sınıf niteleyecisini
	  kullanmalıyız.

---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------03.02.2018 CUMARTESİ--------------------------------------------------------------------

	- Normalde bir türemiş sınıf nesnesinin sadece directive base class'ını construct edebiliriz. indirect base class'ını construct etmek sentaks hatasıdır.

	- Bu durumun bir istisnası vardır.Sınıfın çoklu türetmesi ile ilgilidir. Yani sanal türetmeden kaynaklıdır.

	- Böyle bir durumda En alttaki sınıf(Yani en türemiş sınıf). En yüksekteki(türetilmenin yapıldığı ilk base class)'ı initialize etmelidir.

	- Bu durum default constructor olmadığı durumunda gerçekleşir.

	------ exception handling -------

	- run time da program çalışırken programın işini yapmasını engelleyen bazı durumların oluşmasında bu durumların ele alınmasına exception handling denir.

	- programın kaynak kodundan kaynaklanmayan, çalışma zamanında  beklenmedik bir hata  nedeniyle oluşması durumundadır.

	- hataya karar verilmesi tamamen projenin başında karar verilmelidir.

	- throw statement --> Hatayı tespit eden kodun daha yukarıdaki kodlara bir nesne hazırlayıp bunu göndermesi

	- hataya müdahele edecek kodların bu blok içinde çalışacak kodlar bir hata nesnesi gönderilirse ben hatayı yakalamaya hazırım anlamındadır.

	- eğer bir hata nesnesi gönderilip  yakalanmaz ise program'ı sonlandırılır.(C'deki abort gibi)

	- eğer programı devama zorlayacak isek bütün hata nesnelerini yakalamak zorundayız.

	- exception safe: run time da ne olursa olsun programın çalışmaya devam etmesidir.

	- C++'da exception safety'yi sağlamak çok daha zordur(C#, Java gibi dillere göre).

	- throw exp; return'e çok benzemektedir.

	- tek başına throw ile oluşturulan statement'ta vardır. throw; şeklindedir. bu özel bir durumdur.

	- throw ifadesi olarak bir nesne kullanılırsak derleyici bu nesneden bir temporary object üretir.

	- hata nesnesinin türü hatanın ne olduğu konusunda bilgi verir. örneğin her 0'a bölme hatası bir matematiksel hatadır.

	- hata nesnesinde kullanılan sınıflar ayrı bir hiyerarşisindedir.

	- throw MathError{};

	 void f4(int x){
		cout << "f4 cagrildi" << endl;
		if(x > 10)
			throw 2.3; // derleyici double'türden bir hata nesnesi oluşturup bu nesneye 2.3 ile ilk değer verecek.
		 cout << "f4 sona erdi" << endl;
	 }

	- uncaught exception : Herhangi bir hata nesnesi yakalanmaması durumudur. abort fonksiyonu çağırılacaktır.

	- Hatayı yakalamak C++ için çok önemli bir olaydır.

	 void f4(int x){
		cout << "f4 cagrildi" << endl;
		if(x > 10)
			throw out_of_range; // C++'ın
		 cout << "f4 sona erdi" << endl;
	 }

	 try block : hatayı yakalamaya aday blok
	 catch block: hatayı işleyen blok


	 void f4(int x){
		cout << "f4 cagrildi" << endl;
		if(x > 10)
			throw out_of_range; //
			cout << "f4 sona erdi" << endl;
	 }

	try {
		f4(47);
	}
	catch(int){
		//Gönderilen hata nesnesinin türü ile catch bloğunun paremetresi aynı ise buraya girecektir.

	}

	- try bloğunu zorunlu olarak minimal bir catch bloğu izlemelidir. burada catch bloğu olmaz ise sentaks hatasıdır.
	- catch bloğunun bir tane catch parametresi olmalıdır.

	void f4(int x){
		cout << "f4 cagrildi" << endl;
		if(x > 10)
			throw out_of_range; //
			cout << "f4 sona erdi" << endl;
	 }

	int main(){
		try {
			f4(47);
		}
		catch(int x ){
			cout << "hata main islevi icinde yakalandi x = " << x << endl; //throw ifadesinin değeri burada x nesnesi ile aynıdır.
		}
	}

	- Gönderilen hata nesnesinin bir catch tarafından yakalanması isteniyorsa mutlaka parametre ile nesnenin değeri aynyı olmalıdır.
	  Tek istisnası runtime polymorphismin'den dolayıdır.

	- özel bir catch bloğu vardır. Hangi türden nesne gönderilirse gönderilsin yakalanması içindir.ellipses atomu kulalnılır.(catch all)

	- syntaksı (17376)
	catch(...){

	}

	- eğer birden fazla catch bloğu var ise bunun tümevarım şeklinde yazmalıyız.(özelden genele)

	- main'in tamamını try bloğu içerisine alınması durumunda bile global nesnelerin hatasını yakalayamayız.

	- exception handling neden kullanılmaz
		1-) Gerek olmadığından dolayıdır.
		2-) O kadar kritiktir ki exception throw'a haracayacak kaynağı yoktur.
		3-) programın sadece kendi içindeki çalışan kodlara yöneliktir.asynchrn programlarda kullanılmaz.

	- Çok sayıda kullanılan kütüphanelerde kullanılır.


--- exception yakalandiğinda neler yapabiliriz ---

--- stack unwinding!!! ---
	- Exception mekanizmasının en önemli mekanizmalarından biridir.
	- stack unwinding denilen mekanizma ile hatayı gönderen kod ile hatayı işleyecek kod arasındaki bütün nesneler stack edilirler.(Yani hayatları son bulurlar)

Not : Rai object --> constructor'î ile kaynak elde edilmiş destructor'ı ile kaynaklar geri verilen nesnelerdir.

	- hata nesnesi yakalanmaz ise  nesneler'in hayatına son verilmez.

	- hata nesnesinin yakalanması durumunda catch bloğunun içine girilmeden bu nesnelerin hayatı son bulur.
	- Bu özellikle Sınıf türünden nesneler için çok önemli bir mekanizmadır.

	- C++'da dinamik nesneler için stack unwinding mekanizması  normal pointer kullanıldığı zaman devreye girmez.
	- Eğer akıllı pointer kullanılır ise stack unwinding mekanizması devreye girer.

	-


--- rethrow işlemi ---
--- constructors & exceptions ---
--- destructors & exceptions ---
--- standard exception hiyerarşisi ---
--- operator seviyesindeki exceptionlar ---

-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------04.02.2018 PAZAR--------------------------------------------------------------------

	- rehtrow etmek ile aynı hata nesnesini göndermek arasında ciddi fark vardır.
	- rethrow ettiğinde aynı dinamik tür korunurken , aynı hata nesnesini gönderirken derleyici copy constructor çağırıp geçiçi nesne üretirken
	  kendi hata nesnesini destructor edip, geçici nesneyi gönderir.

	- rethrow etmek yerine aynı nesneyi gönderirsek derleyici copy constructor ile oluşturduğu geçici nesneyi throw eder.
      tipik olarak böyle bir ihtiyaç yoktur.

---- constructors & exceptions ----

	- en fazla exception gönderme ihtiyacı olan durumlardan biri constructor'lar için geçerlidir.

	- yani bir constructor'dam exception göndermenin en fazla ihtiyacı olduğu yerdir.

	- bir constructor'ın kodunun içinden exception yolu ile çıkılırsa nesne  hayata gelemez.
	  ve hayata gelememiş nesne için kesinlikle destructor çağrılmayacaktır.

	- dinamik bir nesnenin constructor'ında exception throw edilirse nesne için  bellek alanında yer ayrıldığından dolayı bu nesne için ayrılan yer destructor çağırılmamasına rağmen
	  bu bellek bloğu geri verilecektir. Derleyici bu bellek bloğunu geri verileceğini garanti eder.(17920)

	- ama constructor'da throw edilmeden önce herhangi bir kaynak elde edilmesi gerekiyorsa bu kaynakların geri verilmesi tamamen bizim sorumluluğumuzdadır.

	- Bunları delete etmek istyorsak throw edilmeden önceden kaynakları geri verilmesi gerekmektedir.

	- Böyle durumlarda normal pointer yerine smart pointer kullanmamız bizim çok önemlidir.

	- constructor'dan exception gönderme konusunda herhangi bir tereddüte gerek yoktur.

	- function try block :  bir sınıfın member'ların gönderdiği exception'ı ona sahip olan sınıfın yakalamasının tek yolu bu şekildedir.
	- Asıl bulunma amacı member'larından biri sınıf olan ve bu memberın constructor'ında throw etmesinden dolayıdır.
	- bir fonksiyonun bütün kodunu try bloğu içine almamızı sağlar. Fonksiyonun ana bloğu ile try bloğu tamamen aynıdır.
	- void func()
	  try{


	  }
	  catch(int){

	  }

	- constructor için sentaksı ise
		Owner(int val) try : mx{val}//önemli nokta bu satırdır.
		{
		}
		catch(int x){
			cout << "hata Owner ctor içinde yakalandi...." << endl;
			throw;
		}()

---- destructors & exceptions ----

	- Destructor kesinlikle dışarıya exception göndermemelidir.
	- Destructor'ın exception gönderme ihtimali çok azdır.
	- standart kütüphane'nin hiç birinin destructor'ı exception göndermez.
	no except  keywordu : exception göndermediğini anlamına gelir.
//////////////////////////////////////////////////////////////////////////////////////////////////////////

------- R.T.T.I(run time type identification) -------

	- bir nesnenin dinamik türünün runtime da check etmeye yönelik araçlar vardır.
		1-) dynamic_cast // operator
		2-) typeid ----> //operator
		3-)

	- dynamic_cast operatoru :
		dynamic_cast<Target Type>(operand)
		dynamic_cast<Audi *>(carptr) --> Audi *'a dönüşüm yapılmış.

	- tamamen down_cast ile alakalıdır.
	-


	---- namespace ----

---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------10.02.2018 CUMARTESİ--------------------------------------------------------------------

----R.T.T.I------(run time type identification);

	- dynamic cast operatoru : programın çalışma zamanında bir down casting'in güvenli yapılıp yapılamayacağını belirtir.
	- dynamic cast operatörünün operandı mutlaka polymorfic bir türlü olmalıdır.
	- scope linkage durumunu engellemek için if 'in içinde bildirmeyi mümkün kulan durumlar vardır.Sadece lojik sorgulamalar için kullanılır.
		if(Der1 *der1ptr = dynamic_cast<Der1 *>(baseptr)
			der1ptr->f3();
	- 2017 ile birlikte if deyimine yeni bir sentaks eklediler.Yeni sentaks ile birlikte sadece lojik sorgulamalar için değil tüm durumlar için geçerli bir hal kılmasını sağlamıştır.
		if(int retval = func(); retval %5 == 0) şeklindedir.

--- dynamic_cast on reference -----
	- dynamic_cast referans üzerinden yapıldığında başarısızlık durumunda bad_cast sınıfı türünden exception gönderecektir.

-- type.id operatoru --
	- sentaksı typeid(exp) şeklindedir.

	- bu ifade derleyicinin oluşturduğu kod ile bir sınıf türünden bir nesneye referanstır..Bu sınıfın ismi type_info'dur. Bu reference const bir reference'tır. typeid(exp)-->typeinfo x; const typeinfo &r = x;

	- type_info sınıfı türünden bir nesne oluşturma imkanı yoktur.(default yada copy construcotr'ı yaktır.)

	- derleyicinin yazdığı sınıf
		class type_info{
		public:
			type_info(const type_info &) = delete;
		}

	- bu nedenle client tarafından bir nesne oluşturulma imkanı yoktur.oluşturulmanın tek yönü typeid operatörüdür.

	- typeid operatörünün sizeof ile benzer bir yanı daha vardır. Oda sizeof'daki gibi içerisine tür bilgisi verebiliriz. typeid(int) şeklinde.

	- operandı olan ifade ile gerçekleşmez. gene sizeof gibi

	- typeid'nin operandının bir polymorfic bir tür olma zorunluluğu yoktur.

	- Bu geri dönüş yazısı tamamen derleyiciye göre değişmektedir.

	- typeid de runtime'a yönelik bir fonksiyon olduğu için

	- iki sınıfın aynı sınıf hiyerarşi içinde olup olmadığını static_cast ile yapabiliriz. eğer static_cast ile dönüşüm legal ise aynı hiyerarşidir.


-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------11.02.2018 PAZAR------------------------------------------------------------------------

----- namespace -------
	- global isim alanlarıdaki birbirinden gizlemek yani çakışmasını engellemek için kullanılan bir mekanizmadır.
	- Bir kütüphanennin isimlerini taşıyan bir container'dır.

	- namespace bir keyword'dur. C++'ın standart kütüphanesi std namespace'i içindedir.

	- napespace Neco {
		// içinde değişkenin, fonksiyonun,sınıfın tanımı veya bildirimi bulunabilir.
	} sentaksı bu şekildedir. Noktalı virgül kullanılmaz. Kullanılırsa bir sentaks hatası değil null statement olur.

	- nested namespace imkanı da vardır.

	- C++'ın standart kütüphanesinde de nested namespace'i olabilir.

	- namespace bir scope'tur. yani namespace içindeki isimlerde birbirinden ayrı olmalıdır.

	- derleyici bir namespace tanımı üzerinden geçtikten sonra aynı isimden bir namespace tanımı daha görürse bunları birleştirir. Bunun nedeni birden çok başlık dosyası ekleme durumunda olur.

	- namespace içindeki isimlerin kullanımı konusunda access control diye bir şey yoktur. Yani private protected public bölümü yoktur.

	- Bir ismi bir namespace içerisinde aratmak için çözünürlük operatörü kullanılır. (Omer::x;)

	- derleyici namespace ismini de bulmaya çalışacaktır.

	- std::cout << "lorem ipsum"; eğer iostrem başlık dosyası eklenmeden aramaya çalışılırsa std namespace'ini bulamadığı için sentaks hatası verir.(bulunmadığı durumda kodun doğru çalışması standart olarak belirlenmiştir.)

	- namespace Neco {
		int x, y, z;
	}

	int main(){
		Neco::x = 12;
	}

	- namespace içindeki ismi, namespace'i nitelemeden kullanmaya yöenelik araçlar başlık dosyası içinde kullanılmamalıdır.

	- bir namespace içindeki ismi, namespace ismi ile  nitelemeden kullanmaya yönelik 3 araç vardır
		1-) using declaration
		2-) using namespace
		3-) ADL(Argument dependant lookup) veya Koenig Lookup

	- namespace Neco{
		int x = 10;
		class Myclass{

		};
	  }
	using Neco::x;
	int main(){
		x =	12 // dersek Neco namespace'i içinde kullanabiliriz.
	}

	- using Neco::x using bildirimlerinin'de scope'u vardır. yani using bildirimini bir fonksiyon içinde yaparsak scope'u sadece
	  o using bildirimini sadece fonksiyonu içinde o namespace ait ismi nitelemeden kullanabiliriz.(18748)

	- using bildirimi ile tanıtılan isin o anki yapılan yere o ismi oraya tanımlamış gibi oluruz. o isimden aynı isim ile başka bir değişken tanımlayamayız.(18772)

	- using bildirimi ile tanıtılan bir program içinde isimler farklı scope'taki isimler gene birbirini gizleyebilir.

	- using Neco::x, Neco::y gibi bir sentaks hatası yoktur.

	- birden fazla ismi isim alanına enjekte etmek istiyorsak her birini ayrı ayrı yapmalıyız.(18835)

	- namespace'ler her zaman global'dir. Namespace içindeki bildirimlerin hepsi de global alandıdır.

	- using namespace bildirimi ile using bildirimi arasında fark vardır.
		1-) bu bildirinde bir scope vardır. tıpki using bildirimindeki gibi
		2-) using namespace bildirimi isim alana enjekte etmemektedir.(18857)
		3-) Tek bir isim için değil sınıf içindeki bütün isimleri dahil ediyor.
	- namespace Neco{
	int x = 10;
	class Myclass{

		};
		}
	using namespace Neco;

	int x = 548; //geçerlidir.

	- Ama burada bir kod x'i kullandığında ambigiouty hatası verir(18857, 18876)
Not : Bazı durumlarda özellikle namespace bildirimini yapmayız.

	- using bildirimi ne kadar dar olursa her zaman daha iyidir.

----- ADL(Argumant dependant lookup)------

	- ADL eğer bir fonksiyona gönderilen argümanlardan herhangi biri bir namespace içindeki user-defined türden ise
	  bu fonksiyonun ismi normal aramanın dışında bu namespace içinde de aranacaktır.(19001)

	- std::cout << s;

	- operator<<(std::cout, s); // operator << 'i std sınıfı içinde bulur eğer ADL olmaz ise std::operator<<(std::cout, s);

	- bir isim normal olarak görülürken bir başka isim ADL ile görülür ise bu iki isim seçicilik yoktur.
	  ismin ADL ile bulunması o isim için bir ayrıcalık olmamaktadır.

		- namespace Huso {
			class Myclass(){};
			void func(Myclass &){}

		}
		void func(Huso::Myclass &){}

		int main(){
			Huso::Myclass m;
			- eğer sınıfın içindeki fonksiyon yorum satırına alınırsa derleyici global func fonksiyonuna çağırılır.
			- eğer global alandaki fonksiyon yorum satırına alınırsa derleyici Huso sınıfı içindeki func fonksiyonuna çağırılır.
			- ikiside açık olursa derleyici ambiguity hatası verir.(19030)

		}

	- farklı sınıfların using namespace bildirimi ile function overloading oluşturur.

	- user-defined türlere ilişkin giriş yada çıkış işlemlerine ilişkin fonksiyonlar o türün  başlık dosyasnda olmalıdır.

---- unnamed namespace(isimsiz isim alanı) ----
	- sentaksı
		namespace {
			int x,y;
			// buraya sınıf yada  fonksiyonlar da koyabiliriz.
		}
	şeklindedir.

	- Bunlar C'deki statik global değişkenler gibidir. Yani dışarı modüllere kapalıdır.

	- namespace'in kendi ismi de çakışma riski vardır.(çok küçük bir ihtimal)
		- dilin buna yönelik bir aracıda vardır.
		- sentaksı
			namespace Lorem = CSD_Project_ Group;(19091)
	-İsim alanlarının nested olması durumunda da bunun bir avantajı vardır.(19111)

-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------17.02.2018 CUMARTESİ------------------------------------------------------------------------

	- fonksiyon şablonlarında genel sentaks şudur.
	template <typename T>
	void Swap(T &r1, T &r2){
		T temp{r1};
		r1 = r2;
		r2 = temp;
	}
	- swap fonksiyonları için gönderilen parametrelere  göre derleyici compile time da kod üretir.

	- şablonlar üzeirnde derleyici üç farklı kontrol yapar.
		1-) Derleyici kendi şablon sentaksını kontrol eder.
		2-)
		3-)

	- template argumant deduction : derleyicinin bir template söz konusu olduğunda fonksiyon çağrısı ifadesine bakarak ,
	  fonksiyonun yazılacağı şablonun parametrelerinin ne olacağını anlama sürecidir.

	- derleyici 1. error senaryosunda template parametrenin türünü çıkarım yapamadığından dolayı hata verecektir.
		template <typename T>
		T func(){
			return 1;
		}

		int main(){
			func();//error
		}

	- derleyici şablonlarda 2. error senaryosunda ambiguoty hatası verebilir.
		template <typename T>
		void func(T x, T y){
		}
		int main(){
			func(10, 2.9);//error ambigious hatası.
		}

	- Template'ler hemen hemen her zaman başlık dosyasında bulunacaklardır.
	- template'ler iç içe template'lere çağrıda bulunabilir.
	- iki tane ayrı fonskiyon template'i olacaksa bunlar mutlaka ayrı ayrı template'ler ile belirtilmelidir.
	- template tanımınından sonra ya bir fonksiyon tanımı yada sınıf bildirimi gelir.

	- template type deduction :

	Not : template tür parametresi ile fonksiyon şablonlarının parametresi aynı olmak zorunda değildir.
		template <typename T>
		void func(T *x)
		{
		}// T int ise fonksiyon parametresinin türü int *'dır.


	- derleyici şablonun parametrik yapısının,

		1-)template <typename T>
		   void f1(T x)
		   {}

		2-)template <typename T>
		   void f2(T &x)
		   {}

		3-)template <typename T>
		   void f3(T &&x)
		   {
		   }
	 olmasında farklı farklı çıkarımlar yaparlar.

	- 1. kategoride
		template <typename T>
		void func(T x);

	- normal gönderdiğimiz argümanın türü ne ise şablonun parametresi de o türdendir.
	  func(10) // ile T'nin türü int tir.

	- eğer func'ı const bir nesne ile çağırırsak derleyici const'luğu gözardı eder.
	  const int x = 23;
	  func(x); // T'nin türü inttir.

	-  reference'ta ele alınmaz
	- adresin const olması ile nesnenin const olması arasında fark vardır. adres const ise aynen aktarılır.

	func("neco"); // T türü const char * 'dır.

	template <typename T>
	void func(T *ptr);

	int main(){
		int x = 10;
		func(&x); ptr is int * so T is int;
	}
	  int x = 10;
	  int &r = x;
	  func(r);// T'nin türü int'tir.

	- şablonlar constluk ve  reference'lığı göz ardı edilir.

	- ikisi birden olduğu durumlarda ikisi de göz ardı edilir.

---- 2. categoride -----
	template <typename T>
	void func(T &r){
	}
	int main(){
		const int x = 10;
		func(x);//T is const int, r is const int &;
	}

	template <typename T>
	void func(T &r1, T &r2)
	{

	}

	int main(){
	func("ali", "veli"); // ambigious hatası çünkü const char * olan diziler biri 4 elemanlı diziyi gösterirken biri 5 elemanlı diziyi göstermektedir.
    }

	-
	template <typname T, size_t size>
	constexpr size_t asize(T &r){
			return size;
	}

	int main(){
	int b[] = {2,3,5,6}

	}

	- 3.kategoride universal reference denir. sol taraf değeri ile çağırılırsa sol taraf referansı, sağ taraf değeri ile çağırılırsa sağ taraf referansıdır.

		template <typename T>
		void func(T &&x){

		}
	// ileride göreceğiz. Çok sık kullanılan bir özelliktir.

	- STL'de parametrik yapısı bu şekilde olan bir çok fonksiyon vardır.

	- hangi durumda hangi template'i seçeceğimiz konusunda çıkarım ne kadar kompleks olursa o seçilecektir. Konu çok karmaşıktır. Böyle öğrenmemiz yeterlidir.

	- varsayılan template tür parametresi vardır.
		template <typename T = int>
		class Myclass{
		public:
			Myclass(){
				std::cout << "type T is " << typeid(T).name() << std::endl;
			}
		}
		int main(){
		Myclass<> mx; // T is int
		}
-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------18.02.2018 PAZAR------------------------------------------------------------------------

----- class template -----

	- template <typename t>
	  class SmartPtr{

	  public:
		SmartPtr(T *p);
		T &operator*();
		T *operator->();
	  };



	- Aynı template'ten farklı türler için açılımı farklı sınıf türleridir. Yani smartptr'nin int ve double açılımı  farklı sınıf türlerindendir.
		Myclass<double> m1;
		Myclass<int> m2;
		m1 = m2 // sentaks hatasıdır.

	- Bir fonksiyon şablonu bir sınıf şablonunu tür çıkarımında kullanabilir.
		vector<list<string>> xvec;

	- Sınıf şablonlarında deduction(çıkarım) yoktur. Ama bunu fonksiyon şablonu ile sarmalayarak yapabiliriz.
		template <typename T>
		std::vector<T> gvec(T x, size_t n){
			return vector<T>(n, x);
		}()

	- deduction :  bir nesne göndererek derleyiciye hangi türden nesne olduğunu kendisinin çıkarım yapmasıdır.

	- STL'in neredeyse bütün container'larında default template argümanlarını kullanır.

	- template sentaksını yazmak zor olduğundan typedef bildirimlerini sıkça kullanırız.

	- modern c++'da typedef yerine using kullanılır.
		typedef int word;
		using word= int;

	- using ile yapılıp typedef ile yapılamayan bazı bildirimleri vardır.
		-typedef bildirimleri template olarak yapılamıyorken using bildirimleri yapılabilir.

	- template <typename T>
		using Spair std::pair<string, T>;

		int main(){
			Spair<int> x; ---> pair<string,int>//bunun typedef eşleneği yoktur.
		}
	- bir template sınıftan açılan sınıf, o template'in başka türünden açılan sınıf ile farklı türlerdir. Ve birbirine atanamazlar.
	- Ama bunlar member template olarak yazılırsa bu template'ler birbirine atabilir.

------ template'lerin özelleştirilmesi -------
	- belirli türdeki template'ler için bir template yerine başka türden bir template kullanılmasını gösterir.
	- sentaksı :
		template <typename T>
		class Myclass {
			Myclass(){}
		}
		template<>
		class Myclass<int> {
		public:
			Myclass(){}
		}
	- int türü için ikinci tür açılacakken diğer türler için

	- begin fonksiyonunda özellikle dizi adresleri için veya herhangi bir pointer açılımı için aşağıdaki pointer kullanılacaktır.
		template<typename T>
		class Myclass<T *>{
		public:
			Myclass(){}
		}

	- iki template tür parametresi aynı ise 1. template'i farklı ise 2. template'i çağıracaktır.
		template <typename T, typename U>
		class Myclass<T,U>{
		public:

		}
		template <typename T, typename U>
		class Myclass{
		public:

		}

	- normal  bir sınıfın bir template member function'ı olabilir.

	- non-type parametre --> stl'in bir iki önemli sınıfı kullanır. template'e herhangi bir tür bildirmez.

-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------24.02.2018 CUMARTESİ------------------------------------------------------------------------

	---------------------------------------------------- STL ---------------------------------------

	- Bu kütüphane veri yapıları ve algoritmalara yöneliktir. veri yapıları ve algoritmalar kod şekline getirilip standartlaştırılmıştır.
	- STL'in en temel öğeleri şunlardır.
		- Containers
		- Algorithms
		- Iterators

	- ayrıca başka öğeleride vardır.
		- adapters
		- lambdas
		- functors

----- containers -----
	- vector :
		- hangi konuda hangi container'ı seçemediğimiz zaman vector'u kullanmalıyız.Sondan ekleme işlemi sabittir.

	- list(çifte bağlı liste sınıfı)
	- deque : dinamik dizilerin dizisi. Ekleme ve silme işlemleri baştan ve sondan yapılıyorsa ve konum bilgisine erişim sabit zamanda'dır.
	- forward_list (C++11)
	- string : STL'in tüm koşullarını sağlamaktadır. aslında vector ile string tıpatıp aynıdır. String sadece yazı işlemleri için özelleştirilmiştir.
	- array(C++11)

	- Buraya kadar olan container'lara sequence container denir. Bunlarda ki ekleme silme işlemleri bir konuma göre yapılmaktadır.

	- aşağıdaki container'lara ise associative containers denir. Bunlar arka planda ikili arama ağacından başka bir şey değildir. Container'da ekleme işlemini herhangi bir
	  iterator'e göre yapamayız. Neye göre daha az maaliyet oluşrutacak sa oraya ekler.

	- set
	- multiset
	- map
	- multimap

	- set ile map arasındaki fark : set anahtar değerli tutar. Yani varmı yokmu
	- multiset :
	- map'te ise : map içinde pair içerir.pair'in first'i anahtar second'ı ise value'ye içerir.
	- multiset'te ise  : aynı key'den birden fazla olabilir.

	- geriye kalan 4 tane container, bunlar hash sınıfıdır.unordered associative containers.
		- unordered_set
		- unordered_map
		- unordered_multiset
		- unordered_multimap

	- hash sınıfları tamamen ikili arama ağaçlarına alternatiftir.
	- hashing : anahtar'ı index'e dönüştürüp direk index'e erişir.
	- hashing ikili arama aracının çok ağır kaldığı yerlerde kullanılır.

	- container'lar her zaman kopyalama semantiği ile çalışır.
	- svec.push_back(str); // örneğin burada str'nin kendisini değil bunun bir kopyasını çıkarıp onu koyarız.
	- vector'de tutulacak olan nesnenin kopyasıdır.Gerçek nesneyi biz construct ediyoruz.
	- container'lar her zaman kopyalama semantiği ile çalışır.
		- 11 ile taşıma fonksiyonları da vardır.

	- Bir nedenden dolayı öğenin kendisini tutmak istiyorsak eskiden pointer kullanırken şimdi akıllı pointer'ları kullanabiliriz.
	- container'larda reference'lar tutan bir container kavramı yoktur. onun yerine reference'ları sarmalayan bir sınıf yapabiliriz. Bu standarttır.
      reference_wrapper

	- container'dan ekleme veya silme yapmak direk olarak container'ın üye fonksiyonlarından yapılır.

--- stl'in ikinci öneli ayağı iterator'lerdir----
	- bir container'daki öğenin konumunu tutar.
	- pointer benzeri bir interface'i vardır. içerik operatörünün operandı odluğunda o konumdaki nesneye erişmesi.
	- ++ operatörünün operandı iterator'un değerini bir artırırız.
	- eğer adres'ler ardışık olmasaydı pointer'ı kullanabilirdik her zaman.

	- her container sınıfının bir begin ve end fonksiyonu vardır. Geri dönüş değeri iterator türündendir.
		iterator begin(); //container boş değilse container'da bulunan ilk öğenin konumudur.
		iterator end(); // container'ların end fonksiyonun döndürdüğü iterator bir nesneyi göstermez. son öğeden bir sonraki öğenin konumu
	- STL'de ki  container'ların range'i begin'i end fonksiyonları arasındadır. [begin,end)

--- algorithms ----
	- Fonksiyon template'leridir.
	template<typename Iter>
	void display(Iter beg, Iter end){
		while(beg != end){
			std::cout << *beg << " ";
			++beg;
		}
	}

	- Burada Iter hangi sınıf türünden ise o sınıfın !=, *, ++ operatörü overload edilmelidir. Burada iter sınıfı da iterator türündendir.
	- STL'deki algorithm başlık dosyaları böyle fonksiyonları içerir.
	- algoritmalar'ın iteratorlere göre yazılma nedeni
		1-) container'ın tamamı üzerinde işlem yapmayı engeller
		2-) iterator parametreli template, function'ların karşılıklı farklı veri yapılarını kullanmak için kullanılır(Örneğin list'ten vector'e kopyalama yapmak için).

	- template kütüphaneler kodun kendisidir

-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------25.02.2018 PAZAR------------------------------------------------------------------------

	- hem iterator hemde container interface'inin generic programlamada ortak bileşenleri ortak typedef isimleridir.
	- bir template içinde C'yi  template tür parametresi olarak kullanırken container içindeki(vector<int> içindeki int gibi)
	  bilgi yi göstermek için value_type kullanılır. Yada bu türün pointer'ını göstermek için bu türün (çözünürlük operatörü)::pointer
	  gibi kullanımlar vardır.

	- iterator döndüren bir fonksiyon şablonu yazmak istersek
		template <typename Con>


	- bütün iteratorler struct iterator denilen bir yapıdan kalıtım yolu ile elde edilmiştir.
	- Kalıtım özellikle template'ler söz konusu olduğunda base sınıfımızın, public üyeleri kalıtım yolu ile elde edilmiş der sınıfı da dahildir.
	- STL'deki kalıtımın kullanıldığı yerler tamamen statik mekanizma olarak kullanılır.
	- bir sınıf şablonundan direk olarak türetme yapamayız. Ama bir sınıf şablonu açılımından türetme yapabiliriz.

	- ortada bir iterator var ise bu iterator'un kategorisi
		- input iterator
		- output_iterator
		- forward iterator
		- bidirectional iterator
		- random access iterator



-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------03.03.2018 CUMARTESİ--------------------------------------------------------------------

---------------------------------------------------------------------------- 1. DERS ------------------------------------------------------------------


	- STL'de örnekler ile fazla zaman kaybetmemek için tnutil başlık dosyasında bazı fonksiyon şablonları yazdık.

	template<typename C, typename F>
	C &fc(C &c, size_t n,  F fn){
		//1. parametre
		//2. parametre
		//3. parametre (böyle template tür paremetreleri fonksiyon çağrı operandı olacak. )

		while(n--){
			c.insert(c.end(),fn());
		}

	- STL'deki bazı algoritmaların sonunda if son eki vardır.countif, removeif gibi
	- sonunda if son eki olan algoritmaların ortak özelliği bir işi koşula göre, koşul sağlanırsa ona göre işlemi yapacaktır.


	- predicate : bir fonksiyonun geri dönüş değeri bool ise o fonksiyona predicate denir. Yada bir sınıfın bool'a geri dönen operator()() fonksiyonunada denir.

	 template <typename InIter, typename OutIter, typename Pred>
		OutIter CopyIf(InIter beg, InIter end, OutIter destbeg, Pred fn){

		}
	}

	- functor  : fonksiyon çağrı operatörünü overload eden fonksiyonlarına  denir.

	- functor class : fonksiyon çağrı operatörünü overload etmek amacı ile kullanılan sınıflara denir.

	- lambda expressions : functor class'ları derleyiciye oluşturan ifadelerdir.

	- programlamada böyle oluşturulan içsel sınıflara closer type denir. oluşan nesneye closer object denir.

	- lampda sentaksı :
	- köşeli parentez sentaksın zorunlu öğesidir. ihtiyaç varsa içine bir şeyler konulabilir.[]
	- fonksiyonun parametre parentezi vardır. ve kullanımı zorunlu değildir.(2.parantez)--> [](){}
	- bu ifadeyi fonksiyon çağrı operatörünün operandı haline getirebiliriz. []{}()

	- derleyici lampda ifadesini CompilerGeneratedClass{} türünden bir geçici nesne oluşturur.

	- lambda'ların en fazla kullanıldığı yer algoritmalara argüman olarak geçmektir.

	-  [](int x){return x % 2 == 0} --> derleyici burada operator() operatörünün fonksiyonun return ifadesinden bool döndürdüğünü anlayıp ona göre fonksiyonu yazar.
	 [](int x){return x %2 == 0}(19) // false ifadesi döndürür.

	 auto x = [](int x ){return x % 2 == 0}(19);

	 copy_if() // algoritması yazıldı.()

	 - sınıfa istediğimiz türden bir veri elemanı koymak istiyorsak bunu [len](const string &s){return s.length() == len;});()

	 - global'ler ve static ömürlü nesneler capture etmeye gerek yoktur.

	 - eğer scope'taki tüm öğeleri capture etmek istiyorsak
		int x = 10, y = 20, z = 30;

		auto f = [=]//Buraya eşittir atomu koymak ile o local'daki bütün atomları eklemiş oluruz.(int a ){return ( a + x + y) * z;}

	- capture olan ifadeyi derleyici sınıfın veri elemanı initialize etmekte kullanmaktadır.

	- derleyicinin yazdığı lambda'lar da default olarak operatör fonksiyonları const'tur.

	- lambda'da [] içine & koyarsak bu reference capture yapmak'tır.

	- kopyalamaya kapatılmış bir sınıfta lambdalarda reference kullanılması zorunludur.

	Not : bir veri elemanı mutable olduğunda o veri elemanını const fonksiyonlar değiştirebilir.

	- yazma algoritmaları hem override modunda hem de push_back modunda çalışır.

-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------04.03.2018 PAZAR--------------------------------------------------------------------

	- Algoritmalar iterator parametreli fonksiyon olduğu için ve  bir algoritma generic template kod olduğu için exception throw edemez. bunu sadece algoritmaya çağrı yapacak kod yapabilir.
	- STL verim odaklı bir kütüphane olduğu içinde exception throw etmez. çünkü exception mekanizması tamamen runtime'a yönelik bir mekanizmadır.

	- Bir iteratoru değiştirmek için kullanılan iter fonksiyonunu yazacağız.
		template <typename Iter>
		void Advance(Iter &iter){

		}

	- random access iterator'lerde direk bir tamsayı ile toplama işlemi yapabiliriz. eğer random access değil ise de döngüsel bir yapı içerisinde iteratorun konumunu ++ operatörü ile dğeiştirebiliriz.

	- exception runtime'a yönelik bir şeydir. Yani compile time da exception diye bir şey olmaz.

	---- distance 2.iterator fonksiyonu'dur -----

	- iki iterator arasındaki farkı verir. distance(c.begin(), iter); ifadesi ile iter'in gösterdiği iterator ile container'ın begin fonksiyonunun döndürdüğü iterator arasındaki farkı verir.

	- eğer random access iterator olursa sadece bir çıkarma işlemi ile bunu bulabiliriz. iter - c.begin();

	-
	int main(){
		vector<string> svec;
		randomize();
		display(fc(svec,10,rs));
		auto riter = find(svec.rbegin(),svec.rend(),"huseyin");
		cout << *riter << endl;
	}


	- normal bir iteratoru reverse bir iterator  ile construct etmek normal şartlar altında sentaks hatasıdır. normal iteratoru construct reverse iterator ile construct etmek için reverse iteratorunun
	  base fonksiyonunu çağırabiliriz.

	- rbegin fonksiyonu ile son öğenin adresi ile end'in geri dönüş değeridir.
	- reverse iteratorunun içerik operatörü kendi konumunu değil bir önceki öğenin konumunu gösterir.
	- base fonksiyonu ise reverse iteratorunun gerçek konumunu vermektedir.()
	- base fonksiyonu dönüştürme işlemi yaparken gerçek konumu vermesi terstende düzden de aynı range'i veriyor.


	- non-modifying algorithm : range'de ki öğeleri hiç bir şekilde değiştirmeyen algoritmalardır.
	- modifying alogirthm : belirli konumdaki öğeleri değiştiren algoritmalardır.

	- removing algorithm : silme algoritmaları yaptığı iş container'daki düzeni değiştirmektir. fiilen bir silme işlemi yoktur.
	  2 3 4 6 4 3 5 2 5 6 3 container'ındaki 4'leri silme işlemi yapıldığında 2 3 6 3 5 2 5 6 3 ? ? şekline gelir.

	- remove_if algoritmasının geri dönüş değeri logic_end konumu dur. logic olarak bir silme işlemi yapılmamaktadır.

	- gerçek silme işlemi yapmak için bütün container'ların sahip olduğu erase fonksiyonuna çağrı yaparak silebiliriz.()

	svec.erase(logic_end, svec.end());

	- remove erase idiomu ile gerçek silme işlemini tek bir satırda halletmiş oluruz.

	svec.erase(remove_if(svec.begin(),svec.end(),[len](const string &str){return str.size() == len;}),svec.end());

	- container'ların erase fonksiyonları silinen öğeden bir sonraki öğenin konumunu gönderir.
	- container'ların insert fonksiyonları eklenen öğenin konumunu döndürür.

	- veri yapısındaki eşdeğer ardışık öğelerin sayısını bire indirme olayına unique işlemi denir.
	- 3 4 4 3 8 7 7 1 7 9 9 9 ------> 3 4 3 8 7 1 7 9 şekline getirmedir.

	- unique algoritmasıda silmeye yönelik bir algoritmadır.

	- bir range sort edilip unique edilirse her bir öğe unique hale getirilmiş olur.

	- STL algoritmalarının bir çoğunda predicate parametreli overload'ları vardır.

	- string bir container olduğu için herhangi bir STL işlemini de string ile yapabiliriz.

	- algoritma silme işlemini yapamaz. silme işlemini container'ın kendi üye fonksiyonu yapabilir.

	- foreach algoritması bizden bir range alıp o range'i bizim gönderdiğimiz bir functor'ı argüman olarak gönderir.

	- for_each(svec.begin(), svec.end(), [](const string &s){ s += "can"});

	- for_each ile yapmak yerine işlemlerimizi range based for loop ile  yapabiliriz.

	- transform algorithm :
		template <typename InIter, typename OutIter, typename Func>
		OutIter Transform(InIter beg, InIter end, OutIter destbeg, Func f){
			while(beg != end){
				*detbeg = f(*beg);
				++beg, ++destbeg;
			}
			return destbeg;
		}

		// bir range'i bir fonksiyona gönderip  fonksiyonun geri dçnüş değerini başka bir range'e yazarız.

	- transform(svec.begin(),svec.end(),back_inserter(lenlist), [](const string &r){return r.size();)(21949)// burada back_inserter fonksiyonunun kullanılmasının nedeni container'ın list olması olmadır.
	  list fonksiyonlarının random access iterator kullanımından dolayı back_inserter kullanılır.

	- container'ların erase fonksiyonlarının reverse iterator overload'ı yoktur.

	- rfind fonksiyonları string container'ı içindir. bütün container'lar için geçerlidir.

	- eğer bir iterator gereken yere reverse iterator atarsak error olur. Çünkü farklı iki türden sınıf nesnesini bir birine atamak sentaks hatasına yol açacaktır.

	------ ostream ve isteram iteratörleri ------

	- algoritmalar ostream iterator sınıfını kullanarak herhangi bir yere yazan algoritmayı çıkış akımına yazdırabiliriz.


	- özellikle sıralama algoritmaları çok önemlidir.


	--------------- containers -------------------

	- forward_list
	- deque
	- list
	- vector
	- string
	- array

	- bunlara sequence container denir.

	- set
	- multiset
	- map
	- multimap

	- associative container denir.

	- undordered_set
	- undordered_multiset
	- undordered_map
	- undordered_multimap

	- unordered associative container denir.

	- bir contanier'ı öğrenirken onların ilk başta veri yapısını öğrenmemiz gerekmektedir.

	- ikili arama ağacında değer arandığı silindiği zaman logaritmik karmaşıklık ile yapılır.

	-  hash_table  erişimi sabit ile logaritmik karşılıklı ile yapılır.

	- hash'leme : key'i indexe dönüştürme işlevidir.

	-

-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------10.03.2018 CUMARTESİ--------------------------------------------------------------------
	- initializer list: basit bir compiler hilesinden başka bir şey değildir. derleyici bunun karşılında const bir dizi oluşturacaktır. yani aynı türden n tane öğenin kullanılmasına izin vermektedir.
	- bir insert ekleme işlemini tek tek yapmak ile toplu halde yapmak arasında her zaman bir performans farkı vardır.

	- modern C++'ın STL'inin hep bir parçasıda initializer list'tir.

	- container sınıflarının initializer list parametreli sınıfları vardır.

	- initializer_list'in öğeleri const olarak tanımlamasak bile derleyici arka planda her zaman öğelerini const olarak kabul eder.
	- initializer_list nesneleri kopyalandığı zaman aynı öğeyi kullanacaktır. zaten aynı öğeyi kopyalacaktır.

	- initializer_list'in tek bir öğeye üstünlüğü vardır.(22324)

	- seuqlence container'lar da küme parantezi kullanmak ile normal parantezi kullanmanın constructor açısından farklılıkları vardır.
		vector<int> x(20); //burada int parametreli constructor çağırılırken
		vector<int> x{20}; // burada initializer_list parametreli constructor çağırılır.

- sınıf türündense default constructor'ı çağrılır. primitive türden ise sıfır değere çekilir--> buna value initialized nedir.(container'lar için);

	- eğer value initialized yapıldığında sınıf türleri için default constructor yoksa sentaks hatası'dır.

	- container'lar için en önemli constructor'dan biri range parametreli constructor'dır.

	- farklı sınıf türlerinden birbirine ilk değer veremeyiz. vector<int> x{5}; vector<double> y {x} sentaks hatasıdır. Bu yüzden range parametreli constructor
	  alınır.

	- vector'un bool açılımı STL'in en fazla eleştirilen noktalarından biridir.
	- bir çok programcı vector'un bool açılımnı kullanmak yerine deque'nin bool açılmını kullanır.
	- taşıma semantiği devreye girdiğinden beri container'a geri dönen fonksiyon yazmak sorun değildir.

	- STL'de forward_list'in size'ı yoktur.

	- vector, deque'nin ve string'in köşeli parentez operatörleri ve at fonksiyonları vardır.(at exception'a tabidir.)

	- eğer range based for loop'ta kopyalama istemyorsak mutlaka referans koymalıyız.

	- iterator invalidation--> bir iterator2un belirli bir işlemden sonra geçersiz hale gelmesi.

	- insert : gösterilen konumda o nesnenin olacağıdır.

	- insert konumunda eğer reallocation durumu olmaz ise önceki öğelerin iteratorunu derefererence etmesi sorun olmazken. sonrasındakiler sıkıntı olur.

	- iterator invalidation söz konusu olduğunda iterator'u dereference etmemeliyiz.

	- vector de list'te string'te ve deque'da sondan ekleme yapma vardır.
	- vector'de baştan ekleme silme
	- sequence container'larda ekleme her zaman bir konumla yapılır.

	- insert fonksiyonlarında yapılan işlem kopya nesne vector'deki yere
	- emplace functions : emplace fonksiyonları bize hiç bir kopyalama olmadan nesneyi o konumda oluşturur.


	- emplace fonksiyonlarına argüman olarak doğrudan container'ın constructor'ına doğrudan o adres için çağrı yapacaktır.Yani nesne'nin hangi adreste construct edilmesi belliyken
	  bu adresi this adresinde bir defada sınıfın constructor'ı çağırılarak nesne orada hayata gelmiştir.

	- emplace kopyalamanın ilave maaliyet yarattığı durumlarda eğer sınıfa geçeceğimiz argümanlar belli ise doğrudan nesneyi compiler'ın ayarladığı belli bir alanda construct edebilir.


	---------------------- sequence container'ların assing fonksiyonu -----------------------------------

	- range, fill ve initializer_list assign edilebilir.

	- assign fonksiyonu ile bir list'ten vector'e aynı parametreye sahip assign edilebilir. operator= fonksiyonu ile bunu yapmamız mümkün değildir.

	-

-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------11.03.2018 PAZAR------------------------------------------------------------------------

	- Aynı türden container'ları karşlılaştırma operatörü ile karşılaştırma yapabiliriz.

	- buradaki karşılaştırma lexicographical_compare ile karşılaştırabilir.

	- vector default kullanılan container sınıfıdır.

	- vector'un bool açılımı içinde bool tutan bir vector değil ayrı bir template kodudur. STL uyumlu bir container değildir.
	  bir bitsel implementasyondur.


	------------ deque container'ı---------

	- deque içinde iki ayrı dinamik dizi tutan bir veri yapısıdır.
	- üç tane temel işlemi constant time'a çeker.
	- baştan, sondan ekleme, köşeli parentez ile erişim
	- vector'un interface'ine çok benzemektedir.
	- vector'un bool açılımı yerine STL algoritmalarına uyması için deque'nin bool açılımı kullanılır.


	---------------- bağlı liste -----------------

	- list çifte bağlı liste sınıfı iken forward_list tek'te bağlı listedir.

	- bağlı liste  vector'den sonra en çok kullanılan veri yapısıdır.

	- bu veri yapısının neredeyse tek neden konumunu bildiğimiz bir öğe'ye ekleme ve silme işlemi sabit zamanda olmasıdır.

	- STL' de ki en önemli konulardan biri bir işlemi hem algoritma hem de sınıfın üye fonksiyonları aynı işlemi yapıyorsa, sınıfın üye fonksiyonlarını seçmeliyiz.

	- bağlı listeyi istesekte sort yapamayız. çünkü sort yapmak için mutlaka random access iterator gerekir.

	- bağlı liste memory overhead'i daha fazladır.

	- bidirectional iterator :
	  1-)iki yönde dolaşılabilir.
	  2-) random access iterator isteyen algoritmalarda kullanamayız.
	  3-)

	- list container'ının üye fonksiyonlarından remove logic silme yapmaz. logic silme yapan fonksiyonlar algorithm başlık dosyasına aittir.


	- list::merge function'ı --> sıralı birleştirme.
	- merge ile iki listeyi birleştirmek istiyorsak bu listeleri önceden sıralamalıyız.

-------- splice(member function) ----------

	- bir listeden diğer listeye eleman taşır.

------ forward_list -------

	- çifte bağlı liste sınıfında düğümler iki tane pointer içerdiği için elimiz de bir düğümün adresi varsa onun önceki ce sonraki öğresine erişebiliriz.

	- bir konuma ekleme yapmak demek o konumdan önceki düğümün  next'ini değiştirmeliyizdir.

	- forward_list'te bir ekleme yapmak için insert değil, insert_after fonksiyonu vardır. hangi konumu verirsek onun sonrasına verir.

	- forward_list'te başa eklemek mümkün değilken bunu before_begin adlı fonksiyon'un gösterdiği konuma ekleme yaparak kullanabiliriz.(ilist.insert_after(ilist.before_begin());)

	- iteratoru forward iteratoru'dur.;

----- standart functor sınıfları(functors) -----

	- STL'in en fazla kullanılan sınıflarından biriydi. lambda'ların gelmesi ile kullanım alanı çok azaldı.

	- plus toplama işlemi yapan şablon
	- less küçüktür işlemi yapan şablondur.
	- bunlar standart'tır.


---------associative containers------
	- set, multiset, map, multimap'tir.

--- set ---
	- sentaksı set<T, less<T>,allocator<T>>;
	- set<int> iset;//
	- set aynı değeri bir kere insert eder.yani 41, 41 te sadece bir kere eklenir.
	- multiset'te ise aynı anahtardan birden fazla koyulur.

	- set ekleme silme ve arama işlemlerini logaritmik olarak yapar.

	- strick


-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------17.03.2018 CUMARTESİ--------------------------------------------------------------------

	----- set ------
	- set ile multiset'in farkı set bir keyi bir kez bulundururken multiset aynı keyden bir den fala bulundurur.
	- multiset te ise aynı key'den birden fazla olabilir.

	- set, multiset, map, multimap container'ların hepsinin üye fonksiyonlarını çağrırız. çok özel durumlar dışında algoritmaları kullanmak çoğunlukla bizim için daha maaliyetlidir.

	- set'in ve map'in insert fonkisyonunun geri dönüş değeri pair'in iterator, ve bool değeridir. pair'in second'ı ekleme yapılmış ise true yapılamamış ise false

	  pair'in first'i ise ekleme yapılmış ise yapılan öğenin konumu ekleme yapılamamış ise de aynı key'den var olan öğenin konumu.

		 -set<int> iset{2,6,12,45};
			int x;
			cin >> x;
			cout << iset.size() << endl;
			auto p = myset.insert(x);
			// burada o konumu bir yerde daha kullanmayacaksak
			//if(myset.isert(x).second) // ilede yapılabiliriz.
			if(p.second){
			cout << "ekleme yapildi" << endl;
			cout << *p.first << endl;
			}
			else {
			cout << " ekleme yapilamadi" << endl;
			cout << *p.first << endl; // var olan öğenin konumunu döndürür.
			}
			cout << iset.size() << endl;

	- set'teki bir karşılaştırma için STL kitabı sayfa 319 'daki kriterleri sağlamalıdır.

	- set'in int açılımı derken anahtar her zaman const'tur. yani const int olarak alır.

	- set'te iterator dışında değer ile silme de vardır.
	- set'te ekleme, silme, arama logaritmik karmaşıklıktadır.

	- lower_bound verilen bir konumdan >= olan ilk konumdur.
	- upper_bound verilen bir konumdan > olan ilk konumdur.

	- lower_bound ile upper_bound'un oluşturduğu range'e equal range denir.
	- bir multiset'te sizin anahtarınıza eşit bütün değerleri gezmek istersek bunu upper_bound ve lower_bound'ı ile birer iterator olarak kullanarak onların range'ini alacağız.
	- lower_bound'ı biz equal range için istiyorsak bunu equal_range fonksiyonu vardır. bu fonksiyon iterator pair çifti döndürür.first'i lower_bound second'ı  upper bound döndürür.
	  aranan değer key olarak container'da yoksa onun equal range'i empty range olacak.

	- lower_bound upper_bound bir çok işlemde kullanılır.

	- eğer set'te karşılaştırma kriteri olarak lambda kullanacak isek lambda'nın default constructor'ı olmadığı için  set'in karşılaştırma nesnesini kopyalarak belli eden constructor'ını kullanmalıyız.
		auto f = [](int a, int b){return a < b;};
		set<int,decltype(f)> myset(f);

	----- map ------

	- map ile set'in farkı map'e insert işlemi yapılırken bunu sadece pair olarak yaparız. map'in amacı aradığımız anahtara karşı bir anahtar değil değer buluyoruz.

	- map'in köşeli parentez operatör fonksiyonu vardır.(multi-map'in değil);

		mymap[120] = "ali";
		burada map'te 120 key'i yoksa onu "ali" value'si ile birlikte oluşturacak.
		eğer 120 key'i varsa onun value'sini ali olarak değiştirecek.

	- primitive türler için default constructor yerine sıfır değeri atanır.

	- vector<string< svec;

		randomize();
		fc(svec,3000,rs);
		map<string,int> mymap;

		for(const auto &i : svec){
			++mymap[i];
		}

		// burada bir container'da kaç tane aynı türden değer olduğunu anlarız.


	-------- sıralama işlemleri -----------(STL'deki algorithm kütüphanesindeki sıralama algoritmalarıdır.)

	- uygulamada en sık kullanılan algoritmalar sort grubudur.
	- associative container'ları sort etmeye çalışmamalıyız. onların kendi içinde bir sıralama algoritmaları vardır.
	- random access iterator veren her container'ı dipslay fonksiyonu ile sıralayabiliriz.
		sort(svec.begin(),svec.end());

	- sort(svec.begin(),svec.end(),greater<int>); ile büyükten küçüğe sıralama yaparız.

	- stable_sort : işlemden önce ki izafi konumu korur.

	- partial_sort : bir vector'un belirli ilk 20 öğesini sıralayıp diğerlerini sıralamaz.

		partial_sort(svec.begin(),svec.bgin() + 5, svec.end());//burada tamamı sıralansaydı ilk 5 'i bu olacaktı anlamına gelir.
		geri dönüş değeri yoktur.


	- partial_sort_copy : sonu copy ile biten algoritmalar yapılan işlemi başka bir range'e kopyalarak yapar.


-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------18.03.2018 PAZAR------------------------------------------------------------------------

	- Hash table : arama anahtar ile yapılırken bu aramayı constant time'da yapmaktır.

	- set multiset map multimap kullanmak yerine bunların unordered olanlarını kullanabiliriz. Değerle erişme setten bile daha hızlıdır.

	- Hash table'ı en çok kullanan kodlardan biri işletim sistemidir.

	- anahtarı index'e dönüştürme işlemine hashing denir.

	- eğer hash fonksiyosunun kalitesi ne kadar yüksek ise farklı anahtarları o kadar farklı değere dönüştürmektedir.

	- collusion = anahtarın aynı değere hash edilmesi

	- yine aynı şekilde map grubu içinde key value pair tutuyor.

	- set grubu ise sadece key'e tutar.

	- burada sıra ilişkisi yoktur. yani eklenme sırasının bir önemi yoktur.

	- set fonksiyonlarının 3 tane template paremetresi vardır. bunlardan birincisi tür bilgisi ikincisi karşılaştırma functor'ı üçüncüsü de hash function'ı.

	- bizim anahtar olarak kullanacağımız değer standart kütüphanenin bildiği bir değer ise bunun hashing fonksiyonları zaten vardır.
	- bizim hash table'da tuttuğumuz türler kendi türlerimiz ise burada hashing işlemi başlar.

	- hash fonksiyonu aynı anahtarı tekrar hashlendiğinde yine aynı değeri vermesi lazım.

	- hash'in bucket count fonksiyonu kaç tane bucket  olduğunu döndürür.

	- load_factor bucket başına düşen değer.

	- max_load_factor : öyle load factor değeriki load_factor değeri bu değere eşit olduğu zaman re-hashing yapılacağıdır. max_load_factor'un 0,70-0,80 arası almalıyız.

	- bucket count artırıldığı zaman bucket içerisinde ki nesnenin teke düşmesi şansı giderek artacaktır.

	- bütün container'larda 6 tane bkarşılaştırma operatörü varken burada sadece eşit ve eşit değil operatörleri vardır.



----------------- giriş çıkış işlemleri ---------------------

	- giriş çıkış işlemlerinde sık sık taban sınıf olan ios_base sınıfının static veri elemanlarına erişeceğizdir.

	- ios_base sınıfı bir template değildir.

	- ios_base'den üretilmiş basic_ios bir template'tir.

	- basic_ios akımın karakter türüne bağlıdır. ama akımın giriş mi çıkış mı akımı olduğuna bağlı değildir. basic_ios'dan giriş akımlarını yönetmek için basic_istream (typedef ismi istream)
	 sınıfını çıkış akımlarını üretmek için basic_ostream(typedef ismi ostream) sınıfı türetilmiştir.

	- basic_istream ve basic_ostream sınıfından multiple inheritance ile basic_iostream(typedef ismi iostream'dir.) sınıfı türetilmiştir.

	- basic_istringstream sınıfı basic_istream sınıfından türetilmiş

	- formatlama ile ilgili bilgiler akım nesnesinin içinde bulunur.

	- formatlama bilgilerinin bir kısmı bool'in türündendir.

	- bool alpha iose_base'in bir static veri elemanı olup bu fonksiyon format'ı değiştirmek için kullanılır.

	- cout.flags fonksiyonun iki tane overload'ı vardır.
		- cout.flags();//get function
		- cout.flags(x);// set function


	- showbase = sayı sisteminin tabınını göstersinmi göstermesin mi
	  uppercase = sayı sistemini büyük harflerle gösterir.

	- bool'in bayrakları en tepe sınıfın const static veri elemanıdır.

	- setf ve unsetf fonksiyonları bir cout içerisindeki bütün nesneleri etkiler.

	- cout << endl; dediğimizde
		ostream &endl(ostream &os){
			return os << "\n*********************\n";
		}

	- endl bir manipülatördür.

	- bir satır atlarken birde buffer'ı flash eder.

	- cout << boolalpha << (10< 340) << noboolalpha << (10>654) << endl; //manipülatör'ü kullanacaktır.

	- iomanip ---> input output manipülatör'üdür.

		- paremetreli manipülatörler vardır.

	- yazma alanı genişliğini set eden fonksiyon cout.width(23) fonksiyonudur.

-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------17.03.2018 CUMARTESİ--------------------------------------------------------------------

	- structural-binding (C++17 derleyiciler şu an desteklemeyebilir.) :

		auto func()
		{
			return make_tuple(23,string{"akin"}, 3.4);
		}

		int main()
		{
			auto [a,b,c,d] = func();//Burada gereksiz kopyalama yoktur. Construct edilecektir.

		}

	- structural binding'in en büyük özelliği stl'in bir çok aracı ile kombine edilebilmesidir.

	- vector ivec{12,45,98,23};// C++17 ile gelmiştir. derleyici kendisi çıkarım yapmaktadır.

	- pair x{23,2.4}; // bu sadece constructor için geçerlidir.



	- reinterpret_cast elimideki bir nesne adresini başka bir nesnenin adresini dönüştürmek için kullanılır. eğer bunu static_cast ile kullanırsak bu bir error'dur.


	- int x = 12321423;

	- unsigned char *pbuf = reinterpret_cast<unsigned char *>(&x);

	- abstract datatype : nasıl implemente edildiği ilgilenmez. sadece interface'e bakılır.

       	- stl'de üç tane sınıf şablonu vardır. bunlar containerlar denir. bunlar container'ları
		stack(son giren ilk çıkar)
		queue(ilk giren ilk çıkar)
		priraty_queue(bir öncelik ilkesi vardır.kuyruğa girerken normal girer. çıkarken de bir sıra ile çıkılır.)

	- C++'da const initializer_list & diye bir şey yoktur.

	 - typename tür parametresine bağlı bir nested type kullanılırken typename kullanımı zorunludur. typename C::size_type size(){}

	 - array<int,5> x = {1,2,3,4,5}; // burada array sınıfının initializer list parametreli bir constructor'ı yapmaktadır. bunlar POD type'tır.

	 - structure ile class arasındaki fark array nesnesi gibidir.


	 - STL genel olarak extendable karakterindedir. STL'in temel öğeleri containerlar,iteratorler, algoritmalar, functor'lardır.
	 - abstract sınıflar türünden nesne oluşturamayız. ama bunlar bize interface veren komutlardır.
