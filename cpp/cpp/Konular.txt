---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------28.10.2017 Cumartesi----------------------------------------------------
	C++ 1.ders

	- C++ derleyicisi sadece kodu derlemiyor ayrýca bizim için kod da yazmaktadýr.
	- template : derleyiciye kod yazdýran bir araçdýr. Özel bir yazdýðýmýz kod ile derleyici bizim yazdýðýmýz koddan
	  faydalanarak kendisi kod yazmaktadýr. Derleyici compile time da kodu kendi yazýp sonra derlemektedir.
	
 
	 
	- sistem programlama alanýnda C++ kullanýmý vardýr. ve giderek artmaktadýr.
	
	- C++'da öniþlemci makrolarý çok nadir kullanýlýr.(Kýsýtlayýcý bir neden yoksa).
	  C' de ki #if #elseif #endif gibi komutlar kullanýlýr.
	
	- C++'da makro yerine geçen özel araçlar vardýr. 
	
	- Özellikle dinamik ömürlü nesnelerin kontrolünde kullanýlan pointerlarýn yerinde burada smart pointer denilen
	  özel sýnýf nesneleri kullanýlacaktýr. Yinede bir çok konunun anlaþýlmasý için pointer konusunun çok iyi bilinmesi
	  gerekir. C'deki temel pointer kavramlarýn hepsini tamamen iyi deðildir.
	
	- C++ generic programlama konusunda(türden baðýmsýz programlama) dünyanýn en geliþmiþ dilidir. Yani template'lerdir.
	
	- Ekrana merhaba dünya yazdýran bir C++ programý, C++'ýn bütün temel amaçlarýný kullanan bir programdýr.
	
	- C++'ýn standart baþlýk dosyalarý .h uzantýsýna sahip deðildir.
	
	- C++'da C'nin baþlýk dosyalarýný baþýna c gelerek include edilecektir. (cstdio) 
	
	- using namespace std;  //bu bildirim std namespace'i içinde ki isimlerin derleyici tarafýndan aranmasý sürecinde nitelenmeden
	  yine de o namespace de aranmasýný saðlýyor. eðer biz bu bildirimleri yapmasak cout ve endl için  derleyici arayýp bulamayacaktý.
	  çünkü namelook up sürecinde o namespace'e bakmayacaktý. Derleyicinin isimleri o namespace de aranmasý için std::cout // þeklinde
	  kullanýlmasý gerekirdi. böyle isimlere qualified name denir.
	
	- cout << "Merhaba dunya"<<endl; ile // burada ki bitsel sola kaydýrma operatörü kullanýlmýþ ama bitsel iþlemle hiç bir ilgisi yoktur.
	  Burada bu atom, operatör overlaoding kapsamýnda kullanýlmýþtýr. Bu C'de olmayan C++'da olan dilin en önemli araçlardan biridir.
	- C++'da operator overloading denilen mekanizma ile user defined türlerin operatörlerin operandý yapýlabilir. derleyici kendisine 
      bir vazife çýkarýp cout << "merhaba  dunya" ile kendisi bir fonksiyon çaðrýsýna dönüþtürecektir.(cout.operator<<("merhaba dunya"))
    
	- Burada ki cout bir sýnýf þablonundan oluþturulan bir sýnýf  türünden nesnedir. cout ostream sýnýfý türünden bir nesnenin ismidir.
	  bu nesne standart çýkýþ akýmýný kontrol eder. kendi interface'i ile onu kullanmamýzý izin veren global bir nesne.
	
	- cout ostream isimli bir sýnýf türünden (fakat ostream bir typedef ismidir. ostream basic ostream isimli þablonun char türünden açýlýmýna 
	  verilen bir typedef ismidir.)

	- inheritance, multiple inheritance, vurtial inheritance gibi temel araçlar vardýr.

	- cout << ile derleyici bunu cout'ýn ait olduðu sýnýfýn bir member functionýna(operator fonksiyonuna) çaðrý yapacaktýr.
	
	- C++'da ayrýca function overloading vardýr.
	
	- cout << "merhaba dunya" << endl;  // burada endl bir fonksiyon ismidir  ve C'deki gibi endl bir manüpilatör yani  fonksiyon adresidir. ve endl'yi
	  derleyici endl << operatörünün operandý olduðu için derleyici vazife çýkartarak baþka bir left shift fonksiyonu çaðýrýr.
	
	- o fonksiyonun parametresi de bir function pointer'dýr. ostream sýnýf nesnelerini alýp onlarý kullanan ve nesnenin kendisine
	  döndüren fonksiyonlara manipulator denir. 
    
	- bir merhaba dünya yazarken C++'ýn 14-15 farklý aracýný birleþtirerek yazmýþ oluruz.
	
	- C++'ýn zor tarafý da budur. çok sayýda araç olup fakat iþ gören kodlar bu araçlarý kombine ederek kullanýyorlar.
	
	- C++'ýn nesne yönelimli programlamaya iliþkisi class dediðimiz araçla baþlar. Bu C'Deki struct'larýn çok dah geliþmiþ halidir.

	--- C++ ile C arasýndaki temel düzeydeki farklar----

	- C++'da old style funciton definition artýk sentaks hatasýdýr.
		double func(a, b, c)
		double c;
		int a;
		long b;
		{
		}//sentaks hatasýdýr.
	
	- implicit int'te yoktur.
	
	- C derleyicilerinde fonksiyonun geri dönüþ deðeri yokken return ifadesi kullanýlmamýþsa sentaks hatasý deðil ama fonksiyon çöp
	  deðer döndürecektir.C++'da errordur.
	
	- main fonksiyonunun geri dönüþ deðerinin int olmasý zorunluluktur.
	
	- C++'da definition'da parametre deðiþkenlerine isim vermek zorunda deðiliz. C'de geçerli deðildir. declaration da ikisinde de
	  isim vermek zorunda deðilizdir.
	
	- C'de func fonksiyonunun definition'ý görülmeden func fonksiyonuna çaðrýlýrsa derleyici ismi arayýp bulamazsa implicit int olarak kabul eder.
	
	- C++'da direk errordur.
	
	- C'de int f1(); int f2(void); arasýnda fark vardýr. f1'in parametre deðiþkeni hakkýnda herhangi bir bilgi yoktur.
	  ama C++'da ikisi de ayný anlama gelir.
	
	- C++'da if parantezi içinde de bildirim yapabiliriz. C'de yoktur.
	
	- C++17 ile gelen yeni bir if deyimi vardýr. ismi if with initializer 
	
	- for(int i : a)--> bu java c# taki foreach gibidir.// range-based for loop denir. C++11 ile dile eklenmiþtir.
	
	- tür dönüþümleri C'de kontrol bakýmýndan çok gevþektir. C++'da bu kontrol çok katýdýr.
	
	- int x = 10; int *ptr = x; int y = ptr C'de yanlis ama gecerli C++'da gecersiz.
	
	
	- C++'da tür dönüþtürme iþlemleri static cast, const cast, reinterpret cast, dynmaic cast denilen opretörler ile yapýlacaktýr.(ileride iþlenecektir.)
	
	- C++'da farklý tür adresler arasýnda da tür dönüþümü yoktur. C'de bu vardýr ama legal deðildir.

	- T*'dan const T*'a dönüþüm C'de de C++'da legal ve doðrudur. const T *'dan T*'a dönüþüm C'de legal ama yanlýþ olma ihtimali yüksek(eðer programcý deðiþtirmeye çalýþmaz ise.). C++'da errordur.
	
	- C++'da void *'dan T *'a otomatik tür dönüþümü yoktur. C'de vardýr. Ama öyle kullanýmý tamamen hatalýdýr(Yani kötü koddur)
	
	- C'de const bir nesneye ilk deðer verilmesi geçerlidir ama yanlýþtýr. C++'da errordur.
	- C'de bir dizinin ifadesi constant expression olan bir ifadeyi kabul etmezken C++'da bu geçerlidir.

	- bir deðiþkeni kullanýldýðý alanýn dýþýnda tanýmlamanýn her zaman bir getirdiði riski olabilir.
	  buna scope linkage denir.
	
	- scope linkage'tan korunmak en önemli amaçlarýndan biridir. Bu yüzden C++11 ile gelen range based for loop ile C++17 ile gelen
	  if with initializer vardýr.

	
	- C++'da global const nesneler static anahtar sözcüðü kullanýlmadan baðlantýsý internal'dýr.(Yani sadece dosya içine özgüdür.)
	
	- constexpr C++'ýn yeni anahtar sözcüðüdür. const expression'dan kýsaltmadýr.

	- 
	
	- C++'da ayrýca bool türü vardýr. Bir keyword'dur. true ve false'da bir keyword olmasýna raðmen constexpr'dýr.

	- C++'da bool türünden aritmetik türlere dönüþüm, aritmetik türlerden bool türüne ve pointer'lardan bool türüne tür dönüþümü vardýr.
	
	- C++'da ki bool türü otomatik tür dönüþümü ile double türden bir deðiþkene bool türünden bir nesne atanabilir.
	
	- bool'un sizeof'u 1'dir.
	
	- karþýlaþtýrma operatörlerinin ürettiði deðerin türü int deðil bool'dýr.
	
	- boolalpha bir manüpilatör'dür.Bir formatlama gibidir. bool türden bir deðerin true yada false olduðunu sözel olarak yazdýrýr(0, 1 gibi deðildir.)
	
	- C'de karakter literallerinin türü int, C++'da CHAR'dýr.
	
	- bool'dan int'e dönüþüm olmasý bool *'dan int *'a dönüþüm olacaðý anlamýna gelmez.

	- true deðeri her zaman 1'e dönüþür.
	
	- istesek de istemesekte bool türlerde integral promotion'a tabidir.(int altý türlerin int'e yükseltilmesi.)
	
	- C++11'den önce NULL pointer yerine 0 kullanýlýyordu. 11'den sonra ise nullptr anahtar sözcüðü geldi. türü nullptr_t türünden bir constant value'dir.
	
	- nullptr sadece pointer'lara ve bool deðiþkenlere atanabilen bir deðerdir.

	- C'de enum türü int'tir.

	- nullptr nin türü nullptr_t'dir.
	
	- C'de enum'ýn underlined_type'ý int'tir. C++'da böyle bir zorunluluk yoktur.
	
	- C++ özel bir sentaks ile programcý enum türünün underlined_type'ýný belirleyebilir.(C++ 11 ile gelmiþtir.)
	
	- C++' baþka türlerden enum türlerine tür dönüþümü yoktur. ama tersi vardýr.
	
	- C++11 ile  enum class türü eklendi. syntax'ý enum class T{} þeklindedir.
	
	- C'de iç içe struct bildirimi yapýlabilir. Fakat içteki struct'ýn scope'ý ile dýþtaki struct'ýn scope'u aynýdýr.
	   Ama C++'da bunu kullanmak için bir özel bir taným gerelidir. A::B x;(90)
	- Ýlk deðer verme sentaksý çok daha farklýdýr.
	
	- C'de global deðiþkenlere ilk deðer veren ifadeler constant expression olmalýdýr.

	- C++'da böyle bir zorunluluk yoktur.
------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------04.11.2017 Cumartesi-------------------------------------------------------------------------------------

	-C++'da formatlý giriþ çýkýþ iþlemleri için sýnýf nesneleri vardýr.
		1- cout(C out)  Standart çýkýþ akýmýný kontrol eden nesnedir.(Bunlar C'deki yapýlar(struct'lar) gibidir.);
		2- cin (C in) Standart giriþ akýmýný kontrol eden nesnedir.;

		- Bunlar sýnýf nesneleridir.
	cout << "Merhaba";


	
	cout << x << "  " << dval << endl;
		- Burada kaç tane left shift var ise o kadar fonksiyon çaðýrýlýr.
	
	- operatör önceliði burada da vardýr. C'de kinin aynýsýdýr.

	- standart inputtan bir deðer cin ile alýnýr. Bunu almamýz right shift ile olur.

	- cin >> x >> y >> d;
	- Giriþ iþlemlerinde dikkat etmemiz gereken adres göndermememizdir(call by reference'dýr.)(117. satýr).

	--- REFERANS SEMATÝÐÝ---

	- C'de call by reference, pointer semantiði ile yapýlýr.
	
	- C++' ise pointer semantiðinin yaný sýra referans semantiði de  vardýr. Bu pointer'a göre daha yükseltilmiþ bir araçtýr. Burada & ve * ile uðraþýlmaz. 
	  Geri planda derleyici gene adresleri kullanýr.

	- referans adeta bir nesnenin yerine geçen isim gibidir.

	- referans semantiðinin dile eklenmesi pointer'larý olan ihtiyacý çok azaltmýþtýr (C'dekinin %20 kadarý kullanýlmaktadýr.)
	
	- C'de pointer kullandýðýmýz yerlerin çoðunda, modern C++'da çoðu yerde  referans semantiði yada smart pointer'lar  kullanýr.
	
	Not : Kurs da hoca reference isimlerine r ile verilir. (Genel olarakta kullanýlýr.).

	 
	Not :  operatörler ifade de olur. decleratörler bildirimde olur.

	- smart pointer : kendisi bir sýnýf nesnesi olup bir pointer gibi kullanýlan, pointer olmamasýna raðmen client'lerin pointer gibi kullanýldýðý sýnýf nesneleridir.

	- int &r = x;  Burada r  x'e bir referansdýr.
	
	- referans'larý initialize etmek zorunludur.(çünkü referanslar tab level const'tur. Yani int & const r);

	- r 'deki herhangi bir deðiþim x dede olur.

	- &r  tab level const'tur(167).
	
	int x = 10;

	int &r = x;

	int *ptr = &r;

	*ptr = 99; // x = 99

	++r; //++r == ++x;

	int x = 10;
	int &r1 = x;
	int &r2 = r1;
	int &r3 = r2;

	-r1, r2 ve r3 de x'i reference eder.(174)

	- bir reference oluþturacaksak ona mutlaka bir nesne ile ilk deðer vermeliyiz.

	- int x = 10;
	  int *ptr = &x;
	  int &r = *ptr;

	  ++r; // ++x ile aynýdýr.(211).

	-int a[] = {1, 4, 5, 6, 2};
     int &r = a[2];
	 ++r; a dizisinin ikinci elemanýný bir artýrma.

	- reference olarak seçilen tür ile deðiþkenin türü aynýdýr.

	- C++'da dizilere de reference alýnabilir.

	- int a[5] = {2, 4, 5, 8, 3};

	- int (&ra)[5] = a;
		ra[k] ile dizinin öðelerine eriþebiliriz.(306)
	
	- burada ra a'ya bir referanstýr.



	
	- bir reference'ýn türü ile adresini tutacaðý nesnenin türü ayný olmak zorunludur.

	- int x = 10;
	  int y = 34;
	  int *ptr = &x;
	  int *&r = ptr;

	  r = &y;

	  ++*r;// burada y'ye eriþiyoruz.(325)

	  - reference'lar en fazla call by reference yapýlýrken kullanýlýr. 

	  - C'de call by reference yapmanýn tek yolu pointer parametre'dir.

	  - C++'da 2. bir yol vardýr. referans semantiðidir. Bizim hemen hemen her zaman bunu kullanmamýz gerekir.

	  void func(int &r)
	  {
		r = 768;
	  }
	  - Burada r fonksiyon çaðýrýsýnda kullanýlan parametrenin yerine geçer.()

	  func(x) --> Bu C'de kesilinkle call by value iken C++'da bunu bilemeyiz. (Çünkü burada fonksiyona bakmamýz gerekir.)

	  - C++'da burada & operatörünü unutarak call by reference iken call by value yapabiliriz.

	  - swap fonksiyonu referans semantiði ile yazýldý(371).
	  
	  Not : referans semantiði kullanýlýrken fonksiyonun çaðrýsýndan call by value yada call by reference olup olmadýðýný bilemeyiz.
	  
	  - fonksiyonlardan g call by value iken diðerleri call by reference'dýr(406)
	  
	  - C++'da const nesnesinin hayati önemi vardýr.

	  - bir reference const olabilir. ve bu nesneyi okumaya yönelik olduðunu gösterir. nesne de deðiþiklik yapýlmaz. (443)

	  int x = 10;
	  const int &r = x; 

	  - r'yi deðiþtirmeye yol açan herhangi bir iþlem sentaks hatasý olacaktýr.(461)
		- const int x = 10;
		- int &r = x; //gecersiz. const int &r olmalýdýr. const bir nesneden int &'a dönüþüm hatadýr.
		()
		
		- const int x= 10;
		  int *ptr = &x; // gecersiz. const int *ptr olmalýdýr. const bir nesneden int *'a dönüþüm hatadýr.
		  


		  void foo (const T *ptr) ile void func(const T &r);
	
	 - parametresi referans olan bir fonksiyon da ilk sormamýz gereken amaç ne.

	 - int &const r = x; //saçma bir kullaným þeklidir. Çünkü reference'lar kendiliðinden  top levelconst'tur.

	 - const int &r = x;
	 
	 - const int x = 10;
	
	 - int &r = x; //direk hatadýr. 

    - bir reference bir R value expressiona baðlanamaz.(eðer const reference deðilse)

	- int &r = 10; //sentaks hatasýdýr.

	- const int &r = 10; sentaks hatasý deðildir.

	- void func(int &r); gibi bir fonksiyonu r value expression baðlayamayýz.
	
	- eðer yukaraýdaki fonksiyonun parametresi const int &r olursa r value expression ile çaðýrabilir.(const int &x = 10)
		1- Burada derleyici arka planda kendisi const int türünden bir nesne oluþturup bizim referansýmýza da o nesneyi gönderir.
		2- derleyicilerin böyle durumlarda oluþturduðu geçici nesne const'tur. böyle bir durumda const &'a derleyicinin oluþturduðu
		   const nesne ile atama yaparýz. 
	
	- C'de bir fonksiyonun nesnenin kendisini döndürmesi yani adres döndürmesidir. 
	

	- C'de fonksiyonlar r value expression olabilir.

	- C++'da geri dönüþ deðeri referans ise (int &func())  l value expressiondýr. Ama fonksiyonun geri dönüþ deðeri referans deðil ise  r value expression'dýr.
	  Yani func() = 10; þeklinde ifade olabilir.(590, 618)
	
	- otomatik ömürlü bir nesneye referans ile geri dönülmesi rte'dir.referans ile dönülmesi için
		1- statik ömürlü bir nesne ile
		2- dinamik bir ömürlü nesne ile
		3- client'ten aldýðý nesnenin referansý ile dönüþ yapabilir.
	
	- static ömürlü nesneler için dikkat edilmesi gereken birden çok çaðrýldýðýnda bütün nesneler en son kullanýlan nesnenin deðerine sahip olacaktýr.


	- referans semantiði ile hayatamýza giren fonksiyonlar.
		1- void func(T &r);
		2- void func(const T &r);
		3- T &foo(/*  */); T*'a dönen fonksiyon.
		4- const T &foo(/**/); const T*'a dönen fonksiyon.
	
	- nesneye referansýn kendisini ok operatörü ile kullanamayýz. 

	---Referanslar ile pointerlarýn karþýlaþtýrýlmasý
		1- pointer deðiþkene ilk deðer vermeden oluþturabilirken, refaransta ilk deðer verme zorunludur..
		
		2- bir pointer'ýn kendisi const olmak zorunda deðildir.(Kodun farklý farklý yerlerinde farklý nesneleri gösterebiliriz.). Referanslar her zaman tab level const'tur.
		
		int *const ptr = &x;
		ile int &r = x; ayný anlamdadýr. içeriði deðiþtirebiliriz ama r'yi deðiþtiremeyiz.

		3- elemanlarý pointer olan bir dizi varken elemanlarý referans olan bir dizi yok.int &ra[] = {x, y, z}; þeklinde bir sentaks yoktur.(865)

		4- C'de ve C++'da pointer to pointer aracý varken reference to reference þimdilik yok kabul ediyoruz. int &&r = x; þeklinde bir reference yok kabul ediyoruz(R value reference'ý hariç tuttuk).

		5- C'de NULL pointer semantiði int *p = NULL; þeklindedir. hiç bir nesneye baðlanmayan bir reference yoktur.
		
			-int *func() þeklinde bir fonksiyon nullptr döndürebilir.
			-int &func() referans semantiðinde böyle bir nullptr döndüern fonksiyon yoktur.(strchr fonksiyonu referans ile dönemez);
		
		- C++11 ile sað taraf referanslarý dile eklenmiþtir.(int &&r)

		- int &&r = 10; bir  L value referans deðildir. Bunlar R value references. 

		- C++11 öncesinde sadece sadece L value references vardý. C++11 ile R value references dile eklenmiþtir.

		// move semantics (taþýma semantiði)            bunlar 11 standartlarý ile dile eklenmiþtir.
		// perfect forwarding (mükemmel gönderme)


		- bir &'lý refarans'lar l value reference'dýr.
		- iki &'lý refarans'lar r value reference'dýr.

		- auto keyword --> 11 standartlarý ile gelmiþtir. Derleyici compile time da ilk deðer veren ifadenin türü ne ise o türden bir ifadenin türünü verecektir.

		- auto x = 0; da x'in türü int olur.


		- int * foo();
		  
		  auto x = foo(); x'in türü int * olur.

		- auto x örneði(967);

		- auto keywordu ile declera edilen bir deðiþkene ilk deðer vermek zorunludur.
		
		- uzun ve kompleks tür isimlerinde çok daha fazla kolaylýk saðlamýþtýr.

		- auto ile türe baðlý deðiþikliklerde sentaks hatasý olmayacaktýr.

		- modern C++'da en basit deðiþkenleri bile auto ile tanýtma eðilimi vardýr. auto x = 0;

		- ilk deðer verme de C++ da farklý sentaks yapýlarýda vardýr.
			1- int x = 10; yerine int x(10); kullanýlabilir.
			2- int &r = x; yerine int &r(x); kullanýlabilir.
			
		C++11 ile gelenler
			1- int x{ 10 };
			2- int a[]{ 1, 5, 65, 7 };
			3- int &r{ x };
			int *ptr{ &x };
		
		double dval = 5.6;
		int x{dval}; //uniform initializer ile narrowing conversion legal deðildir.
		int y(dval)  // gecerli.
		int x = dval; // gecerli.
	
	----ÝÞLEVLERÝN VARSAYILAN ARGÜMAN ALMASI---
		
		- C'de parametre deðiþkeni sayýsý ile fonksiyona gönderilen argüman sayýsýnýn birbirine eþit olmamasý sentaks hatasýdýr.
		
		- default argüman = fonksyionlar'ýn client cod belirli sayýdan eksik argüman sayýsý gönderildiðinde eksik argümanlar önceden belirlenen deðerler ile kullanýlýr.
		
		- tamamen compile time a yönelik bir mekanizmadýr. Ve client kodu yazan programcýnýn iþini kolaylaþtýran bir programdýr.
		
		- programlama domain'lerinin çoðunda böyle fonksiyonlar vardýr.
		
		- varsayýlan argüman özel durumlarý göz ardý edersek tamamen interface'e yönelik bir fonksiyon.
		
		void func(int, int, int = expr);
			- eðer biz func(25, 50) deðerleri ile çaðýrýrsak 3. parametredeki  herhangi bir expression olabilir.(1140'da örnek).
			- bir fonksiyonun bir parametresi varsayýlan argüman alýrsa onun saðýndakilerin hepsi varsayýlan eleman olmaz zorundadýr.(1182, 1220 ve );
			- func(10, , 20);// gecersiz
			- func(, , 10); // gecersiz

			- varsayýlan argüman bir reference, bir pointer da olabilir.(1278)

			int f1(int x = 10, int y = 20);

			int f2(int a, int b = f1());
		
		- varsayýlan argüman'ýn deðeri bir fonksiyonun geri dönüþ deðeri de olabilir.
		
		- varsayýlan argümanýn açýklanmasý(1301).
		
		- önceden baþka bir kütüphaneden eklenen bir fonksiyonun bir argümanýný varsayýlan argüman yapabiliriz.(1330);

		- önceden baþka bir kütüphaneden eklenen bir fonksiyonun 3. argümaný varsayýlan argüman iken ikinci parametresine bir varsayýlan argüman yapýlabilir.redeclaration yapýlarak(1360)
			- not : varsayýlan argüman'ý yeniden declare edilmez.
			- void func(int, int, int = 15);
			  void func(int, int = 20, int); //func fonksiyonu redeclara edilmiþtir. fonksiyonun yeni parametrik hali(int, int = 20, int = 15);'dir.

		- sarmalýyýcý bir fonksiyon ile 3. parametre ye gönderdiðimiz parametre ile varsayýlan argümaný ikinci parametreye atamak.

	Not : bildirimde varsayýlan argüman var ise tanýmda olmayacak. sentaks hatasý olur.
		- itoa'yý wrapper ile kendimize göre yazdýk(1417).

		- bazen varsayýlan argüman kullanýlmasýnýn nedeni sadece test amaçlý varsayýlan argüman kullanýlýp kullanýlmadýðýna bakmak içindir.(1451).
	------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	-------------------------------------------------------------05.11.2017 PAZAR-------------------------------------------------------------------------------------------------
	
	--- FUNCTION OVERLOADING(fonksiyonlarýn doðrudan yüklenmesi)---
	
	- Ayný isme sahip parametrik yapýlarý birbirinden farklý olan fonksiyonlardýr.
	- Bütün dillerde düþük seviyelerde vardýr.(C'de i1  + i2, d1 + d2).
	- Özellikle yüksek seviyeli dillerde birinci amaç programcýnýn iþini kolaylaþtýrmaktýr.
	- Bu mekanizma C'de olmamasý çok büyük bir derleyiciye sahip olmamasýndan dolayýdýr.
	- Burada derleyiciyi yoran þey fonksiyonlarý elemeden geçirmektir. Ve bu derleyici çok fazla yoracaktýr.
	
	-- function overload resolution : derleyicinin compile time da n tane ayný isimden fonksiyon varken bunlardan hangisini seçeceðidir.
		- overloaded function' a da biz overload deriz.(Yani burada overload isim olarak kullanýlýr.)
	
	- Bu mekanizma standart kütüphanenin çok sýk kullandýðý bir mekanizmadýr. Bu mekanizma kullanýcý rolündeyken çok fazla bilmemiz gerekir.
	- Burada en ufak bir yanlýþlýk programýzý direk hataya götürebilir.

	- Ortada function overloading var mýdýr, yok mudur?
	- function overloading programýn çalýþma zamanýna herhangi bir ek yük getirmez.(compile time da getirir.)
	- Derleyici compile time da fonksiyonun ne istediðini belir.
	- Çaðýrýlan fonksiyonun ne olduðunu anlaþýlmasý
		1- compile time da yapýlabilir.(static binding, early binding)
		2- run time da yapýlabilir.(dynamic binding, late binding) hangi fonksiyonun çaðrýldýðý run time da anlaþýlacaktýr. C'de böyle bir karþýlýðý yoktur.
		
	Not : rastgele sayý üreticisi run time da yapýlan bir iþlevdir.

	- runtime polifermizm  : hangi fonksiyonun çaðrýldýðýnýn run time da belli olmasýdýr.

	- ileride overloading'e benzer gibi gözüken overwriting tamamen dynamic binding ile ilgilidir.
	
	- overloading var mý yok mu ?
		- iki koþul vardýr. Bunlar saðlanmýyorsa kesinlikle overloading deðildir.
			1- isimler ayný scope da olmalýdýr.(farklý scope da bildirilen fonksiyonlar overload etmez.Global scope tan farklý scopelarda vardýr.)
			
			2- imzalarý(signature) farklý olacak.
				(fonksiyonun parametrik yapýsý dahildir. Geri dönüþ deðeri dahil deðildir. Yani kaç parametresi olduðu ve parametrelerinin türü)
				- imzalarý ve ayný zaman da geri dönüþ deðerleri de farklý ise bu overloading'dir.

	- eðer imzalarý ayný ve geri dönüþleri ayný ise bu function redeclarationdýr.
		- void func(int);
		  void func(int); //function redeclarationdýr.
		
	- void func(const int);
	  void func(int); //function redeclarationdýr. tab level constluk her zaman legaldir. low level constluk da durum farklýdýr.

	 Not : ayný fonksiyon ise derleyici ikisinin ayrý ayrý tanýmlanmasýna izin vermez.
	
	- void func(const int x); // bu çok saçma bir definition'dýr. Zaten otomatik ömürlü olduðundan dolayý deðiþip deðiþmemesi saçmadýr.
	
	- void func(int * const ptr);
	  void func(int *ptr); //redeclaration(1617)
	
	- farklý typedef isimleri overloading yapmaz. Redeclaration'dýr(1638).
	
	- imzalarý ve isimleri ayný olup geri dönüþ deðeri farklý olan fonksiyonlar errordur.Yani redecleration yapmaya çalýþmýþýz. ama farklý geri dönüþ deðerine sahip olmasýndan dolayý sentaks hatasýdýr.(1664)

	- farklý scope da ki isimler birbirini gizler.

	- refereans semantiði kesinlikle function overloadingdir.(geri dönüþ deðeri farketmez)(1687)
	
	- const overloading (eðer const'luk low level const ise function overloading olabilir.)
		- Bu bir çok yerde karþýmýza çýkacak bir yapýdýr.
	
	- void func(int &r);
	  void func(const int &r); Kesinlikle const overloading'dir.
	
	- void func(int x = 10);// varsayýlan argüman alsa da almasa da bir parametrei vardýr.
	  void func(); function overloadingdir.(1759)

	- void func(int x, int y= 10);
	  void func(int y);
	  void func(int, ...); üç tane overload vardýr.(1772)
	
	---- **** FUNCTION OVERLOAD RESOLUTION ***** ----

	- Eðer kurallarýný iyi bilmezsek beklentimiz ile bir þey yapmaya kalkarsak yanlýþ sonuçlar alabiliriz.
	
	- ortada function overloading varken ayný isimli fonksiyonlarýn çaðrýlmasýnda sentaks harasý olabilir..
	
	- C++'da en zorlayan þeylerden biri ortada sentaks hatasý verken programcýnýn hatayý bulamamasýdýr.
		1- nedeni çok fazla kural olmasýdýr.
		2- template : derleyicinin bizim için kod yazmasýdýr.
	
	- function overload resolution ya legal olarak sonuçlanacaktýr. 

	- illegal olmasý durumunda iki farklý durum vardýr.
		1- ortada n tane fonksiyon varken sizin fonksiyon çaðrýnýz hiç bir fonksiyona uygun deðildir.(no match)
		2- derleyici dilin kurallarýna göre birini seçmesini gerekirken bir seçicilik yoktur.(ambiguity : çift anlamlýlýk hatasý)
	
	- void func(int)
	  void func(int, int);
	  void func(int, double);
	
	int main(){
		func(); //soruda overload vardýr. ama no match error vardýr(1796);
	}
	 
	
	- void func(int);
	- void func(long double);

	int main(){
		func(10U);//ambigouos call to overload function 
		// eðer bunlardan biri tek baþýna bulunsaydý legal olurdu.
	}

	- eðer bir argüman bir parametre deðiþkenine aktarýlýyorsa, derleyici function overload resolution'ý üç aþamada gerçekleþtirir.
		1- derleyici ayný scope içirisindeki bütün isimleri ayný olan overload'larý listeye dahil eder.Bu süreçte imzalarýný da alýr.
		2- derleyici fonksiyon çaðrýsýndaki argüman sayýsý ile fonksiyonlarýn parametre sayýsýna denk düþmesi gerekecek ve buna göre fonksiyonlarý seçecektir.
		   (var sayýlan argüman  dahil  ve variadiclic'de dahil)Her bir argümandan her bir parametreye tür dönüþümü de uygun olmasý gerekir.(uygun fonksiyon)
		   Not : eðer 2. aþamayý geçen fonksiyon yoksa error. Bir tane fonksiyon varsa legal. eðer birden fazla varsa 3. aþamaya geçecek fonksiyon varsa derleyici
		   en uygun fonksiyon vardýr.
		3- derleyici bu aþamada argümandan parametreye geçiþte 3 farklý yöntem arayacak.
			a) conversion
				- int'ten double'a, double'dan int'e.
				- dönüþümü kaliteye göre yapýlabilir.
					1- exact match(tam uyum)olabailecek en iyi dönüþüm kategorisidir.
						-argüman olan ifadenin türü ile parametrenin türü bire bir ayný olmasýdýr.
						- standartlar aþaðýdaki durumlarýn hepsini exact match kabul eder.
							1- L value to R value transformation.(Bir fonksiyon'un parametresi bir r value expression'ken  ona L value expression göndermektir.)
							2- const conversion 
								- bir fonksiyonun parametresi const int * ise biz onu int * argümaný ile çaðýrabiliriz.(aksi durum errordur)
							3- array to pointer conversion
								- fonksiyonun parametresi int* iken fonksiyonu dizinin adresi ile çaðýrmaktýr.(1867)
							4- function to pointer conversion(1866 - 1871);
					2- promotion(terfi)
						1- integral promotion(int altý tðrlerin int'e yükseltilmesi.)
							C' deki integral promotion'larýn hepsi vardýr. Ayrýca boolean türünden int'e de vardýr.
						2- float to double promotion
							- sadece floattan double'a olan promotion'dýr.

					3- standart conversion
						- Eðer yukarýdaki durumlardan biri deðilse normal promotion'dýr.
					void func(int);
					void func(doule);

					func(13u); //errordur.(1871)

					func(1.3f); //legal 2. çaðýrýlýr(1881);

					bool türle alakalý 2. si çaðýrlacak(1890);

					Not : C++'da karakter sabitlerinin türü char'dýr.
					
					
				Not : Çok büyük iki ambiguity error ikisininde 
					1- user defined tür olmasýdýr.
					2- ikisininde standart conversion olmasý.

				Özel durumlar :
					1- void func(double);
					   void func(int *);

					   func(0); çaðrýsý nullptr'e dönüþüm olduðu için error'dur.
					
				    2- ) Not : nullptr'in kullanýmý burada özellikle gerekir.(nullptr sadece pointer'lara atanabilen bir sabittir.) nullptr'den sadece pointer türlerine dönüþüm vardýr.
					
					3- void func(int x);
					   void func(int &x);
					   //call by value'nin call by reference'a üstünlüðü yoktur.(1929);
					4- const int * türünden int * türüne otomatik dönüþüm yoktur.(1950)
						- int *, const int *'a baskýnlýðý vardýr.(1950)
						- refarans semantiðinde de const overloading vardýr. fonksiyon çaðrýsý const t & ile olursa const t& olan fonksiyon, çaðrý t& ile yapýlýrsa t& olan fonksiyon (1970)
					
					Not : tür dönüþtürme operatörü ile de istediðimiz çaðrýyý yapabiliriz. Ama C'deki tür dönüþtürme operatörlerini C++'da kullanmamamýz gerekir.(1990)

					5- varsayýlan argüman ile uyum herhangi bir þekilde dezavantaj deðildir. Soruda derleyici ambiguity hatasý verir.(c.a.h)(2010)
						- C++11 ile geren bir araç ile fonksiyon delete etmek aracý vardýr. Daha sonra görecez.
					6- Bir overload fonksiyon birden fazla parametreye sahip ise seçileblirlik kriteri
						1- bir parametre de üstünlük olacak. Ama diðer parametrelerinde de hiç birinden kötü olmayacak. Seçim gene yukarýdaki kurallara göre yapýlacak.

			b) user defined conversion (programcýnýn bir fonksiyon ile dönüþümü yapmasý)
				- C'de bir karþýlýðý yoktur.
				- normalde bir türden bir türe fonksiyon yoktur. programcý tarafýndan yazýlan bir fonksiyon ile dönüþüm gerçekleþtirir.(1838)
				- dönüþümü legal hale getiren bu fonksiyonun varlýðýdýr.

			c) variadic functions 
				- seçicilik açýsýndan en kötü durum budur.
			
		
		- C++'dan C fonksiyonu çaðýrmak bir önlem almaz isek bu bir hata olur(linker hatasý).
			- C'de derlenmiþ fonksiyon C++ derleyicisinin derlediði kodun obj isimlendirmesinden kaynaklanmaktadýr.
			- extern "C" void func_dec(par1); ile linker'ýn bunu bulmasýný saðlarýz. C++ derleyicisine bunu mutlaka göstermeliyiz.
			- extern "C" {
					void bprint(int);
					void foo(int);
					void func(int);
					void falanca(int);
			} // C' de derlenen fonksiyonlarý kullanabiliriz.

		#ifdef _cplusplus
			extern "C"{
		#endif
			baþlýk dosyasýnda ki bildirimler

		#ifdef _cplusplus
		}
		#endif

		- Baþlýk dosyasýný bunu yapmalýyýz.
	---C++'da tür dönüþtürme operatörler---

	- C'deki tür dönüþtürme operatörü kullanýmý (target type= double, int,...)operand þeklindedir.
	- C++'da amacýna baðlý olarak farklý operatörler kullanýlabilir.
	- Ve tür dönüþtürme operatörleri sözelleþtirilmiþtir.

	Not : veri kaybýnýn gönüllü yapýldýðý iþlemlerde kullanýlabilir.
		-ival = (int)dval;
		-

	not : const cast iþlemleri : const char * türünden bir türü char *'e cast etmek.

	alt seviyeli c kodlarýnda tür dönüþümü çok riskli olabilir.

	Student türünden bir nesne char *p = (char *)&s;

	- static_cast 

	- const_cast
	
	- reinterpret_cast
	-----------------------------
	- dynamic_cast(C karþýlýðý yoktur.)


	Yukarýdakiler tür dönüþtürme operatörleridir. Ve hepsinin ortak bir sentaksý vardýr.

		-static_cast<int>(expression)
			- burada <> parantez içerisine hedef tür yazýlýr.

		-static_cast ile randomize iþlevi : srand(static_cast<unsigned>(time(nullptr))); þeklinde olabilir.(2067)
		Not : unsigned ile unsigned int arasýnda herhangi bir fark yoktur.
		
		- Bu uzun diye sakýn C'deki type cast'i kullanma.

		- const_cast örneði(2116)
			char * yerine const_cast<char *>(p) þeklinde olur.
		
		- reinterpret_cast(2142)

		Not : Zorlayacak neden bir yok ise C'deki type cast operatorleri kullanma.

		const int *func();

		int main(){
			reinterpret_cast<char * >(func());//bir hatadýr.
			const_cast<char *>(reinterpret_cast<char * >(func()));
			reinterpret_cast<char *>(const_cast<int * >(func()));    (2163);
		}

		- C++'da da bir nutility.h oluþturuldu.(sl)


		Not : using namespace std; implementasyon dosyalarý içindir. Baþlýk dosyalarýnda gerek yoktur.
		--------------------------------------------------------------------------------------------------------------------------------------

	--------------------------------11.11.2017 CUMARTESÝ------------------------------------

	Not : dizi boyutunu ifade eden deðer constant expression olmalýdýr. Ve C++'da bunu derleme zamanýnda belirleyebilir.(2201) 
	- Eðer bir fonksiyonu constexpr keyword ile belirtirsek bunu compile time da derleyici deðerin kaç olduðunu bilir.(2201)
	- compile time da hesaplanabilecek bir deðer asla run time da (C++11'den sonra ) hesaplanmamýþtýr.
	- eðer const bir nesneye constant expression bir nesne ile deðer verilirse const nesne constant expression sayýlýr.
	-- constexpr keyword:
		1- const ile constexpr farklý bir keyword'dur.const int x = 10; // x burada constant expression'dýr.
													  const int x = func() // x burada constant expression deðildir.(2201)
		2- constexpr int  x = func();//geçersizdir. constexpr'ye ilk deðer verirken constant expression olmasý zorunludur.
			Not : const bir nesneye ilk deðer verilmesi zorunludur.
	
	Not : constant expression bbir ifadeye ilk deðer veren ifade constant expresion olmak zorundadýr.
	
		3- constexpr int x = exp;
			- Burada iki farklý amaç vardýr.
				1- okuyucuya bu ifadenin constant expression olduðunu belirtiriz.
				2- ve biz de bunun exp'ýnýn constexpr olup olmadýðýný biliriz.
		- bir pointer'ýn const expression olmasý için verilen nesne statik ömürlü olmalýdýr.()
		int x = 10;
		int main(){
			constexpr const int *ptr = &x;//constexpr yüzünden ptr'yi deðiþtiremeyiz. ve constexpr gereken bir ifade de kullanýlabilir.
			// const ise sadece *ptr'yi okuma amaçlý kullanacaktýr.
		}

		- bir ifadenin constexpr olup olmadýðýný anlayýp anlamamak için
			-const int x = 10;
			 int z = 10;
			 constexpr int y = x; //legaldir.
			 constexpr int w = z; //legal deðildir.
		-C++'da sabit ifadesi gereken yerler ileride template'lerde hayati önem taþýyacaktýr.
		
		int main(){
		int x = 10;
		const int *const ptr = &x 
		// constant expression gereken yerlerde ptr yi kullanamayýz.
		}

		--------------------SINIFLAR-----------------

		not : procedurel programlamada temel yazýlým birimi fonksiyonlardýr.
		- nesne yönelimli programlama da paradigma da ise bu tamamen sýnýflara ayrýþtýrýlarak yapýlmalýdýr.(ayrýþtýrmalar class'lara yöneliktir.)
		Not : C++ hem nesne yönelimli programlamaya destek vermektedir. istediðin paradigma da program yazabiliriz.
		- Sýnýflar nesne yönelimli program da temel yapýtaþýdýr.
		- C'de en yakýn karþýlýðý yapýlardýr.
		- Ama C++ daki yapýlar da birer sýnýftýr. C++'daki struct anahtar sözcüðü ile C'deki nin anlamý tamamen birbirinden farklýdýr.
		- class C++'da bir türdür.
		- class MyClass {
		
		}; Bir definition'dýr.

		- class definition client'lar bu türü kullanacaksa kesinlikle baþlýk dosyasýnda olmalýdýr(Hemen her zaman baþlýk dosyasýnda olur). diðer türlü .cpp dosyasýnda bulunur.
		- baþlýk dosyasýnýn ismi de tür ismi ile ayný olabilir.

		- class Data {
		
		};
		- typedef bildirimi olmadan da bu türün ismi Data'dýr.(Struct data gibi deðildir.)

		class Data {
		
		};

		- C'de öðesi olmayan bir yapý sentaks hatasýdýr. C++'da ise bu geçerlidir.(ileride öðreneceðiz).

		- C++'da struct'ta olsa class' da olsa ikiside class'dýr.iki farklýlýðý vardýr.(Daha sonra göreceðiz.)

		class Data {
			int mx;
			void func();
			typedef int WORD;
		};
		- bu sýnýfýn içinde tanýtým yapmak mümkündür.Bunun elemanlarýna member denir.
		- mx bu sýnýfýn bir data member'dýr.(deðer tutan eleman anlamýndadýr).
		- C++'da bir sýnýfýn içinde bildirilen fonksiyonlar vardýr.func bunlara member function denir.
		- sýnýfýn içinde bildirilen fonksiyonlar farklýdýr. Diðerleri C'deki gibi  globaldir.
		- C++'da global fonksiyonlara(global function yada free function denilir.)
		- member function ve global function arasýndaki fark sadece semantik açýdandýr.
		- typedef int WORD type member(member type)'dýr.(2300)

		- class'lar ayný zaman da bir scope'tur. 
			-C++'da class scope denilen kavram vardýr.bu scope sýnýfýn içinde bildirilen isimleri karþýlar.
		
		- C'de member function yoktur. 
		- C'de structure scope diye bir scope yoktur. C++'da class scope vardýr.

		- class scope'un olmasý namelook up'ý etkiler.

		- global fonksiyonlarda kullanýlan bir ismin class'larda aranmasý için
			1- isim nokta operatörünün sað operandý olarak kullanýlmýþsa
			2- isim ok operatörünün sað operandý olarak kullanýlmýþsa
			3- isim binary ::(scope resolution operator) operatörünün sað operandý olarak kullanýlmýþsa(2315)
		
		- ismin aranýp bulamamasý zaten errordur.
		- isim aramanýn baþarýlý olmasý ismin kullanýldýðý yerde bir sentaks hatasý olup olmayacaðý farklýdýr.
			1- . operatörünün sað operandý(binary infix bir operatördür. C ile aynýdýr.)
				x.y eðer x sýnýf türünden bir nesme ise burada y, x'in ait olduðu sýnýfta aranacak.
			2- ptr-> y eðer ptr bir sýnýf türünden adres ise burada y ismi ptr'nin ait olduðu sýnýfta aranacak.
			3- Myclass::x eðer Myclass bir sýnýfýn ismi ve  x bu sýnýfta aranacaktýr.
		
		Not : C'deki yapýlardan önemli bir farký da þudur. PUBLIC, PROTECTED, PRIVATE  kesinlike scope deðildir.
			- class scope'taki isimler bulunduktan sonra birde bu kodun bu ismi kullanma yetkisi olup olmadýðý kontrolünden geçecektir.
				- Buna access kontrol(eriþim kontrolü) denir.
			- sýnýfýn PUBLIC bölümünde eriþim konusunda derleyici herhangi bir hata vermez.
			- sýnýfýn PRIVATE bölümünde client buraya eriþemez.(can not access in PRIVATE)
			- C'deki bütün yapýlarda eriþim PUBLIC'dir.
			- Ve bunlar C'de yoktur.
			- PROTECTED C'de olmayan bir araç olan kalýtýmdýr(inheritance). client buraya da eriþemez.
			- PROTECTED kalýtým uygulandýðýnda ancak aktif olabilir.
			- Yani PROTECTED bölümü client'lara kapatýlmýþ, ama kalýtým yoluyla elde edilecek sýnýflara açýlmýþtýr.
			- C++'da bu keyword'u bölgesel olarak kullanabiliriz. Herhangi bir memberýna verilmez.

			- class'larýn genel eriþimi default olarak PRIVATE'týr. struct'larda bu PUBLIC'tir.

			class Data{
			public:
			//
			protected:
			//
			public:
			//
			}

			- burada public: ifadesinden baþlayan ifadeler public'tir.ve eðer baþka bir sözcük kullanýlmamýþ ise hepsi(2345)
			- protected: kalýtým olmadýðýnda kullanýlýr.
				class Data{
			public:
				void func();
			private:
				int mx, my;
			}(2360);

			class Data{
				int mx, my; //private 
			public:
				void func();
			}
			
			- eðer bir zorunluluk deðilse istediðimiz konvensiyonu kullanabiliriz.

			class Data{
				int mx;
			public:
				double mx;//geçersizdir. Çünkü public, private, protected scope deðildir.
			};(2382)

		
		- eriþim hatasý(2390)
		- foo'ya eriþilirken diðer fonksiyon member'a eriþim kapatýldý.(2409)


		- ilerleyen saatlerde data member'larý kendi içinde iki'ye ayýracaðýz.
			1- non-static data member
			2- static data member
	class Data{
	int mx;//non-static data member
	static int my; //static data member
	};

	- non-static data member C'deki yapý nesneleri gibidir.(fiilen sýnýf nesnesi içerisindedir.)
	not: class'lar tipik olarak bir baþlýk dosyasýndan gelecektir.
	- non-static türünden bir nesne eklemek sizeof'u direk artýracaktýr. C'deki yapýlar gibi olacaktýr.
	- statik türünden olanlar ise C'deik global nesne'ler gibidir. tek farký scope'larý file scope'tur.
	- static data member'lar (fiilen sýnýf nesnesi içerisinde deðildir).(2440)

	- class bir ismin sözlükteki tanýmý gibidir.
	- nesnelerin member'larý specific özellikleri tutar.
	- sýnýflarýn non-static veri elemanlarý sýnýf nesnesinden sýnýf nesnesine göre deðiþebilen elemanlardýr.
	- sýnýfýn static veri elemanlarý ortada object olsun yada olmasýn vardýr.
	- elemanlarýn sýnýfýn private bölümünde oluþturulmasý 
		1- öðrenme yükünü giderir.
		2- eðer bunlar kullanýlsaydý bunlarda yapýlan deðiþiklikler beni de etkileyecektir. Bu yüzden private korumasý
		bizi korumaya yönelik bir korumadýr.Yanlýþ kod yazma riski de büyük ölçüde elimine edilmiþtir.
		3- kontrolsüz bir þekilde veri elemanlarýný kullanmamýzý engeller.
	
	- Sýnýfýn private bölümünü tamamen gizleme olanaðýda vardýr.(Bunu ileride göreceðiz.)

	Not : global fonksiyonlardan member_function'a geçiþ makine kodu düzeyinde herhangi bir deðiþiklik saðlamaz.

	- Sýnýfýn non-static fonksiyonlarýnýn hepsi arka planda interface'de gözükmeyen o nesnenin adresini tutacak bir deðiþken bulunur.
	- non-static bütün fonksiyonlar kaç parametresi var ise arka tarafta bir fazlasýna sahiptir. O nesne türünden adres tutan bir pointer'dýr.

	- sýnýflar'ýn member function'larý overload edilebilir.(2486)
	- bizim fonksiyonlarýmýz çoðunluðu member_function'dýr.
	- functionoverloading vardýr. Çünkü public scope belirtmez.(2507)

	- member_function'larda  static yada non-static olabilir.
	- non-static member_func'larýn arka planda bir fazla parametresi vardýr(pointer türünden bir nesne).
	- static member_func'larýn ise görünen parametresi kadar parametresi vardýr.

	- çözünürlük operatörünün önceliði 1. öncelik seviyesindedir.
	- static member function'larýn object(instance) ile hiç bir alakasý yoktur.

	- global fonksiyonlarýn gizli bir parametre deðiþkeni yoktur.
	- global fonksiyonlar'ýn C++'da public private protected ayrýmý yoktur. Ancak C'de ki bilgilerimiz ile yapabiliriz.
	- C'de ki isim arama kurallarý C++'da da vardýr. Sadece üye fonksiyonlarý için isim arama kurallarý böyle deðildir.
	- üye fonksiyonlarýn tanýmlarý kaynak dosyasýnda olacaktýr. Bildirimi baþlýk dosyasýnda bulunur.
	- üye fonksiyonlarýn tanýmlarý kaynak dosyasýnda belirtilirken void className::func(int x, int y, int z);

	- üye fonksiyonlar için arama ilk önce blok içerisinde arayacak eðer bulamazsa class içerisinde arayacaktýr.
	- //Data.h
		class Data{
			int mx, my, mz;
		public:
			void set(int x, int y, int z);
		}
	// Data.cpp
	void Data::set(int x, int y, int z)
	{
		mx = x;
		my = y;
		mz = z;
	}
	//Burada arka planta &data1->mx = x &data1->my = y &data1->mz = z; 

	- bir ismi C++'da global name space'de aramanýn uniry :: operatörü kullanarak ::mx ile yapýlabilir.(2527)
	- eðer mx global alanda bulanamaz ise error verecektir.
	- maskeleme olsa bile her zaman maskelemeyi çözmenin bir yolu vardýr.
	- bir üye fonksiyon baþka bir üye fonksiyonu çaðýrdýðýnda ikiside non-static ise aldýðý adresi diðer fonksiyona 
	  verecektir.
	- Soru direk hatadýr. Çünkü func ismini blok içinde arayacaktýr. sonra class içinde arayacaktýr.(2622)
	- Global fonksiyon ile member fonksiyon function overload olmaz. olsa olsa birbirini gizlerler.
	- üye fonksiyon hem recursive çaðrý hemde global fonksiyona çaðrý yaptý(2647).

	- Myclass::x ismi Myclass scope'unda arayacaktýr. ::x ismi sadece global alanda arayacaktýr.
	
	- member functiona'private yasaðý yoktur.

	void Data::set(int x, int y, int z){
		mx = x;
		Data data1;
		data1.mx = 45;
	}

	- ister global nesnelerin private elemanýna, ister yerel nesnelerin private elemanýna ayný sýnýfýn member fonksiyonu ile
	eriþim geçerlidir.
	- global fonksiyonlar için redeclaration vardýr. class member function'lar için redeclaration yoktur.(2648)
	- function overload resolution daha önce yapýlmýþtýr. access control daha sonra yapýlýr.(2670)
	- derleyici böyle bir func fonksiyonu olmadýðý için hata verecektir.()
	- C++'da bir fonksiyonun tanýmý kesinlikle fonksiyonun private'mi public mi olduðunu kesinlikle bunu söylemez.
	- Bunu sadece makrolar ile yapabiliriz.
	#define PUBLIC
	#define PRIVATE
	#define PROTECTED

--------------------12.11.2017	PAZAR---------------------

- const member function
	- const member function, member function'ýn nesneyi okuma amaçlý olup olmadýðýný anlarýz.
	void func()const == (C'de)void func(const T *ptr);
	void foo() == (C'de)void func(T *ptr);


	class Date {
	public:
	void display()const;
	};
	- Date mydate; nesnemin deðerinin okuma amaçlý kullanýlmasý için mydate.display() ile bunu bilebiliriz.
	- client gözü ile baktýðýmýzda nesnenin öz nitelekleri deðiþtirilecekse eðer const olmamalýdýr.
	Not : nesne yönelimli programlama da her zaman interface implementasyondan önce gelir.
	
	- fonksiyonun const olup olmayacaðý tamamen problem domaini içerisinde ki gözlenebilir bir deðeri deðiþtiriyor ise
	  const olamaz.
	
	- ismi get olan fonksiyonlar çok özel bir durum yoksa const olmalarý çok açýktýr.
	
	- derleyici void func()const; þeklinde bir fonksiyon tanýmý görürse bunun gizli  parametresinin
		const T *ptr þeklinde olacaktýr.
	- const bir üye fonksiyonunun içinde onun non-static bir veri elemanýný set amaçlý kullanmak sentaks hatasý
	  olacaktýr.
	- const anahtar sözcüðü imzanýn bir parçasý olduðundan dolayý bildirimde de tanýmda da olmalýdýr.

	- const bir üye fonksiyonun const'luðundan dolayý non-static veri elemanýný deðiþtiremeyeceði(2732)

	- C'de const T*	'dan T*'a dönüþüm yanlýþtýr ama legaldir(Zaten lojik olarak yanlýþtýr.). C++'da error.

	- const bir sýnýf nesnesini  sýnýfýn const olmayan bir member function ile çaðýrmak geçersizdir.

	Not : T*'dan const T*'a dönüþüm yanlýþ deðildir. ne de sentaks hatasýdýr.(2799)

	void func(int *p);
	void func(const int *p);
		- böyle bir durumda kendisi const bir nesne ile çaðýrýlýr ise const olan kendisi const olmayan bir nesne ile çaðýrýlýr
		ise  const pointer olmayan çaðýrýlýr. Buna const overloading denir.
	------------------------------------------
	class Myclass{
	public:
		void func();//1
		void func()const;//2
	}
	int main()
	{
		Myclass m;
		const Mylcass cm;

		m.func(); ile 1. fonksiyon çaðýrýlýr.
		cm.func(); ile 2. fonksiyon çaðýrýlýr.
		// bu bir function overloading'dir. standart kütüphanenin bir çok yerde kullanýr.
		//ayrýca bir const overloading'dir.
	}
	------------------------------------------

	- bir non-static üye fonksiyon baþka bir non-static fonksiyonu çaðýrýrken kendi aldýðý adres'i
	çaðýrdýðý fonksiyona iletir.(2905)
	- const bir non-static üye fonksiyon içinde asla ve asla sýnýfýn const olmayan bir üye fonksiyonunu çaðýramayýz.(2925)

	- const T*'dan const T*'a dönüþüm yapýlmýþtýr.(2941).
	- Sýnýflarýn const üye fonksiyonlarý sýnýfýn baþka const üye fonksiyonlarýný çaðýrabilir.

	-class A{
	public:
		void func();
		void func()const;
	};
		
	void A::func()
	{
		func();//derleyici function overload resolution'dan dolayý recursive call'dýr.
	}(2959)

	- gene const T*'dan const T*'a dönüþüm olup recursive fonksiyon olur.(2995)

	---this keyword---
	
	- this keyword'u sadece ve sadece sýnýflar'ýn non-static member function'larý içinde kullanýlýr.
	- this keyword'u bir pointer'dýr.(this pointer denir).
	- this poniter'ý yazmadýðýmýz parametre deðiþkenini temsil eder. Yani bu non-static fonksiyon hangi nesne için çaðýrýlýrsa
	  this o nesne'nin pointer'ýdýr.
	- this ile nesnenin adresi aynýdýr.

	- eðer bir fonksiyon ben hangi nesne için çaðrýldýysam o nesneyi geri döndürmek isterse bunu return *this 
	dýþýnda yapmanýn yolu yoktur.(3104)
	- bir sýnýfýn üye fonksiyonu hangi nesne için çaðrýlmýþ ise ve nesnenin adresini istiyor 
	ise return this ile geri dönüþ yapabiliriz.
	- eðer nesnenin kendisini istiyor ise fonksiyonun geri dönüþ deðeri referens semantiði ile olup return *this olur.
	
	Not : this her zaman tab level const bir pointer'dýr.(T *const this);
	-this = nullptr bir //hata verecektir. 

	eðer sýnýf member_function'ý const member function ise void Myclass::func()const;
	
	- Yani this'in low level const olup olmayacaðý bize baðlý. tab level const olmasý ize zorunludur.

	- Bir fonksiyonun const üye fonksiyon olmasý bu fonksiyonun sýnýf nesnesini deðiþtiremeyiz.
	
	- mutable anahtar sözcüðü : sýnýfýn bir veri elemaný mutable ile tanýtýldðýnda 
	  mutable int call_cnt = 0; bu veri elemanýnýn deðiþip deðiþmemesi sýnýf nesnesinin veri elemanlarýný
	  ile ilgili deðildir. Bunun deðiþmesi sýnýf nesnelerin deðiþmesi ile alakalý deðildir.
	  böyle tanýtýlmýþ nesneleri const bir member_function ile de deðiþtirebiliriz.
		 
	-------INLINE FUNCTIONS-------

	- inline expansion(inline açýlým)
		- yazdýðýmýz kodun daha hýzlý çalýþmasý için derleyicimizin yaptýðý bir optimizasyon. Derleyici fonksiyonun
		  giriþ çýkýþ kodlarýný direk kendisi üretmesidir.
		- derleyicinin böyle bir optimizasyon yapmasý için olmazsa olmaz þeyler
		  1- çaðýrýlan fonksiyonun tanýmý ile çaðýran fonksiyonun tanýmý ayný kaynak dosyada olmak zorundadýr.
		  2- söz konusu fonksiyonun satýr sayýsý çok fazla olmamalýdýr.
		  ........
	Not : C'de inline fonksiyonlar C99 ile gelmiþtir.
		- inline int square(int x){
			return x * x;
		}
		- Derleyici fonksiyonun sadece tanýmýný görüyorsa geri dönüþ deðerini inline yapmak.

		- derleyicinin bu fonksiyonun çaðrýlmasýnýn tanýmda ya da bildirimde bir kez inline keyword'u kullanmak
		  yeterli olacaktýr.
		
		- inline expension'dan çokça faydalanmak istiyorsak kodu kýsa olup sýkça çaðýrýlan fonksiyonlar tercih
		  edilmelidir.
	
	- C++'da sýnýflarýn üye fonksiyonlarýnýn da inline function olabilir.
	- C++'da inline function'larýn tanýmýnýn yeri kesinlikle baþlýk dosyasýdýr.
	
	- C++'da baþlýk dosyasýnda 3 önemli istisna dýþýnda kod olmaz. Bildirimler olur.
		1- inline functions
		2- function templates
		3- constexpr functions
	
	//date.h
	class Date {
		int md, mm, my;
	public:
		int getMonthDay()const{
			return md;
		};
	};

	- C++'da bir fonksiyonun implementasyonunu class içinde yapmak fonksiyonun inline function olmasýný saðlar.
	
	- fonksiyonun inline olup olmamasý fonksiyon çaðrý semantiðinde bir deðiþim göstermez.

	- sýnýf içinde inline olarak açýlmamasý  isim arama kurallarýnda bir deðiþiklik yapmayacaktýr.(3238)

	- derleyici fonksiyonun kodunu görmemesi durumda derleyicinin bir vazife çýkartýp inline yapmasý mümkün deðildir.

	Not : kodu yazarken optimize etmek hiç iyi bir fikir deðildir.

	- data member
	member functions
		const member functions
		const overloading
	access control 
	mutable keyword
	this keyword
	constexpr
	inline functions
	-- konularý iþlendi


	SPECIAL MEMBER FUNCTIONS
	(ÖZEL ÜYE ÝÞLEVLERÝ)
	
	constructor
		default constructor
	destructor
	copy constructor
		copy assignment function

	C++11 ile gelen
	move constructor
	move assignment functions

	 - dynamic objects
	 - new / delete operators

	- bir nesnenin bellekteki yerini edinebilmesi baþka, o nesnenin  iþini görebilecek olabilmesi olmasý baþka bir olaydýr.

	- constructor -->özel bir member function'dýr.
	- bir sýnýf nesnesini hayata getiren iþlev sýnýfýn kurucu iþlevidir(constructor).(3284)
	- bir sýnýf nesnesi constructor kodunun run time da çalýþmasý bittikten sonra hayata gelmiþ kabul edilir.(3286)
	- constructor çalýþmadan bir bellek alaný olabilir. ama hayata geldiði söylenemez.
	- constructor  sýnýfýn ismi ile ayný isimli iþlevdir.
	- derleyici constructor olduðunu bu isimden dolayý anlar.
	- constructor geri dönüþ deðeri kavramýna sahip olmayan iþlevlerdir.(geri dönüiþ deðeri diye bir kavram yoktur.)
	  Yani burada geri dönüþ deðeri yerine bir þey yazmayacaz.
		---------------------------------------------------------
		class Fighter{
		public:
			Figter();//constructor. zaten implicit int diye bir þey yoktur
		}

		----------------------------------------------------------

	- C++'da constructor sýnýfýn static iþlevi olamaz. non-static member_function olmak zorundadýr.
	- constructor sýnýfýn const member_function'ý olamaz.
	- kurucu iþlevler herhangi bir parametrik yapýda olabilirler.
	- constructor sýnýfýn diðer member_function'larý gibi overload edilebilirler.
		class Data{
		public:
			Data(int);
			Data(double);	
			Data(const char *);	
			
		};

	- bir sýnýfýn constructor'larý sýnýfýn public private, protected iþlevleri olabilirler.(Ancak çok büyük çoðunlukla public olacaklardýr.)
	- sýnýflarýn constructorlar nokta yada ok operatörleri ile çaðýrýlamazlar.

	- bir sýnýfýn
		a) parametresi olmayan
		b) parametresi olan ancak tüm parametreleri varsayýlan argüman alan constructor'larýna
		varsayýlan constructor(default constructor) dýr.

	-Argüman gönderilmeden çaðýrýlabilecek kurucu iþlevler
Not : özel fonksiyon 
	- eðer bir sýnýf için programcý bir constructor yazmamýþ ise derleyici söz konusu sýnýf için 
		a)non-static
		b)public
		c)inline bir constructor kodu yazar.

	Not : Ortada hayata gelmiþ bir nesne var ise mutlaka constructor çaðrýlmýþtýr.

	- Not : bir çok programlama dilinde yerel yada global sýnýf nesnesi yoktur.
	- sýnýf nesneleri de otomatik, statik ve dinamik ömürlü olabilir.

	- Dil de önce statik ömürlü nesneler hayata gelip ondan sonra main çaðrýlýr.
	Test için g'ye bir constructor ekleyebiliriz.(3337)
	- tanýmlanma sýrasý ile consrtructor'ýn çaðrýlmasý arasýnda garanti bir iliþki vardýr.
	- önce çaðrýlan nesnenin constructor'ý daha önce yapýalcaktýr.
	- otomatik ömürlü yerel sýnýf nesneleri için constructor programýn akýþý oraya her girdiðin de tekrar çaðrýlacaktýr.(3388,3442, 3463)
	- statik yerel nesnelerde durum biraz daha farklýdýr. burada bir kez çaðrýldýktan sonra bir daha constructor çaðrýlmayacaktýr.

	--------------------------------------------------------------------------------------------------------------

	---------------------------18.11.2017 CUMARTESÝ-----------------------------

	- main.c dosyasýnýn olduðu dosyanýn ismi main.c yada driver.c adý verilir.

	- Not : mecbur olmadýkça global nesne kullanmayýn.
	- Farklý modüller(kaynak dosyalar) de tanýmlanmýþ statik ömürlü sýnýf nesnelerinin hayata gelme sýrasýna iliþkin dilin kurallarýnýn 
	  bir belirleyiciliði yoktur.
	
	Not : Program daha baþlar baþlamaz run time da çökerse bunun nedeni global nesneler ile alakalýdýr.
	
	Not : C++ gibi bir dil için dizi'ler alt seviyeli kalmaktadýr. Kullanýlmasýnda herhangi bir sentaks hatasý
		  olmayacaktýr. Ama kullanýlmamasý daha çok tercih edilebilir.
		1- ya vektör veri yapýlarýný kullanýrýz.(dinamik bellek yönteminden dolayý fazlaca maaliyeti olabilir.)
		2- yada array isimli bir sýnýf()
	
	- header file'da asla using name space kullanýlmamalýdýr.
	
	- pointer deðiþken tanýmlamak bir sýnýf türünden nesne yaratmak anlamýnda deðildir.
	  pointer deðiþken ile constructor çaðrýlmaz.
	
	- referans semantiðinde de ayný durum geçerlidir.(3707)

	- default constructor
		- parametresi olmayan yada her bir parametresi var sayýlan argüman olacak.
	- eðer default constructor kullanýlmayýp nesne çaðrýlýr ise derleyici sentaks hatasý verir.

	- uniform initilazier Myclass m1{} ; ile nesneyi default constructor ile hayata gelecektir.
	
	int x = 10;
	int y(20);
	int z{30};

	- uniform initializer ile veri kaybý olan(double'dan int'e) bir atama yapýlmasý sentaks hatasýdýr.

	--- destructor---

	- bir nesnenin hayatý bittiðinde çaðrýlýr. 
	- ismi sýnýfýn ismi ile aynýdýr. constructor ile karýþtýrýlmamasý için ismin baþýna ~ karakteri alýr.
	- parametresi olamaz. sýnýfýn destructor'ý parametresi olmayan bir iþlev olmak zorundadýr.
	- varsayýlan argümanýda olamaz.
	- overload edilemez. Yani bir sýnýfýn yalnýz ve yalnýz tek bir destructor iþlevi olabilir.
	- sýnýfýn non-static üye iþlevi olmak zorundadýr.(static üye iþlevi olamaz.)
	- public/protected/private olabilir.
	- const member function olamaz.

	- ismi ile çaðrýlmasý sentaks hatasý deðildir.(ileride inceleyeceðimiz tek bir durum dýþýnda ismi
	  ile destructor iþlevini çaðýrmayýn).
	**- destructor özel bir üye iþlevdir.(1.si default constructor'týr. yani bir sýnýfýn destructor'ý olmak zorundadýr).
	    programcý yazmaz ise derleyici ilgili sýnýf için 
		1-) non-static
		2-) public
		3-) inline
		bir destructor yazar.
	
	- sýnýflarýn çoðunluðu için destructor yazmamýz gerekmektedir. Ama destructor için bu her zaman geçerli deðildir.
	  Bu sadece sýnýf nesnesinin hayatý bitiþinde destructor'ý yazmamýz gereken en az bir neden olmasý gerekmektedir.
	
	- resource acquisition is initialization(RAII)(Kaynak edinimi ilk deðer verme yoluyla olur.)
		- bazý sýnýf nesneleri iþlerini görebilmek için bazý kaynaklar kullanýr.
		- Bu kaynaklarý constructor nesneye verirken destructor geri verecektir.
	
	- Kodunun bizim belirleyeceðimiz bir destructor RAII için kullanýlýr.
	Not : bu fonksiyonlar'ýn kodunun hiç birinin inline olma zorunluluðu yoktur.

	- global sýnýf nesneleri main çaðrýlmadan hayata gelip main bittikten sonra hayatý sona erecektir.
	- yerel nesnelerde main çaðrýldýktan sonra constructor ve main bitmeden destructor çaðýrýlacaktýr.(3934)
	- fonksiyon birden fazla çaðrýldýðýnda da ayný iþlem olacaktýr.(3970, 4010)
	- static yerel nesnelerde ise main bittikten sonra destructor çaðýrýlacaktýr.(4070);

	Not : static yerel nesnelerde ise constructor ve destructor bir ekz çaðýrýlacaktýr.
	
	- eðer hayatta 2 sýnýf nesnesi varsa constructor'ý daha sonra çaðýrýlan nesnenin destructor'ý daha önce çaðrýlýr.(4134)

	--- Dinamik ömürlü nesneler---

	- istediðimiz zaman hayata getirip istediðimiz zaman hayatýný sonlandýrabileceðimiz nesnelerdir.
	- Nesnenin hayatýnýn bitmesi de tamamen bizim sorumluluðumuzdadýr.(resource leap'le alakalýdýr.)
	- otomatik ömürlü ve statik ömürlü nesnelerin storage'ýný compiler elde edilir.

	- kaynak olarak kullanýlacak bellek alaný resource denir.
	- örneðin necati ergin stringini gönderdiðimiz bir fonksiyonda necati ergin resource da tutulacaktýr.

	- otomatik ömürlü, statik ömürlü bir nesne için onun storage'ý compiler karþýlar.
	- dinamik ömürlü nesnelerin storage'ý default olarak dinamik bellek yönetimi ile elde edilir.
	ama zorunlu deðildir.

	- Dinamik sýnýf nesneleri nasýl oluþturulur.
		- C++ dilinde dinamik ömürlü nesneler operatör kullanýmý ile hayata getirilip
		yine operatör kullanýmý ile bunlarýn hayatý sonlandýrýlýr.(4280)
		- Burada hayata getirmek için kullanýlan operatörler new operatörleri'dir.(Birden fazla new operatörü vardýr.)
		- nesne'nin hayatýný sonlandýrmak için delete operatörleri kullanýlýr.

	- derleyici new operatörünün kullanýmýnda 
	
	- operator new bir fonksiyondur.(malloc benzeri bir fonksiyondur. neredeyse aynýsýdýr.)

	- void *operator new(size_t n);
		operator new(n);
		
		new Fighter //ile aþaðýdaki iþlem arkada gerçekleþir.
		(static_cast<Fighter *>(operator new(sizeof(Fighter))))->Fighter();//sadece görünüm amaçlýdýr.
	- new ifadesi ile yeni bir nesne oluþturulduðunda 
		 - operator new ile sizeof(size_t); n ile yer ayýrýp.
		 - daha sonra onun için constructor'ý çaðýracaktýr.
		 - eðer ilave bir araç oluþturmazsak pointer  kullanmak zorundayýzdýr.
	Not:  C++'da void * otomatik olarak baþka bir türe cast edemeyiz.

	- new Figter 'ýn ifadesinin türü Fighter * türünden'dir.
	Figter *p = new Fighter;(4296)
	
	- Yeni bir C++ kodunda Fighter *p = new Fighter; yerine smart pointer kullanýlacaktýr.	
	- //Fighter *p'ye raw(çið, ham) pointer denir.
	
	auto p = new Fighter; þeklinde kullanarak çok Fighter * ile uðraþýlmamýþ olur.
	- Fighter *p1 = new Fighter;
	- Fighter *p2(new Fighter);
	- Fighter *p3{new Fighter};

	- Fighter *p4 = new Fighter();
	- Fighter *p5 = new Fighter{};
	// her birinde auto kullanabiliriz.
	- Fighter &f = *new Fighter; //þeklinde kullanabiliriz.
	- Bu sentaks açýsýndan legal olsa da özel durumlar dýþýnda kullanmamalýyýz.

	----------------------------------------------------------------------------------

	----------------------------------19.11.2017 PAZAR--------------------------------

	- Not : Bir nesne ile iþimiz bittiðinde o nesne'nin hayatý bitirilmelidir.

	- nesnenin hayatý bitirilirken gene operatör kullanýlýr.
	- constructor bir takým kaynaklar elde ettiðini düþünürsek , bu kaynaklarýn verilmemesi ile baþýmýza sorun açýlabilir.
	- bu kaynaklarýn geri verilmesi kullanýcý açýsýndan sadece dinamik ömürlü nesneler için geçerlidir. otomatik ömürlü ve statik ömürlü 
	  nesneler için derleyici destructor'ý kendi çaðýracaktýr.
	
	- nesneleri hayatýný bitirirken delete operatörü kullanýlýr.(operandý adres olmalýdýr.)
	- delete operand olan adresin destrector'u çaðrýlmaktadýr. Destructor burada kullanýlan kaynaklarý geri vermektedir. resource leap.
	- nesne'nin hayatý bitmiþtir. Ama nesne'nin kapladýðý storage'ýn geri verilmesi içinde operator delete fonksiyonu nu çaðýrýr. operator delete(p);
	- derleyici new Fighter dediðinde operator new'i çaðýrýp oradan aldýðý adresi this olarak kullanýp operator new ile storage elde eder.
	- new operator'u overload edilemez. olsa olsa, operator new function'ýný overload elde edebiliriz.
	- böylece bellek alaný elde edilme iþlemi bizim istediðimiz þekilde gerçekleþir.
	- C++'da operator bir keyword'dur.
	Not : C'de anahtar sözcük olmayan bir isim kullanýrsak bu C++'da operator, new gibi anahtar sözcüklerinden dolayý hata verecektir.
	- operator keyword'u, operator fonksiyonu dediðimiz fonksiyonlarýn kullanýlmasýnda kullanýlýr.
	- ismi operator keyword'u ile baþlayan fonksiyonlar'a operator function olarak kullanýlýr. ve operator overload eder.
	- cout << x; ile operator overload denilen mekanizma vardýr.
	- operator new ile malloc da ayný iþlevi görmektedir.
	- opearator delete == free fonksiyonu ayný amaçý verir.
	- operator new ile elde edilen bellek bloðunu geri vermek için operator delete kullanýlacaktýr.
	- dinamik olmayan bir nesneyi delete etmek runtime hatasýdýr.
	- destructor içinde ki this, constructor içindeki this ve aldýðýmýz dinamik nesne ayný adrese sahip olacaktýr.(4764)
	- eðer constructor'ýn parametreleri var ise dinamik nesneler için 
		1-) auto p1 = new Fighter(45);
		2-) auto p2 = new Fighter{56};
		3-) auto p3 = new Fighter{2.3} //yazarsak ve constructor paramteresi int olursa uniform initializer'da tür dönüþümü olmayacaðýndan dolayý sentaks hatasý verecektir. 
		
----- M.I.L(member initializer list yada constructor initializer list) sentaksý---
	
	- constructor'larýn sýnýf nesnesinin non-static member'larýn bunlara ik deðer verme için kullandýðýmýz sentaksa denir.
	  (Bir sýnýf nesnesi hayata geldiðinde onun non-static member'larýda hayata gelmektedir. )
	- MIL kullanmak olunda zorunda olduðumuz bir sentaks deðildir.
	- MIL Sentaksý sadece constructor için tanýnan bir haktýr.
	- static data member'larýn constructor'la herhangi bir alakasý yoktur. onlar sýnýf nesnesi olmadan hatta main çaðrýlmadan önce vardýrlar.
	class Data {
		int mx, my;

	public:
		Data();
		void display()const;
	}
	//data.cpp'de
		Data::Data() : mx(10), my(20)
		{
			std::cout << "Data::Data()" << std:: endl;
		}
		Data::display()
		{
			std::cout << "mx = " << mx << std::endl;
			std::cout << "my = " << my << std::endl;
		}(4862);
	- constructor'ýn parametre'li hali olabilir.(4902)
	
	- constuctor'ýn ana bloðunun için de de atama yapýlabilir. ama bu initializer deðildir. 
	  bu assignment'týr. Ve arada çok fazla fark yoktur. Ama böyle yazmayýn.
	
	- Her zaman MIL sentaksý ile non-static veri elemanlarýna aksi bir durum olmadýkça ilk deðer verin.

	- Data::Data(int x, int y) : mx(x) ile burada constructor'ýn ana bloðuna girilmeden ilk deðer verme gerçekleþir.
	{
		
	}
	- C++'da önce öðeler hayata gelmesi gerekir. daha sonra constructor'larýn ana bloðuna girecektir.
	- Bazý varlýklara ilk deðer vermemek sentaks hatasýdýr.
		1- reference'lar
		2- const'lar.
		3- sýnýfýn elemanlarý'nýn reference olmasý durumunda (Ve burada MIL sentaksýnýn kullanýmýnda da zorunluluk vardýr.)
	
	- ayný durum sýnýfýn non-static data member'ý const olmasý durumunda da geçerlidir.
		

		1-) eðer sýnýfýn non-static veri elemaný reference yada const ise ilk deðer verme zorunludur.
		2-) kalýtým(daha sonra girilecektir.)
		3-) composition(daha sonra girilecektir.)
	
	- constuctor'ý yaptýracaðý tek iþ ilk deðer verme olsa bile fonksiyonun ana bloðu olmak zorundadýr.(Boþ olsa bile)
	 Date(int d, int m, int y) : mday(d), mmon(m), myear(y){}  

Not : mümkün olduðu kadar az baþlýk dosyasý include edilmelidir.
	- C++ 11 ile birlikte uniform MIL'i uniform initializer ile de kullanabiliriz.

    - Bütün deðerlere ilk deðer verme gibi bir zorunluluðumuz yokken const veya reference olanlarýn hepsine vermek zorundayýz.

	- MIL'deki ögelerin sýrasýnýn hayata gelip gelmemesi ile herhangi bir ilgisi yoktur. class'ýn içinde nasýl decleration edildiyse öðeler öyle hayata gelecektir.
	- Bunu bizi ilgilendiren tek kýsmý birbirini kullanan veri elemanlarý için geçerlidir. Bunlarýn hayata gelmesi  MIL sentaksýnda ki sýra deðil
	  her zaman bildirim de ki sýradýr.Genel de bildirim de ki sýra ile MIL sentaksýnda ki sýranýn ayný olmasý önerilir.(4968)
	
Not : C'deki size_t neyse C++'da bu çok daha fazla vardýr.
	- runtime hatasý. (4994)
	- runtime hatasý olmadan kod yeniden yazýldý(5044).

	- struct Data {
		int mx = 12;
		int my;
	}

	- C++11'den sonra böyle bir ilk deðer verme kuralý vardýr. Var sayýlan argüman olarak almýþtýr.
	- Bununla derleyiciye ona constructor'ý yazdýrýp mx'e MIL ile deðer verildiðini var say deriz.
	- Derleyicinin yazdýðý default constructor'a bundan baþka bir vatsayýlan argüman ile deðer verdiremeyiz.
	- int mx{20}; kullanýmý da vardýr.
	- //inclass initializer C++11 (5095)

	---- COPY CONSTRUCTOR ----
	
	- eðer bir nesne hayata deðerini kendisi ile ayný türden bir nesneden alarak hayata geliyorsa hayata gelen nesne için copy constructor kullanýlýr.
	- bu durumun bir kaç farklý senaryosu vardýr.
		1-) T x = y; T x(y); T x{y}; // Burada hayata gelen x için 3 durumda da  copy constructor çaðýrýlacaktýr.
		2-) void func(int x); // call by value fonksiyon çaðrýsýnda da kullanýlýr.  
		3-) Fighter func(){
			return f;
		}//Bir fonksiyonun geri dönüþ deðeri T türünden ise de copy constructor çaðýrýlýr.
		
	- copy constructor 3. special function'dýr. Yani ya olacak ya da olacaktýr. Derleyici copy constructor kodunu kendi yazacaktýr.
	- Eðer programcý bir sýnýf için copy constructor yazmaz ise derleyici ilgili sýnýf için
		1-) non-static
		2-) public
		3-) inline bir copy constructor yazar.
	
	- copy constructor'ýn parametresi const &(reference) olmalýdýr.
	- Derleyicinin yazdýðý ismi Fighter olan sýnýf için derleyicinin yazacaðý copy constructor'ýn parametrik yapýsý þu þekildedir.
		- class Fighter{
			int mx, my, mz;
			public:
				Fighter(const Fighter &r) : mx{r.mx}, my{r.my}, mz{r.mz}
				{}
		}//bütün non-static veri elemanlarýnýn parametresi çekilen nesne'nin non-static veri elemanlarý ile karþlýklý eþleþmesi gerekecektir.
	
	- Eðer derleyicinin yazacaðý copy constructor iþimize gelmiyorsa copy constructor'ý kendimiz yazmamýz gerekecektir.
	- Bir çok sýnýf için copy constructor'ýn derleyici tarafýndan yazýlmasý iþimize gelecektir.
	- derleyici n  tane constructor içinde copy constructor olduðunu parametresinden anlar	.
	  Myclass sýnýfýnýn Myclass isimli constructor'ýnýn parametrik yapýsý Myclass(const Myclass &r); þeklinde ise direk copy constructor diyebiliriz.
	- Sýnýfýn copy constructor'ý yazýlmýþ ise mutlaka default constructor'ý yazýlmalýdýr. 
		1-)T x = y için copy constructor gösterildi(5151)
		2-)void func(T x) için copy constructor çaðýrýldý(5189)
		3-) T func(); için copy constructor yazýldý.()

	------------------------------------------------------------------------------------------------------------------------------------------------
	---------------------------25.11.2017 CUMARTESÝ----------------------------
	
	- vexing parse : programcý bir fonksiyon çaðýrdýðýnýzý zannederken dildeki anlamý bir fonksiyon bildirimidir. Böyle problemlere denir.
	- copy constructor bir nesne hayata gelirken deðerini kendisi gibi ayný türden bir  nesneden alýrken çaðýrýlýr.
	  1-) açýk ilk deðer verme sentaksý ile
	  2-) call by value fonksiyon çaðrýlarýnda. Fonksiyonun parametresi bir sýnýf türünden. Argüman olan sýnýf nesnesi parametre deðiþkenine ilk deðerini verecek. Parametre deðiþkeni için copy constructor çaðrýlýr.
	  3-) geri dönüþ deðeri T(T* yada T & deðil) türünden olan fonksiyonlar için. fonksiyonun geri dönüþ deðerini tutacak nesneye yapýlan çaðrý için tutulur.
	- Eðer copy constructor yazmaz isek derleyicinin bizim için yazdýðý copy constructor atanan nesnenin her bir öðesi, hayata gelen nesnenin her bir öðesi ile karþýlýklý elemaný ile hayata getirir.(MIL sentaksý ile)
	- Öyle durumlar olacak ki copy constructor yazma zorunluluðu olacaktýr.
	- Copy constructor çaðrýldýðýný geri dönüþ deðeri için gösterdik(5377)
	- copy constructor açýk ilk deðer verme için gösterildi(5384)
	- call by value fonksiyon çaðrýsý ile copy constructor(5424)
	- value semantics(iki nesnenin deðerleri aynýdýr. Birinde bir deðer deðiþikliði yaparsan diðerinde deðer deðiþikliði olmaz.)
	- uygulanan value semantic ise copy constructor'ý derleyiciye yazdýrmamýz çok normal olur.
	- derleyicinin yazdýðý kopyalamaya shellow copy(sýð kopyalama) yada member while copy
	- öðelerin handle olmasý durumunda pointer'larý birbirine kopyalamak deðil öðeleri birbirine kopyalamak gerekir.(deep copy)
	- Eðer RAII nesneleri söz konusu ise biz kaynaklarý paylaþmalarýný istemiyorsak copy constructor'ýný kendimiz yazmalýyýz. Kendimiz yazmaz isek rte olur.
	- copy constructor'ýn çaðrýlmasý duruma göre çok yüksek maaliyetli bir iþlemde olabilir. 
	- RAII nesneleri söz konusu olduðunda copy constructor'ýn çaðrýlmasý çok büyük bir maaliyet alacaktýr.
	- RAII nesnerlerinin kaynaklarý ortak olduðundan dolayý eðer bizim yapacaðýmýz bir iþlemden dolayý nesnelerden birinin hayatý diðerine göre daha erken biterse
	  bu durumda diðer nesne'nin de kaynaklarý boþa çýkacaktýr. Ve o nesne'nin kullanýmý bizim için bir run time hatasýna neden olacaktýr.(5466, 5515)
    - kod da  a1 sýnýf türünden nesne için girilen karakter'in bir fazlasý kadar karakter'lik bir nesne için MIL sentaksý ve dinamik bellek yönetimi ile 
	  yer elde edilecektir. Sonrasýnda a nesnesi func'a argüman olarak gönderildiðinde burada func'ýn paramtetresi olan a ile a1 ayný nesneyi gösterip  func'ýn sonunda a nesnesinin
	  gösterdiði dinamik bellek(heap) boþaltýlacaktýr(destructor ile). ve bu yerin kullanýmý bizim için run time hatasýna neden olacaktýr.(5515)
	
	- bu sýnýfý non-copy bir sýnýf olarak sunabiliriz. bir kopyalama iþlemi runtime deðil compile time hatasý yaptýrabiliriz.   
	- ileride öðreneceðimiz tekniklerden dolayý ostream sýnýfý kopyalamaya kapatýlmýþtýr.
	- standart kütüphane'nin yaptýðý gibi bazý sýnýflarý kopyalamaya kapatabiliriz.(Ancak böyle yaparak kullaným alanýný daraltýrýz.)
	- Copy constructor'ý private bölümüne alarak ta access kontrol ile eriþimi engelleyeibiliriz(5757). Fakat bu yöntemin sýnýfýn kendi kodlarý içindeki kopyalamaya engel olamayýz.(5787)
Not : sýnýfýn üye fonksiyonlarý sýnýfýn private bölümüne eriþebilir.
--------------------------------------------------------
	--- iþlevlerin default ve delete edilmesi
--------------------------------------------------------

	- C++ 11 ile gelen iki araç vardýr. Ýþlevleri default, ve delete etmek.
	- Ýþlevlerin default edilmesi special member function'lara tanýnan bir özelliktir.
	- delete edilmesini ise herhangi bir  function'a yapabilir.
	- Myclass() = default; // since C++11 ile default edebiliriz.(ileri de daha fazla deðineceðiz.)
	- Derleyiciye burada özel olarak default constructor'ý nasýl yazman gerekiyorsa öyle yaz demektir.
	- ileri de karþýlacaðýmýz durumlar da derleyici  default constructor'ý yazmayacaðý anlamýna gelir.
	
	- Bir fonksiyonun delete edilmesi
		- herhangi bir fonksiyona tanýnan bir haktýr.
		- sentaksý void func() = delete;
		- Burada anlam þu bu fonksiyon var ama bunlara yapýlan çaðrýlar sentaks hatasý olsun.(5851)
		- Bu fonksiyon function overload resolution'a katýlmaktadýr.ve derleyici function overload resolution'ýn sonucunu da alýr. ama fonksiyon delete edilmiþ ise hata verir.
		- Yani bir fonksiyonu belirli bir argüman ile çaðrýlmasýný saðlamýþ oluruz.
	- Bir fonksiyonu sadece bir tür ile çaðýrýlýð diðer türler ile çaðrýlmasýný engellemek için þablonlar kullanýlýr. 
	- fonksiyon þablonu : derleyicinin fonksiyon kodunu yazmasýný saðlayan bir meta koddur.
	- standartlar bir fonksiyon þablonuyla beraber bir gerçek fonksiyon ayný scope da bulunursa  gerçek fonksiyon o belirli türden bir argüman ile çaðýrýlablir.(5905)
	- delete'de yukaridaki amaç için kullanýlabilir.
	- kopyalanamayan sýnýf nesneleri olsun istiyorsak copy constructor'ý delete etmeliyiz.(5935)
	- bir sýnýfa copy constructor yazmak nasýl anlaþýlýr
		1-) bir sýnýf için destructor yazmamýzý gerekteren nedenler varsa, copy constructor'ý da yazmalýyýz.
		    eðer destructor yazýyorsak belirli kaynaklarý geri vereceðimizdendir(RAII sýnýfý). copy constructor yazmaz isek de kaynaklar da paylaþýlacaktýr.
	Not : bir sýnýf için destructor yazarsak orada yüzde 90 ya bir copy constructor yazacaðýz yada non-copy constructable bir sýnýf olmalýdýr
	      Yani kopyalama yoluyla oluþturulamayan bir sýnýf nesnesi oluþturmalýyýz.
	- C++'da ayný türden sýnýf nesneleri birbirine atandýðýnda yine bir fonksiyon çaðrýlýyordur.
	- Sýnýfýn her zaman özel bir fonksiyonu tarafýndan yapýlýr. ismi atama operator fonksiyonudur. ama sentaks da ki ismi operator keywordu ve onu izleyen = operatörü.
	- Yani sentaksý Myclass &operator = (const Myclass &r); // þeklinde bir interface'e sahiptir.
	- Constructor ile karýþtýrmamalý. Zaten iki nesne de hayattadýr.
	- sýnýfýn non-static member function'ýdýr. Bir nesne * this olarak kullanýlacaktýr. atama operatörünün sol tarafýndaki nesnedir diðer nesne de bu fonksiyona argüman olarak gönderilecektir.(5969, 6042).
	- Bir sýnýfýn atama operator fonksiyonu olmak zorundadýr. Eðer biz yazarsak bir sýnýf nesnesine ayný türden baþka bir nesne atandýðýnda bizim yazdýðýmýz fonksiyon çalýþacak.  
	- derleyici iki sýnýf nesnesinin karþýlýklý birbirine operator sentaksý ile atandýðýný gördüðünde bunu atamaoperator fonksiyonuna yapýlan çaðrýya dönüþtürür.	
	- derleyicinin sýnýf için yazdýðý atama operator fonksiyonu sýnýfýn
		1-) non-static
		2-) public
		3-) inline bir function'dýr.
	- Atama fonksiyonlarýnýn bir geri dönüþ deðeri vardýr. Constructor gibi deðildir. Ve bu geri dönüþ deðerini bir çok durumda kullanacaðýzdýr. 
	- derleyicinin yazdýðý atama fonksiyonun geri dönüþ deðeri sýnýf türünden & döndürecektir.
	- hatta fonksiyon *this döndürecektir. Yani  a = b; gibi bir ifadenin deðeri a'dýr.
	- derleyicinin yazdýðý atama operator fonksiyonu *this'in her bir öðesine argüman olan nesnenin ilgili elemanýnýn atanmasýdýr.(6042)
	- Class türünden olan iki nesne a, b için a = b; atamasý ile a.operator=(b);  ayný iþlemi yapmaktadýr.
	- eðer ortak kaynak kullanýmý söz konusu olacak ise atama operator fonksiyonunu yüksek ihtimal ile kendimiz yazmamýz gerekecektir.
	- derleyici atama operator fonksiyonun geri dönüþ deðerinin üzerinde bir kýsýtlama koymamaktadýr.
	- çok özel durumlar dýþýnda atama operator fonksiyonu *this döndürsün.
	- kendi kaynaðýný kullanmayacaðýndan dolayý o kaynaðý geri  vermesi lazým. bu yüzden delete ile bu kaynaklar geri verilmelidir.(6132)
	- bir sýnýfýn destuctor'ýný yazmak için bir neden varsa çok büyük olasýlýkla copy constructor'ýn ve atama operator fonksiyonun(assignment operator function) yazýlma gerekliliði de vardýr.(Big three deniliyordu.)
	  çok istisnai durumlar haricinde biri yazýldýðýnda diðerleri de yazýlmalýdýr.
	- big three önceden kullanýlan bir terim olup. artýk big five denilen ayrýca iki tane daha fonksiyonu yazmamýzý gerektirecek durumlar olacaktýr. üçü kesin olarak yazýlacak ve iki tane daha yazýlacaktýr.
	  C++11 ile gelen iki fonksiyon vardýr.
    
	- ayný nesneyi birbirine atamaya self assignment denir. self assignmet'ý biz doðrudan yapmasakta bir fonksiyona argüman olarak gönderildiðinde fonksiyon bunu kendisi arka da yapmaktadýr.
	- self assingment bir lojik hata olmak zorunda deðildir.
	- Yazdýðýmýz sýnýflar'ý bir self assignment'a tabi tutulduðunda bir run time hatasýna girmemelidir. Yani ortada bir kaynak kullanýmý olup biz self assignment'a karþý bir tedbir almaz isek sonu rte olur.
	- bunu engellemek için self assingment olup olmadýðýný kontrol ederek iþlemimizi yaparýz.(6211->6239)
	- atama opretator fonksiyonun kodu genel olarak þöyle yapýlabilir. release source ve ardýndan deep copy(öðelerin handle olmasý durumunda poniter'larýn deðil öðelerin birbirine kopyalanmasýdýr).
	- copy and swap idiomu da atama operator fonksiyonunun yazýlmasý için kullanýlabilir(ileride göreceðiz).
	- atama operator fonksiyonu special member function'dýr. atama operator fonksiyonu dýþýndaki(<, >, <=, >=) gibi operator fonksiyonlar special member function deðildir.
Not : operator fonksiyonlarý member function olmak zorunda deðildir. 
	
	---------- move semantics(taþýma semantiði)--------- 
		- bir dilin verimini etkilyen çok büyük bir araçtýr.
		- bir nesnenin hayatýnýn bitmesi ile boþalacak bellek alanýnýn geri verilmesi yerine onun baþka bir nesne tarafýnda kullanýlmasýdýr.
		- C++11 öncesi gereksiz kopyalama iþlemleri derleyicinin belirli bir kýsýtta kodu optimize etmesi ile yapýlmaktadýr. 
		- derleyici dilin kurallarýna göre  hayatý bitmekte olan bir  nesnenin baþka bir nesneye kopyalandýðý yada atandýðýný görse sýnýfýn özel bazýfonksiyonlarýna çaðrý yapmaktadýr.
		  bu fonksiyonlar kaynaðý geri verip yeni kaynak edinmek yerine sadece handle'larý kopyalýyorlar. 
		  bu fonksiyonlara move constructor denilir(Taþýyan kurucu iþlev denir).
		- eðer atama yolu ile kopyalama yapýlýr ise ona da (move assignment operator function denir).
		
		- C++11'den sonra bütün standart kütüphane taþýma semantiðini destekleyecek þekilde deðiþtirilmiþtir.
		
		- dile yeni eklenen R value reference'lar vardýr. &&r;
		- R value reference dilin temel sentaksýna yapýlan çok önemli bir eklemedir.eklemenin yapýlmasýnýn nedeni 2 tanedir.
			1-) dilin sentaksý kopyalama yapýalcaksa kopyalama kodunu taþýma yapýlacaksa taþýma kodunu seçmesine izin veriyordu. R value reference ile 
			    dil taþýma semantiðine kavuþmuþtur
			2-) iki tane C++11 öncesi desteklenmeyen yapýnýn desteklenmesini mümkün kýlmak için R value reference dile eklenmiþtir.
		
		- ister sol ister sað referansý olsun ikisi de nesne'nin yerine geçer. ikisinin farký sol taraf referansý l value expression olan bir nesnenin yerine
		  sað taraf referansý r value bir nesnenin yerine geçer.
		
		- sol taraf referansýna sað taraf deðeri ile deðer vermek ve tersi sentaks hatasýdýr.tersi de sentaks hatasýdýr.

		-  bir fonksiyon t türüne geri dönüyorsa, r value expression'dýr. Ama reference döndürüyor ise l value expression'dýr.
		   Myclass func();// R value expression döndürür
		   Myclass &foo();// L value expression döndürür


		- Bir fonksiyonun parametresi const T & ise bu fonksiyon R value expression ile çaðýrýlabilir.
		  copy constructor bir R value expression parametresini kabul etmektedir.
		  Myclass(const Myclass &r);//copy constructor
		  Myclass(Myclass &&r);
			
		- r value ref'in const l value ref'e seçiçiliði vardýr.(6583)
		- sað taraf referansý ile belirtilen bir nesnenin hayatý bir süre sonra biteceðine iþarettir.
		- bu yüzden de copy constructor ve move constructor'ýn bir arada olmasý sentaks hatasý olmayacaktýr.(6616);

		- Yani ölmekte olan bir nesneden aktarým yaptýðýmýzda move constructor kodunu hayatý devam eden bir nesneden aktarým yapýldýðýnda copy constructor çaðýrýlýr.
		- ayný þey atama operator fonksiyonu içinde geçerlidir. eðer atama operator fonksiyonun sað operandý R value expression ise move assignment operator function
		  L value expression ise copy assignment operator function çaðýrýlýr. Eðer R value expression ile çaðýrýlýp move assignment function yazýlmamýþ ise
		  copy assignment funct3-ion çaðýrýlacaktýr.
		- eðer kopyalamaya maaliyeti taþýma yoluyla azaltýlabilecek bir sýnýf ise taþýma constructor'ý yazýlmalýdýr.
		  

	------------------------------------------------------------------------------------------------------------------------------------------------
		
	---------------------------26.11.2017 PAZAR--------------------------------

	- Myclass(const Myclass &r); //copy ctor
	- Myclass(Myclass &&r); //move ctor
	- Myclass &operator=(const Myclass &r); //copy assingment;
	- Myclass &operator =(Myclass &&r);//move assignment;


	Myclass func();
		
	int main(){
		Myclass m1 = func();//Burada move ctor vardýr.
		Myclass m2 = m1; //Burada copy constructor kullanýlýr ise
			
	}

	- bir fonksiyonun geri dönüþ deðeri sýnýf türünden ise o fonksiyon bize R value gönderir. 

	- Myclass() = default; //ile default constructor'ý belirtiriz.
		
	int main(){
		Myclass m1;

		Myclass m2 = m1; //m2'yi m1'in kaynaðýný çalarak hayata getirmek için(move constructor çaðýrýlýr.Yani taþýma yapmaya zorlamak istiyoruz.)
	}

	- öyle bir fonksiyon var ki bu fonksiyona L value expression gönderdiðimiz zaman geri dönüþ deðeri olarak R value expression olan bir ifade verir.
	- Myclass m2 = move(m1);
	- copy constructor deðil move constructor çaðrýldý(6792).

	- Normalde dilin sentaksýna göre copy constructor çaðrýlacaðýna yerine kopyalama için kullanýlacak nesnenin kaynak kodlarýna çalarak move constructorý çaðýrabiliriz.
	- move fonksiyonu run time daçalýþan bir fonksiyon deðildir. Tamamen compile time a baðlý bir fonksiyondur.

	- C++'da eþ isimler using ile kullanýlýr.(C'deki typedef gibi)
	- using Fcmp = int(*)(const char *, const char *);//strcmp
	- Ýleri de öyle eþ isim yapýlarý  gelecek ki using ile yapabiliriz. Fakat typedef ile yapamayýz.

Not : C++'ýn öteden beri olan sentaksýndan dolayý enum türünden bir nesneye baþka hiç bir türden otomatik tür dönüþümü yoktur. Yani sadece ve sadece enum türünden bir nesne yada onun enumarator'lerinden birini atayabiliriz.
	- C++'dan enum'dan diðer türlere dönüþüm vardýr. ancak enum class'lardan da diðer türlere dönüþüm yoktur.

Not : incomplete declaration(class Myclass; Yani implimentasyonu yoktur.) kullanýlan yerler de incomplete declaration kullanarak bir baþlýk dosyasýný include etmekten kurtulabiliriz.
	
	- C'de de C++'da da enumarator'lerin scope'u enum türünün scope'dýr. Global enumarator isimleri global scope'u kirletmelerinden dolayý sýkýntý olur.
	
	- bu çakýþmayý önlemek için C++'da ilk yol olarak isimleri özelleþtirebiliriz. ikinci yol olarak bunlarý bir class içine alarak class scope'una dahil edebiliriz.

	- enum class  C'de olmayan C++. için de 11 standartlarý gelen bir enum vardýr.
	-1.si eski tip enum(unscope enum) 2. si 'de enum class(scope) isminde iki farklý scope vardýr.

	- enum class ScreenColor {White, Yellow, Gray};
	  enum class TrafficColor {Red, Yellow, Green}; // burada herhangi bir isim çakýþmasý olmayacaktýr.

	  Screen color = ScreenColor::Yellow;
	  TrafficColor tcolor = TrafficColor::Yellow; // böylece scope problemi tamamen çözülmüþtür.

	Not : enum Status {Off, On, Hold, Standby};
		Status s = Status::Hold; //Normalde Status'un herhangi bir scope'u olmamasýna raðmen bu kullanýmý da legal kýlmýþlardýr. 

	- bir yeni gelen özellikte enum türlerinin underlined type'ýný kendimiz belirleyebiliriz.Bu hem enum class olsun yada C'den gelen(covensional enum'lar) olsun underlined type alabilirler.
	  
	  enum Color: unsigned int{Black, Blue, Purple};
	  // Bunun storage'la ilgisi olabilir.
	
	- C'de R value expression ancak C++'da L value expression olan ifadeler.
	  1-) ++x;
	  2-) x, y;
	  3-) flag ? x : y;

	  if (x > 10)
		a = y;
	  else
		b = y;
		- if deyimi  ile aþaðýdaki iki deyim ayný anlama sahiptir..
		(x > 10 ? a : b) = y;// C++'da L value expression'dýr.
		*(x > 10 ? &a : &b) = y; // C'de yukarida ki kodun yazýlma þekli bu olacaktýr.
	
	--- conversion constructor---

	- Bir class nesnesine int türden bir deðer atamak bir error deðildir.
	- Sýnýflarýn tek parametreli constructor'larýna conversion constructor denir.
	- Sýnýfýn tek parametli constructor'larý parametresi türden bir deðeri olan T türünü o sýnýf türüne dönüþtürecektir.
	
	-  My class m{36};

	- m = 12; // derleyici burada  atama yaparken geçici bir nesne oluþturacaktýr.  
	//----->bu noktadan sonra derleyicinin oluþturduðu geçici nesne yoktur.
	/*
	 Myclass temp {12};
	 m.operator = (temp);(6940)
	 
	 - Geçici nesnelerin ömrü onlarýn gerektiði yerdeki ifade gerçekleþtikten sonra ömrü sona erecektir.
	 - Bazý yerlerde conversion constructor'ýn olmasý istenen bir þeydir.(özellikle String sýnýfýnda)

	 - class Counter {
		
	 };
	- Dilin kurallarý conversion constructor'ýn devreye girmesi gereken yeri programcýya býrakmamaktadýr.
	- DErleyici bir user defined convertion'ý dilin normal convertion'ý  izlediðinde bunlarý yapmak zorundadýr. Yada  tam tersi olduðunda gene zorunluluðu vardýr.
	- Yani ard arda iki kez arka arkayae user defined conversion yapamaz.
	- A-----> B--->C // C = A; ile bu dönüþümü yapmak mümkün deðildir.

	- explicit constructor explicit keyword'u ile belirtilen constructor'dýr.

	- C++'da bazý anahtar sözcükler var ki bildirim de de, tanýmda da kullanýlmak zorundadýr. explicit anahtar sözcüðü tanýmda kullanýlamaz.
	- explicit ile belirtilen constructor'ýn otomatik tür dönüþümlerinin bu constructor'ýn kullanýlamayacaðýný belirtir.
	- bunu otomatik tür dönüþtürme operatörü ile yapabiliriz.()
	- çok özel bir durum deðilse conversion costructorlarý explicit yapmak iyi bir fikirdir.
	- conversion constructor bir special member function deðildir. Bunu yazacak isek convertion constructor'ýn kodunu kendimiz yazmalýyýz.

	- Counter z = 45; derleyici 45 ifadesini geçici bir Counter nesnesini dönüþtürür. Sonra da oluþturulan bu nesneyi copy constructor ile z ' ye ata;(Counter temp(45); Counter z(temp); ifadesine dönüþtürür.)
	- Counter z = 45; ile derleyici aslýnda Counter z(45); ifadesi olur. Eðer convertion constructor explicit ise bu durum sentaks hatasýdýr.()
	- tek parametreli olmayan bir constructor'ýn explicit keyword'u ile bildirilmesini sentaks hatasý olarak görmez.
Not : Smart pointer'lar kopyalamaya tamamen kapatýlmýþ pointer'lardýr. Hiç bir zaman dinamik nesne'nin iki sahibi açýktýr. Ama taþýma semantiðine açýktýr.
	--------------------------------------------------------------------------------------------------------------------------------------------------------
	------------------ 02.12.2017 CUMARTESÝ---------------------
	Myclass m2(10);
	Myclass m2{12};
	Myclass m3 = 20; //eðer conversiton ctor explicit ise bu gerçekleþmeyecektir.
	
	void func(const Myclass &r);

	int main(){
		func(flag) //flag bir boolean türden bir deðiþken olmak üzere eðer func fonksiyonunun double türden bir standart conversion'ý varsa burada otomatik dönüþüm ve user defined türden bir dönüþüm olacaktýr.	
	}

	- conversion constructor'ýn exlicit olmamasýnýn verebileceði bir logic hata. (7301)
	- unique ptr'nin constructor'ý da explicit'tir.
	- unique ptr nesnesi olan nesnenin scope'u bittiðinde nesneyi yok edecektir.
	-  convertion ctor'un explicit olmasý Class türünden bir nesneye otomatik dönüþüm ile deðer vermeye izin vermemeiþlerdir.

Not : C++'da fonksiyon tanýmýnda da parametre nesnemizin bir ismi olmak zorunda deðildir. Function overloading saðlanmasý içindir.(7390)	
	
	- bir class türünden nesne hayata geliyor ise mutlaka ctor çaðrýlmýþtýr.

	- conversion constructor class türünden bir nesneye, class türünden olmayan bir nesne ile atama yapýldýðýnda yada ilk deðer verildiðinde  çaðýrýlabilir. Derleyici bizim için bir  geçici bir nesne oluþturacaktýr.

	- Myclass(12) için derleyici sadece bu ifadenin yürütülmesi için bir geçici nesne oluþturdu(7429).

	-	string h1(const string &s)
		{
			return "<h1> + s + "</h1>";

		}

		int main()
		{
			h1("Necati"); // ile çaðrýlmasýnda ctor explicit ise bir hata verecektir.

			h1(string("poyraz")); //ile derleyici bir geçici bir nesne oluþturur. Ve derleyicinin oluþturduðu bu geçici nesneler r value'dir.
		}

	- derleyicinin oluþturduðu geçici nesneler r value reference'dýr.
	
	- geçici nesne oluþturma sentaksý ile bir geçici nesne oluþturmak zorunlu bir sentaksdýr. Bu nesneyi bir kere kullanacaðýmýz zaman geçici nesne oluþturmalýyýz.

	Not : Özel bir durum yoksa uniform initializer ile ilk deðer vermeliyiz.
	
	- initializer list bir ifade içinde küme parantezi kullanarak bir fonksiyona bir deðerleri argüman olarak geçmemizi saðlar.
	
	- eðer intializer list ile beraber int gibi bir parametreye sahip fonksiyon overload edilirse öncelik intializer list parametrenindir.
	 vector<int> vec1(12); // derleyici int parametreli deðil initalizer list olan fonksiyon devreye girer.
	 
Not : L value expression sað taraf referansýna baðlanamaz.sentaks hatasýdýr.const Myclass & parametresine sahip bir fonksiyon parametresini sað taraf referans ile çaðýrabiliriz.(7517)
	
	- bir fonksiyonun geri dönüþ deðeri referans ise l value expression, sýnýf türünden ise r value expression'dýr.
	- hayatta olan bir nesnenin kaynaklarýný çalmak istiyorsak l value to r value fonksiyonu olan move fonksiyonu çaðýrmamýz gerekecektir.

	- void func(string s) --> böyle bir fonksiyonu l value ile çaðýrýrsak kopyalama kesin olacaktýr. r value ile çaðýrýrsak derleyici kopyalama yapmayýp optimizasyon yapacaktýr.

	--- STATIC VERÝ OGELERÝ AND STATIC MEMBER FUNCTIONS ---

	- C++'da static anahtar sözcüðünün kullanýmý çok daha fazla geniþletilmiþtir.
	- non-static data members bir sýnýf nesnesinden bir sýnýf nesnesine deðiþikþlik gösterebilen verileri tutar. Bu veriler sýnýf nesnesinin içinde kullanýlýr.
	- sýnýf'larýn ortak kullandýðý verilere de static data member denir.
	- Bunlar C'dekþ global deðiþkenler gibidir. Farký 3-4 tanedir.
		1-) scope// sýnýfýn static veri elemanlarý class scope içindedir.
		2-) access control//

	- namespace{
		int gx = 10;
	};//unnamed name space(c'deki static globaller gibidir. Ama her þeyi buraya koyabiliriz.fonksiyon, typedef)

	- gömülü sistem programlama da global deðiþkenler'in kullanýmý çok daha sýktýr.

	- sýnýfýn diðerr veri elemanlarýndan farklý olarak statik veri elemanlarýnda  mutlaka kaynak dosyalarýn birinde tanýmý olmalýdýr.

	- statik veri elemeanlarýnýn hayata gelmesi main çaðrýlmadan öncedir.
	- statik veri elemanlarý sýnýf nesnesinin sizeof'u ile aalakasý yoktur.
	- client kodlarýn statik veri elemanlarýný class scope içinde aramalýdýr.
	- özellikle aritmetik türden veri elemanlarý için mutlaka ilk deðer vermeliyiz.
	- statik anahtar sözcüðü tekrar edilemeyen sözcüklerdendir. sadece bildirim de olmalýdýr.
	- bir statik data member'ýn bildirimini yaptýðýmýz gibi tanýmýnýda yapmalýyýzdýr.
	//myclass.h 
		class Myclass{
			int mx1, mx2;
		public:
			static int msx;
		}
	//myclass.cpp 
	int Myclass::msx = 0;(7620);

	- Bir sýnýfýn non-static veri elemaný kendi türünden olamaz.nedeni incomplete type olduðundan dolayýdýr. ama incomplete type'dan bir statik veri elemaný olabilir.(7627)

	- forward declaration : bir türün bildirimini derleyiciye haber verip tanýmýný vermemizden dolayýdýr.

	- bir sýnýf baþka bir sýnýf türünden veri elemanýna sahip olacaksa bu sýnýfýn baþlýk dosyasý diðer sýnýfý include etmek zorundadýr. Eðer veri elemaný statik veri elemaný
	olsaydý baþka bir dosyayý include etmemize gerek kalmadan sadece bildirimini görmemiz yeterli olacaktýr.

	- bir baþlýk dosyasýnýn baþka bir baþlýk dosyasýný inlcude etmesi gerek yokken çok büyük bir sorumluluktur.

	- sýnýfýn veri elemaný pointer yada referans ise bunun için complete type olmasý zorunluluðu yoktur.
	- global deðiþkenler gibi sýnýflarýn statik veri elemanlarý main çaðrýlmadan hayata gelmektedirler. Bunlar'ýn varlýðý için ortadaki bir sýnýf objesi olmasýna gerek yoktur.
	- farklý kaynak dosyalarýnýn include edilmesi sonucu statik class member'larýn hangisinin daha önce hayata geleceði için bir standart yoktur. ve bu runtime'a sebep olabilecek bir koddur.(7752);
	 
	- sýnýfýn statik veri elemanlarýnýn MIL sentaksý ile hiç bir  ilgisi yoktur. dolayýsý ile ona yönelik bir kod yazmaya çalýþýrsak sentaks hatasýdýr.(7778)
	- MIL sentaksý constructor ile ilgilidir. Ve constructor da sýnýfýn non-static veri elemanlarýný deðiþtirmeye yönelik bir fonksiyondur. Ama sýnýfýn herhangi bir üye fonksiyonu
	  sýnýfýn statik veri elemanýný kullanabilir.
	- const üye fonksiyonlarý static veri elemanlarýný deðiþtirebilir. ve const üye fonksiyonu çaðýrýlan fonksiyonun deðerlerini dðeiþtirmemeye yöneliktir. static veri elemaný ile hiç bir il ilgisi 
	  yoktur.
	- sýnýfýn statik üyelerine nokta opeatörü yada ok operatörü ile de eriþebilir.(public ise). Ama bu okuyana sanki nesne ile bir alakasý olduðunu gösterir.
	
	- class scope'da kullanýlmýþ bir member function'ýn çaðrýlmasý için bir nesne olmasý eðer statik bir member function deðilse zorunludur.(7855)
	- statik veri elemanlarýna ilk deðer veren ifade de ilk baþta class scope'a bakacaktýr.(7901)
	
	
	------ static member functions -------
		- bir sýnýf nesnesinin adresi ile çaðrýlmayan, dolayýsý ile bir instance ile ilgisi olmayan fonksiyonlardýr.
		- global fonksiyonlarýn yerine geçmeye çalýþan en büyük aday static member functions
		- sýnýfýn private bölümüne eriþim hakkýna sahipler. Global fonksiyon sýnýfýn private bölümüne eriþim yapamazlar.
		- sýnýfýn static member function'larýný private public yada protected yapýlabilir.
	Not : instance -> bir sýnýf nesnesinin oluþumu, hayatta oluþu
		
		- inline olarak tanýmlanabilir.
		- inline olarak tanýmlanmayacak ise tanýmýn sýnýf türüne nitelenmesi gerekir. void Myclass::func(int x); 
		- static keywordu tanýmda kullanýlamaz.
		- static keyword'unun this pointer'ý yoktur.(7987)
		- sýnýfýn constructor'ý private iken bu sýnýfýn kendi statik üye fonksiyonlarý ctor'a eriþebilirler.(8058)

		- static üye fonksiyonlarýný const, non-const diye bir þey yoktur. const kullanýmý geçerszidir.
		- buradaki üye fonksiyonun const olmasý *this'i deðiþtirip deðiþtirmeyeceði olmalýdýr.
		- sýnýfýn static üye fonksiyonu doðrudan sýnýfýn non-static üye fonksiyonunu doðrudan çaðýramaz.(8093)
	--------------------------------------------------------------------------------------------------------------------------------------------------------
	
	------------------ 03.12.2017 PAZAR----------------------
	- static üye fonksiyon'un this pointer'ý olamaz.
	- static üye fonksiyon const olamaz.
	- static üye fonksiyon içinde sýnýfýn non-static data member'ý ismiyle kullanamaz.
	- static üye fonksiyon içinde sýnýfýn non-static member function'ýna eriþemez.
	- non-static member function, static member function'una çaðrýda bulunabilir.
	- Hayatta olan nesnelerin sayýsýný saymak çok sýk kullanýlan bir temadýr.(static int instance_count;)
	- Constructor private yapýlýrsa ne otomatik ömürlü ne statik ne de dinamik ömürlü nesne oluþturamayýz.(8272);
	- eðer constructor private ise bir nesne yaratmak için static T *'a geri dönen bir member function yapmalýyýz.
		daha sonrasýnda copy constuctor ile otomatik ömürlü yada static ömürlü bir nesne oluþturabiliriz.
	- en çok kullanýlan tasarým kalýplarýndan biri singletan(tek nesne).
		
	- sýnýf nesnesi ile sýnýfýn non-static fonksiyonu çaðýrmak yerine sýnýfýn static member function'ýný çaðýrýrsak derleyici hiç bir hata vermeyecektir.
	
	- C++'da static yerel sýnýf nesneleri ilk çaðrýldýðýnda hayata gelecektir.
	------ meyer singleton ---- 

		static Counter &getInstance(){
			static Counter c;
			return c;
		}
	--------------------------------
	- Sýnýfýn static veri elemanlarýný sýnýf içinde nitelereyek  kullanan coderlar vardýr. 
	--------------------------------------------------------------------------------------------------------------------------------------------------------
	
	------------------ 09.12.2017 CUMARTESÝ----------------------

	- pimple idiom ile bir baþlýk dosyasý ile client'larýn iliþkisi kesilebilir.(þimdilik öðrenmemiz için çok erkendir.)
	- eski c++'da Taþýma semantiði olmadýðý için kopyalama maaliyeti çok fazla kaçýnýlýyordu. Modern C++ ile tþaýma semantiði geldiðinden dolayý bunlarý rahatça
	yapabiliriz.
	
	- en sýk yapýlan vector iþlemlerinden biri, container'da belirli öðeye sahip bir öðeyi silmemiz gerekebilir.
	- Bir container'da belirli bir deðeye sahip ilk öðeyi silmek ve tamanýný silmek arasýnda farklar vardýr.
	
	- remove arrays = nit sequence container'da belirli öðelere sahip öðelerin tamamýný silmek için remove arrays idiomu kullanýlýr.
	- her container sýnýfýnýn container'da belirli bir öðeye sahip öðesini silmek için kullanýlan bir sýnýf vardýr.
	- range based for loop => for( : ) iki noktanýn sað tarafýna dolaþmak istediðimiz veri elemaný yazýlýr.  

	- int a[]= {12, 24, 24, 24, 25, 67, 85};
	  for (int i : a );//burada referans semantiði yoktur.(döngü deðiþkeninin refereans semantii olarak kullanmak istersek int &i kullanmaktýr.)(8755)
      for (const int &i : a); // container'ý salt okuma amaçlý kullacanaðýmýzý belirtiriz.
	- range based for loop auto keyword'u ile kullanýlabilir.

	- for (auto x : c);//burada kopyalama semantiði vardýr.
	- for (auto &x : c); // burada x container'daki öðenin yerine geçen referans isim  ve set amaçlý kullanacaðýmýzý gösterir.
	- for (const auto &x : c); // salt okuma amaçlý kullanma referansý.

	- range based for loop her zaman container'ýn tamamýný dolaþmak içindir.

	- range based for loop örneði(8816)
	- range based for loop taþýma semantiðin de de kullanýlabilir. for(auto &&r : c);

	-'den 100'e kadar sayýlarý ekrana yazdýran bir C++ kodu yazýnýz(döngü yazmadan)(8875)

	- bir container'ý baþtan sona dolaþýrken begin ve end fonksiyonlarý kullanýlýrken sondan baþa dolaþýrken rbegin ve rend fonksiyonlarý kullanýlýr.

	------ arkadaþlýk bildirimleri ------

	- sýnýfýn private bölümleri sýnýfýn kendi kodlarý hariç sýnýfýn implementasyonunu client'lara kapatýlýr.
	
	- öyle kodlar var ki siz seçilmiþ bazý kodlar için sizin private bölümününe eriþim saðlanacaktýr. Bu araç özel durumlarda kullanýlacak bir araç olacaktýr.
	
	- kodsal bir problemin en kolay çözümü seçilmiþ bir koda sýnýfýn private bölümüne yetki vermektir.

	- C++'da arkadaþlýk bildirimi 3 farklý kategoriye ayrýlýr.
		1- global bir fonksiyona arkadaþlýk vermektir.
		2- bir baþka sýnýfýn bir üye fonksiyonuna friendlik vermektir.
		3- bir sýnýfa komple arkadaþlýk vermektir.
	
	- bir class içerisinde friend keyword ile bildirilmiþ bir fonksiyon bildirimi o fonksiyonun direk global olduðunu gösterir. ve derleyicinin foo iþlevinin bildirimini daha yuakrýda görmesi gerekmez.(9033)

	- friendlik bildirimin de ilginç bir nokta daha vardýr. friendlik bildirimi bildirilen bir fonksiyonun tanýmýný sýnýfýn içinde inline olarakta yapabiliriz.
	
	- friendlik bildirimi sadece private bölüme eriþim yapmak zorunda kullanýlmak zorunda deðildir.
	
	- bir friendlik bildirimini sýnýfýn public yada private bölümünde yapýlmasýnýn farkýnýn olmadýðý ender durumlardan biridir.
	
	- class Myclass {
		void foo();
	public:
			frined class A;
	}  

	- Burada A sýnýfýnýn complete bir type olma zorunluluðu yoktur.
	
	- A sýnýfýnýn B'ye arkadaþlýk vermiþ ise B'nin kodlarý içinde A'nýn private bölümüne eriþilebilirken B sýnýfý A'ya arkadaþlýk vermeden A sýnýfý B'nin private bölümüne eriþemez.
	- A sýnýfý B'ye B sýnýfý C'ye arkadaþlýk verdiðinde C'den A'ya direk eriþim yoktur.
	
	
	----------------------------operator overloading(iþleç yüklemesi)------------------------------

	- C'de yapý nesneleri sadece 4 tane operatörün operandý olabilir. &, ., sizeof, =

	- C++'da bir sýnýf nesnesinin diðer operatörlerin operandý olmasý da mümkündür. Biz bir nesneyi opeartörün operandý yapmýþ gibi gözüksekte derleyici compile time da 
	bunu fonksiyon çaðrýsýna dönüþtürüyordur.
	- operatörlerin doðal türden veriler için sunduðu interface'i sýnýflara da taþýyarak client kodlara yardýmcý olmayý saðlamaktýr.
	
	- date1 = date2++;

	- bu mekanizmanýn herhangi bir runtime maaliyeti yoktur.

	- programýzýn çalýþma hýzý ile operator oveloading'in herhangi bir alakasý yoktur.

	- C++'ýn çok büyük standart kütüphanesi operatör overloading'e dayanýr.
	
	- overload edilen bir opearatör'ün operandý olmasý durumda global bir fonksiyonun çaðrýsýna dönüþüyorsa buna global operatör fonksiyonlarý denir.
	-  overload edilen bir opearatör'ün operandý olmasý durumda class member functionýn bir fonksiyonun çaðrýsýna dönüþüyorsa operatör member function denir.

	---iþlek yüklemesi olmak için---
		1-) bir operatör yüklemesi olmasý için en az bir operandýn sýnýf türünden olmasý gerekir.
			- örneðin i1 ve i2 int türden nesne olmak üzere i1 = i2 için bir fonksiyona yapýlan çaðrýya dönüþtürme olanaðý yoktur.
	
		2-) dilin kurallarýna göre overload edilemeyen operatörler vardýr.
			- koþul operatör(ternary operator)
			- nokta operatörü(nokta op.) 
			- :: operatörü
			- .* operatörü (C'de olmayan C++'da yoktur.)
			- sizeof
			- new
			- delete
			- typeid 

		Not : operatör new ve operatör delete fonksiyonlarý function overload edilebilir.
		
		- bazý operatörler yalnýzca üye operatör fonksiyonu olabilir.
			- iþlev çaðrý operatörü
			- ok operatörü
			- köþeli parantez operatörü
		
		3-) operatör overloading mekanizmasýnda operatörlerin arity'sini deðiþtiremeyiz. Yani binary operatörleri binary olarak uniry operatörleri uniry olarak kullanmalýyýz.
			- binary bir operatör member operatör fonksiyonu olarak çaðrýldýðýnda burada her zaman sol taraftaki operandý *this olarak alýnýr.binary operatörün sað operandý da 
			parametre deðiþkenine gönderilen argüman olacaktýr.
			- binary bir operatör member function olarak yüklendiðinde 1 parametresi olmak zorunda global ise 2 tane parametresi olmak zorundadýr.
			- uniry bir operatör member function olarak yüklendiðinde fonksiyonun parametresi olmayacak, global ise bir tane parametresi olmak zorundadýr.
---------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------10.12.2017 PAZAR---------------------------------------------------
		OPERATOR OVERLOADING genel kurallar
	1- Ortada bir operator ovelraoding olmasý için mutlaka bir sýnýf nesnesi olmalýdýr.
	2- operatör olmayan bir atomu bu mekanizma da kullanma þansýmýz vardýr.
	3- bazý operatörler overload edilemez.
		- koþul operatör(ternary operator)
		- nokta operatörü(nokta op.) 
		- :: operatörü
		- .* operatörü (C'de olmayan C++'da yoktur.)
		- sizeof
		- new
		- delete
		- typeid 
	4- bazý operatörler için sadece member function yazýlabilir.
		- iþlev çaðrý operatörü
		- ok operatörü
		- köþeli parantez operatörü

	5- Bu fonksiyonlara keyfi isim veremeyiz. isimleri operator keywordu ve keywordu hangi operatör takip ederse o operatör kullanýlýr.
		RET.TYPE operator+()const;//iþaret operatörü
		RET.TYPE operator+(const Myclass &r)const;// toplama opreatörü
		RET.TYPE operator()();// fonksiyon çaðrý operatörü 
	
	6- operator new ve operator delete dýþýnda hiç bir operator fonksiyonu static olarak yazýlamaz.


	7- class Myclass{
		public:
			bool operator>(const Myclass &r);
			// yada friend bool operator>(const Myclass &r1, const Myclass &r2);
	}

	8 - fonksiyon çaðrý operatörü  hariç hiç bir operator fonksiyonu varsayýlan argüman alamaz.
	
	9- operatör öncelik seviyesi ve yönünü deðiþtiremeyiz.
		bool f = m1 * m2 +m3 > m4;
		//eðer operator fonksiyonlarý global ilse
		bool f= operator>(operator+(operator*(m1, m2), m3), m4);
		//eðer operator fonjsiyonlarý member function ise
		bool f = m1.opeator*(m2).operator+(m3).operator>(m4);
		// > member function olup gerisi global olursa
		bool f = operator+(operator*(m1, m2), m3).operator<(m4);

	- endl bir member function ismidir.
	m1.operator<<(endl); //'de argüman olarak function pointer gönderilir.	

	- binary operatörleri overload edilen operator function sol operandý sýnýf nesnesinden ise sol operand için fonksiyon çaðýrýlýr. eðer sol operand 
	sýnýf türünden deðil ise ve sað operand class türünden ise global bir operator function çaðýrýlmasý gerekir.

	
	- operator fonksiyonlarýnýn geri dönüþ deðeri problem domaini yada logic yapýsýna göre deðiþir. reference yapýsý olup olmamasýda tamamen logic yapý ile
	  ilgilidir.
	- operator'un ürettiðin deðer l value expression olacak ise fonksiyonun döndüreceði deðer reference olmalýdýr.
	
	- operator'un ürettiðin deðer r value expression olacak ise fonksiyonun döndüreceði deðer const reference olabilir. Yada r value döndürmesi gerekir.

	- fonksiyon çaðrýlarýnda gereksiz kopyalamaktan kaçýnmak için bir fonksiyonun parametresi sýnýf türünden deðil sýnýf türünden referarans olacaktýr.

	- stl user defined türler sözkonusu olduðunda en önemli operatörler < ve == operatörleridir.

Not : C'de de C++'da da iþaret operatörleri r value expression üretirler.
	
	- parametresi olmayan bir operator ++ bildiriirse bu prefix(++x) olarak bildirilecektir. // C++'da ++x l value expression'dýr. & türden yapýlýr
	- int türden parametresi olacak bir operator ++ bildiriirse bu postfix(x++) olarak bildirilecektir.//C++'da r value expression'dýr. Türden yapýlýr.

	- yani prefix için Integer& operator++(); //prefix
	  yani postfix için Integer operator++(int);//postfix olur.				

	Not : C++'da operatör fonksiyonlarý friend'in en fazla kullanýldýðý yerlerdir.

	- çok sýk kullanýlan bir kodlama idiomumda  karþýlaþtýrma operatörleri < operatörünü kullanarak saðlanýr.	

	- aritmetik operatör fonksiyonlarýn en iyi yazýlma þekli olarak += fonksiyonunu + toplama fonksiyonundan sonra yazacaðýz.
---------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------16.12.2017 CUMARTESÝ---------------------------------------------------

	- global operator fonksiyonlarýnýn tanýmý sýnýfýn içinde inline olarak tanýmlanabilir.

	- += fonksiyonu ve + fonksiyonu yazýlýrken ilk önce += fonksiyonu member function olarak yazýlýr. + fonksiyonu ise global olarak yazýlýp içinde += fonksiyonunu
	  çaðýrmalýdýr.
	
	- ön ek konumlarý(++x) l value expression'ken son ek konumlarý(x++) r value expression'dýr.

	- Integer& operator++()//onek
	  {
		++mval;
		return *this;
	  }
	
	- son ek operator ++ fonksiyonun dummy parametresi olacak.(Yani var olacak ama kullanýlmayacak).
	
	- Not: son ek ++ operatörü *this'i artýrmak için önek ++ fonksiyonunu çaðýracaktýr.

	---- inserter & extractor

	- friend std::ostream &operator <<(std::ostream &os, conset Integer &i)
	  {
	       return os << "(" << i.mval << ")" <<endl;
	  }
	
	- frined std::istream &operator>>(std::istream &is, Integer &i);

	 - cout << c1++ << "  " << ++c2 << endl;(9620)
	   //operator<<(operator<<(cout,c1.operator<<(0)).operator<<("   "),c2.operator++()).operator<<(endl); 
		
				-------- özel operatörler ---------
	
	- dilin sentaksý ve kullanýmý açýsýndan özelliði olan operatörlerdir.( [], *(içerik operatörü), ->, tür dönüþtürme operatörleri, ()iþlev çaðrý operatörü)

	1-) köþeli parantez operatörü
		- member function olmak zorundadýr. p[n] biçimde yazýlan bir ifadenin fonksiyon ile çaðrýlmasý p.operator[](n);
		- burada n'nin tipik türü size_t 'dir.
		- köþeli parantez operatör fonksiyonu kesinlikle referans döndürmelidir.
		- reference döndürmesi gerekmektedir.
		- Bir sýnýfýn const'luk dýþýnda ayný sýnýfa ait function overload'u olabilir.
			- char &operator[](size_t idx);
			  const char &operator[](size_t idx)const;
		- köþeli parantez operator fonksiyonlarý için hemen hemen her zaman const overload yapýlýr.

		- Name sýnýfý için büyük beþli köþeli parantez operatörü ve standart giriþ  ve çýkýþ fonksiyonlarý yazýldý.(9780)
Not : x bir map nesnesi ise eðer x["asdasd"]; eðer böyle bir associative array yok ise map nesnesine ekleme yapýlacaktýr.
	
	
	2-) *(içerik operatörü)
		- *ptr --> ptr.operator*(); 
		- member function olarak yazýlacaktýr. 
		
	3-) ->(ok operatör fonksiyonu)
		- ok operatörü binary bir fonksiyon iken uniry bir fonksiyonmuþ gibi görülür
		- a->b demek a.operator->()->b; demektir. 
		- bir sýnýfýn ok operatör fonksiyonu baþka bir sýnýfýn ok operatör fonksiyonunu çaðýrabilir.
		- dinamik nesneleri MyclassPtr gibi sýnýf nesnesinden bir nesneye baðlayarak hayatýný sonlandýrabiliriz(10133);
	class template örneði(10220);
---------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------17.12.2017 PAZAR---------------------------------------------------
	- unique_ptr nenesine atama semantiði, kopyalama tamamen yanlýþtýr. taþýma semantiði kullanýlabilir.
	- dinamik bir nesne ile ilk deðer vermeliyiz. Varlýk nedeni bundan kaynaklýdýr.
	- unique ptr sýnýfýnýn constructor'ý explicit'tir.
	- bu sýnýfýn ömür iliþkisin de scope vardýr. garbage collector kullanýlýr.
	- yani dil bize dinamik bir nesnenin tek bir sahibi olabileceði yapabileceðimizdir.
	
	- reference counting : reference sayýmý, belirli bir T anýnda nesneyi gösteren kaç tane pointer olacaðýný gösterir.
	
	
	- shared_ptr bir nesnenin birden fazla sahibi olabilir. yani  kopyalama semantiði geçerlidir.
	
	- operator tür dönüþtürme  fonksiyonlarý ile sýnýf türünden bir nesneye dönüþüm saðlanabilir.
	
	- operartor tür dönüþtürme fonksiyonlarýnýn geri dönüþ deðeri türü yazýlmaz. Bu constructor gibi deðildir.
	  zaten hedef tür yazýlacaðýndan dolayý geri dönüþ deðeri türünün yazýlmasýna gerek kalmaz.
	
	- operator tür dönüþtürme fonksiyonu operator int()const; þeklindedir.

	- int mx = c;
	  int mx = c.operator int(); þeklindedir.(10699)
	  int mx = static_cast<int>(c);(C tarzý tür dönüþtürme operatörü de kullanýlabilir.)
	  int mx = (int) c;
		
	  derleyici her biri için sýnýfýn operatör int fonksiyonunu çaðýracaktýr.
	
	- derleyici arka arkaya iki tane user defined tür dönüþümü yapmaz.

	- sýnýfýmýza kontrol etmek amaçlý operatör tür dönüþtürme fonksiyonlarýný explicit yapmamýzý engelleyebiliriz.()
	 
	- string sýnýfýnýn en önemli fonksiyonlarýndan biri c_str'dir. string sýnýfý türünden bir nesneyi const char * türüne dönüþtürür.

	- yani string sýnýfýndan const char *'a otomatik tür dönüþümü yoktur.

	- C++'da sýnýf türlerinden bool türüne otomatik dönüþüm yoktur. Yani logic yorumlamayý saðlayacak bir operatör fonksiyonu yazmak doðrudur.

	- bir sýnýfýn herhangi bir tür dönüþtürme fonksiyonunu bool'in türüne dönüþüm için kullanabiliriz. Ama böyle bir kullanýmýn zararý çok olabilir.

	- modern C++ ile bir sýnýfa operator bool yazýlýp bu fonksiyon explicit yapýlýrsa baþka türe otomatik tür dönüþümü yasaklanmýþ olur. logic contextte 
	  kullanýlmasý durumunda ise sentaks geçerlidir.(11001)
	- 

---------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------23.12.2017 CUMARTESÝ----------------------------------------------------------------

	-----------NESTED TYPES------------
	- sýnýfýn type member'larý vardýr.(type members);
		1- bir türün bildirimi sýnýfýn içinde yapmak ile sýnýfýn dýþýnda yapmak arasýnda fark vardýr.(Bu class scope'da ki bir türdür.);
		2- en sýk karþýmýza çýkan nested types'lar typedef bildirimleri, bir sýnýfýn öðesinin baþka bir sýnýf olmasý, enum'lar.
	- nested type'lar da access kontrol yapýlmaktadýr.Yani client'ýn bu bildirimlere eriþebilmesi için
	  sýnýfýn nitelenmesi gerekmektedir.
	  sýnýfýn private bölümünde olmamalýdýr.
	
	- en önemli noktalardan biri  isim aramadýr.
	
	- eðer class definition içinde bir isim aranacaksa sýnýfýn her yerinde aranmamaktadýr. Class definition'dan bulunduðu yere kadar arama yapýlýr.
	  bütün class scope'u içinde aranmaz.
	  
	- class Word{
		public:
		void foo();
	  }
	  class Myclass{
		public:
			Word mword;//Bu Word sýnýfý türünden bir nesnedir.
			typedef int Word;
	  }
	
	- fonksiyonun inline olmasý isim arama kurallarýný deðiþtirmemektedir. Bir sýnýf'ýn member function'ýnda tanýmlanan bir isim önce tanýmlandýðý fonksiyonun içinde 
	  sonra bütün class scope'da aranacaktýr.//bütün class scope sadece kendi bulunduðu yer deðildir.(11541);
	
	- pimple idiyomu - client'tan baþlýk dosyasýnýn gereksiz include edilmesini saðlar. sadece bununla kalmayýp client'ten sýnýfýn private bölümünü gizleriz.
	  yani sýnýfýn öðelerini sýnýfýn veri elemaný yapmak yerine  pimple isminden bir yapýnýn veri elemanlarý haline getirebiliriz.
	
	 ----------------------------STANDART STRING CLASS--------------------------------

	 - string bir template sýnýfýn açýlýmýnýn typedef isminden baþka bir  þey deðildir.

	- template < typename A, typename B, typename C > //typename A--> template	type parameter. 

---------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------24.12.2017 PAZAR--------------------------------------------------------------------

	iterator
		string::iterator
		string::const_iterator
		string::reverse_iterator
		string::const_reverse_iterator
		gibi 4 farklý iterator nested type'ý vardýr.

	- iterator semantiði bir container'da ki tutulan öðelerden her bir öðenin konumunu tutmak için kullanýlýr. container'daki her bir öðenin konumunu tutan nesnelere iterator denir.
	
	- modern c++ öncesi iterator veren fonksiyonlar sadece member function'lardý.

	- container'da tutan bir öðenin iterator'unun deðerini sürekli artýrýrsak belirli bir noktada end fonksiyonunun gösterdiði iterator'a kadar devam edecektir. Yani bütün container'ý dolanacaktýr.
	
	- eðer string sýnýfýnýn bir üye fonksiyonunun parametresi const char * ise sizden bir c-string(sonunda null karakter olan) istiyor. Bu durumda yazýnýn son karakterinin null character olmasý tamamen bizim sorumluluðumuzdadýr.
	
	- eðer const char *' a eþlik eden bir size_t parametre var ise, bu bir adres ve o adresden baþlayarak kaç karakter alacaðýný gösterir.(buffer parametre)

	- iki adres isterse onu da range olarak kabul etmektedir.(range parametre). 1. iterator konumu dahil, ikinci iterator konumu hariç.

	NOT : buffer parametreye çok dikkat edilmesi gerekmektedir.

	- fill(doldurma) parametre. karakterden kaç tane olduðu ilk parametresi size_type n, ikinci parametreis charT türünden karakterdir.

	- parametresi string, size_type, size_type ise string'in i. indeksinden baþlayarak n tane karakter kopyalayacak.

	- container'ýn tamamýný silen fonksiyon clear'dýr. container'ý silmenin birden fazla da yolu vardýr.

	- string s1(35,'A');

	- string s2{35,'A'}; //initializer_list_ctor //bu constructor ile yukarýdaki constructor birbirinden farklýdýr. sýnýflarýn initalizer list constructor'ý var ise bunun önceliði vardýr.

	- raw string literal(Sadece yazýma iliþkin bir notasyondur.) R"()" ile kullanýlýr.//c++11

	- R"--()--" ile de delimeter olarak da yazýlabilir.

	- baþtan belli olan bir kapasitelik için reserve fonksiyonu ile önceden yer ayýrabiliriz.

	------string::npos------

	- string sýnýfýnýn bir public, const static veri elemanýdýr.

	- bir string'in olabilecek en uzun yazý sayýsýný gösterir. Yani bir yazý da geçerli bir indeks olarak kullanýlamaz.

	- npos'un sýk kullanýlan yerlerinden biri arama fonksiyonlarýnýn baþarýsýzlýk deðeri'dir.
	
---------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------06.01.2018 CUMARTESÝ--------------------------------------------------------------------

	- operator iterator iþlemleri : 

	- sýnýfýn begin ilk öðeye iterator verir. begin fonksiyonunun geri dönüþ deðerine index verir.
	- bir iterator geçersiz bir deðer tutuyorsa rte olur ve exception mekanizmasý döndürürler.

	- iterator nesnesini * operator'unun operandý yaparsak o anki iterde tutulan adrese eriþilir.

	- bir container sýnýfýnýn aralýðýný sýnýfýn begin ve end fonksiyonlarý ile belirleyebiliriz.

	- bir yazýnýn ilk karakterine eriþmenin yolu s.front , s[0], s.begin() fonksiyonun geri dönüþ deðeri olan iter'i dereference etmektir.

	- bir yazýnýn son karakterine eriþmenin yolu s.back(), s[s.length() - 1], *--.end() = yada bunun yerine *prev(s.end()) ile yapýlabilir.

	- C++11 ile global begin ve end fonksiyonu eklenmiþtir.
		begin(s);
	
	- her iterator sýnýfýnýn hem const iterator(string::const_iterator), hemde iterator nested type'ý vardýr. eðer bir range'i okuma amaçlý dolaþmak için kesinlikle const_iterator'u kullanmalýyýz.

	- cbegin ve cend fonksiyonlarý const_iterator döndürür.
	
	- modern c++'da bir container'ý okuma amaçlý dolaþmanýn yöntemi þöyledir.
		
		- for(auto citer = svec.cbegin();iter != svec.cend(12654); ++iter)//örneklerde ki kodda hata var.doðrusu burasý
				// sadece container'ý okuma amaçlý kullanýlabilir.

	- global cbegin ve cend fonksiyonu da vardýr.

	- reverse iterator : öyle bir iterator ki siz onu artýrýrken o azalarak gider. Tersten baþa doðru dolaþmak içindir.

	- rbegin verdiði deðer son öðenenin konumudur.
		string::const_reverse_iterator iter = s.rbegin();
	
	- .....iteartorlerine sahip sýnýflar ile pointer'larla yapýlan bütün iþlemleri gerçekleþtirebiliriz.

	- range based for loop ile derleyici iterator kodu yazma kýsmýný derleyiciye býrakmýþ oluruz.
		
		range based for loop for(char c : s) //Burada c otomatik ömürlü bir nesnedir. ve burada sadece okuma amaçlý kullanabiliriz. Burada kopyalama olacaktýr.
							for(char &c :S )// Burada ise referans semantiði kullanalýcaktýr. herhangi bir kopyalama yoktur.
	
	- for(auto x :c) ile container'da tutulan öðede herhangi bir deðiþim söz konusu olmayacaktýr.
	  
	  for(const &x : C) ile öðenin yine kendisi ama sadece okuma amaçlý kullanýlýr.


	for (auto x : c)-> yi derleyici 
	for(auto iter = c.begin();iter != ivec.end(); ++iter){
		int temp = *iter;
		++iter þeklinde bir kod üretir.
    }
	// Ama bunun herhangi bir ek maaliyetini çok fazla olduðunu söyleyemeyiz. Derleyicinin optimize etmesinden dolayýdýr.
		
	- auto iter = find(svec.begin, svec.end(),"sinan"); find fonksiyonu bir range baþlangýcý, ve sonu ister. ve aranacak deðeri 3. parametre olarka alýr.
      geri dönüþ deðeri iterator cinsindendir.
	 
	- arama fonksiyonlarý
	
	- find fonksiyonlarý
		- hepsi member function'dýr. ilk parametresi ne aranacaðý. ikinci parametresi arama yapýlacak index
		- geri dönüþ deðeri size_type türündendir. eðer arama bulunursa index'i döndürür. bulunamazsa string::npos döndürür.
		 string s {"polat alemdar"};

		 auto idx = s.find('a');//3

		 auto idx = s.find('a', 4);//6
		 auto idx = s.find('a', 7);//11
	- string sýnýfý yazýnýn uzunluðundan fazla bir idx'i bir fonksiyona parametre olarak göndermek herhangi bir rte deðildir.legaldir.C++11 ile gelmiþtir.
	
		- rfind -> aramayý sondan baþlatýr.(12902)strchr ile strrchr gibi

		-find_first_of --> strpbrk gibi
		-find_first_not_of --> girilen karakterlerden biri olmayan ilk karakteri bulacak.
	bunlarýn tam tersi 
		- find_last_of aramaya sondan baþlayacaktýr.
		- find_last_not_of --> girilen karakterlerden biri olmayan aramaya sondan baþlayarak yapar.
		
		- str.sub_str(4,5) ilk parametre indeksi 2. parametre kaç tane karakter alacaðýný yazarýz. 
		- eðer fonksiyonun  2. parametre geçmez isek yazýnýn sonuna kadar alýr.
		- herhangi bir argüman göndermeden çaðýrýrsak c'deki strdup gibi yazýnýn bir kopyasýný elde etmiþ oluruz.
		
	
	- silme iþlemleri (erase fonksiyon);
		- erase(13025)
		- bütün container lar da olan erase fonksiyonu bir iterator alýp o iterator konumundaki nesneyi silebilir. containerinterface'idir.
		- str.erase(str.begin() +1 , str.end() - 1) ile ilk ve son harfi hariç hepsini siler.
		index parametreli fonksiyon
			- 1. parametreden baþlayarak 2. parametre kadar siler.
			- 2. parametreye argüman geçilmez ise 1. parametreden baþlayarak bütün yazýyý siler.
			- iterator girilerek(bütün container'lar için geçerlidir) o iterator daki nesne siler.
			- hiç bir argüman geçmez isek bütün yazýyý siler.	

	- insert fonksiyonlarý
		push_back ve appen fonksiyonlarý ile sona ekleme yapýlýrken, insert fonksiyonu ile herhangi bir yere atama yapabiliriz.

		- iki tane ayrý interface vardýr.(iterator ve index interface'leri)
		- index interface'i ile çalýþanlarýn yani index parametreli olanlarýn hepsinin geri dönüþ deðeri *this'dir.
		
		- iterator interface'i ile çalýþanlar index döndürür.

	- replace fonksiyonalarý
		- iki tane ayrý interface vardýr.(iterator ve index interface'leri)
		- index interface'i ile çalýþanlarýn yani index parametreli olanlarýn hepsinin geri dönüþ deðeri *this'dir.
---------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------07.01.2018 PAZAR--------------------------------------------------------------------
	
	- bir string sýnýfýndan nesneyi sadece okuma amaçlý kullanýrsak nesnenin adresinde herhangi bir deðiþiklik olmayacaktýr.
	
	- ama nesneye büyültme yada küçültme  iþlemleri yaparsak bunun adresinin ayný kalacaðý hakkýnda kesin bir bilgi veremeyiz.

	-  KARÞILAÞTIRMA OPERATÖRLERÝ

	- iki farklý karþýlaþtýrma þekli vardýr. 
		1-) operatör overlaoding ile gelen karþýlaþtýrma operatörleri
		2-) C tarzý strcmp 
	geri dönüþ deðerleri int türündendir.

	string s1{"bu yil kis gelmedi"};

	string s2{"burasi mecidiyekoy"};

	s1.compare(s1.size() -5, 5,s2,s2.size() -5,5);z

	- algoritmalar her zaman iterator fonksiyonlarý ile çaðýrýlýr.
	- iterator konum tutan bir nesneden baþka bir þey deðildir.

	- STL algoritmalarý hiç bir zaman bir container'a ekleme yada silme yapamaz. çünkü silme yada ekleme iþlemini sadece container sýnýfýnýn member function'a yaptýrabiliriz.

	- STL' deki silme algoritmalarý lojik silme iþlemi yapabilirler. remove erase idiom

	----------------------COMPOSITION---------------------

	- composition bir nesne'nin baþka bir nesneye sahip olmasýdýr.

	- composition yapmak için bir çok yol vardýr.
	
	- en fazla karþýmýza çýkan biçim bir sýnýfýn baþka bir sýnýf türünden öðeye sahip olmasý þeklindedir.
	
	- Ýngilizce de bu iliþkiye (has a) iliþkisi denir.
	
	- String sýnýfý en çok composition olan sýnýftýr.
	

	- bir sýnýfýn baþka bir sýnýf türünden nesne içermesi çok normal bir durumdur. composition ile sahip olunan nesnenin interface'ini ele almýyoruz.
	

	- access control:
	- scope
	- 

	- bir sýnýfýn non-static veri elemaný incomplete type olamaz. static veri elemaný içinse incomplete type olmasý yeterlidir.

	- bir sýnýfýn baþka bir sýnýf türünden nesnesi olmasý fiziksel olarak ta olduðu anlamýndadýr.(sizeof içerisindeki nesne kadar atar.)


	- baþka bir sýnýf türünden elemena sahip olmasý eleman olan sýnýfýn private yada protected bölümüne eriþim hakký yoktur.
	- Bir composition da private bölüm kapalýdýr.
	- Bir Car türünden x nesnesi hayata geldiðinde onun içindeki Engine türünden eng nesneside hayata geliyor. ilk hayata gelen eng nesnesidir.(13655)
	
	--------COMPOSITION AND INTERFACE--------

	- composition'da öðe olarak aldýðýmýz sýnýfýn interface'i öðe olarak aldýðýmýz sýnýfýn interface'i ile alakasý yoktur.
	- yani composition bir interface devralma iliþkisi deðildir.eðer böyle bir þey istiyorsak bu kalýtýmdýr.

---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------13.01.2018 CUMARTESÝ--------------------------------------------------------------------

	-------- COMPOSITION VE COPY CONSTRUCTOR ----------
	
	- class Engine{
	public:
		Engine() = default;// ileri de göreceðiz. 
		Engine(const Engine &c)
		{
			std::cout << "Engine::copy ctor" << std::endl;
			//Herhangi bir þekilde copy construct edildiðinde bu fonksiyon çaðýrýlacak.
		}
		
	};
	
	class Car{
		Engine e;
	public:
		// Car() = default;
		// Car(const Car &c){
			std::cout << "Car"
		}
	}

	int main(){
	Car c1;
	
	Car c2{c1}; //c2 için copy constructor yazýlacak. Ve Engine nesnesi için de copy constructor çaðýrýlacak.

	}

	- Bir nedenden dolayý sýnýfa yazýlan copy constructor için ayrýca default constructor'da çaðýrýlacaktýr.
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	class CrtptoTrader {
		std::string mname;
		Date mbdate;
	public:
		CrpytoTrader(const std::string &name,const Date &d) : mname{name}, mbdate{d}
		{}

		void display()const
		{
			std::cout << "(" << mname << ", " << mbdate << ")" << std::endl;
		}
	}

	int main(){
		CryptoTrader ctp{"lorem ipsum", Date{4,7,2002}};
		
		ctp.display();

		CryptoTrader ctp2{ctp};
	}

	- Bir sýnýnf için bir nedenden dolayý ctor yazýlýyor ise bütün öðeleri copy constructor etmek tamamen bizim sorumluluðumuzdadýr. Eðer
	  yapmaz isek derleyici diðer sýnýf nesneleri için default constructor'ý yapacaktýr. 

	- modern C++'da const char * istenen yerde mutlaka string kullaýlmalýdýr.

	- adres dönüþümleri hiç bir zaman static cast deðil reinterpret cast'tir.
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------14.01.2018 PAZAR--------------------------------------------------------------------
	
	- hiç bir constructor bildirmemek 6 tane özel fonksiyonu derleyiciye havale etmektir.
	
	- Bir fonksiyona yazma görevi derleyiciye havale etmiþ ve derleyici bu fonksiyona çaðýrmasý geçersiz sayýlýyorsa 
	  derleyici bu fonksiyonu deleted olarak kabul eder.
	
	-   class A{
			A();
		} 

		class B{
		public:
			B();
		}

		int main(){
			B bx;//attempting to deleted function. yukarýdaki duruma örnektir.
			// Bu sadece olabilecek örneklerden biridir.
		}
	
	- derleyicinin yazmasý gereken kopyalayan fonksiyonlar, deleted olma durumuna düþerse move member not declared(hiç bildirilmemiþ olarak)
	  ele alýnýr.
	
	- bir sýnýfýn taþýyan kurucu iþlevi yok ise onun yerine copy constructor çaðýrýlacaktýr.
	
	- sýnýflarýn her zaman olmasý gereken bir fonksiyonu copy ctor ve copy assingment'týr.

	- bir sýnýfa move ctor yazmak istersek her bir member için de move fonksiyonu çaðrýlmalýdýr.

	---------- 2. Bölüm için Önemli konular-----------

	1-) Kalýtým(10'a yakýn alt baþlýðý var)
	2-) Exception Handling(olaðan dýþý durumlarýn iþlenmesi)
	3-) Ýsim alanlarý(Namespace)
	4-) Dinamik ömürlü nesneler
	5-) Þablonlar(Templates)
	6-) Lambdalar
	7-) STL
	8-) Giriþ çýkýþ iþlemleri(belleðe, dosyaya, formatlý ve formatsýz okuma)
	9-) Uygulama pratiðinde önem taþýyan STL'in sýnýflarý

	---------- KALITIM(INHERITANCE) ----------

	- nesne yönelimli programlamanýn olmazsa olmaz bir aracýdýr.

	Not :
		- Bir sýnýfýn veri elemaný pointer ise copy ctor ve copy assignment'ý yazmalýyýz. eðer unique_ptr kullanmazsak.
		- eðer sýnýfýmýzýn öðesini baþka bir sýnýf türünden yapmýþ olursak	

		- template <typename T>
		  void func(T) = delete;

		  void func(int);
	
		- Bir fonksiyon þablonu ile ayný isimli bir fonksiyon var ise exact match olduðu durumlarda derleyici þablondan herhangi bir fonksiyon
		  kodu üretmez.
	
	- is a relation : bir sýnýfýn, baþka bir sýnýfýn tamamen interface'ini kullanmaya denir. 

		class Engine{
		public:
			void start();
		}

		class Car{
			Engine eng;
		public:
		}

		int main(){
		Car a2;
		a2.start();// kalýtým tam olarak böyle bir kullaným örneðidir.
		}

	- eðer interface'i kontrollü olarak ele almak istiyorsak bunu composition denir.

	- kalýtým da ise interface'i tamamen ele almamýz gerekecektir.

	- kalýtým 3 kategoriye ayrýlýr. (private in, protected in, public in)

	- protected ve private inheritance composition'a alternative'dir.(Bu ikisi daha sonra istenecektir.)

	- programlama dillerinde genel kalýtým C++'da public inheritancedýr.

	- multiple inheritance : 
		1-) çoklu kalýtým'dýr.
		2-) tek bir kalýtým iþlemi birden fazla sýnýfýn interface'ini devralma iþlemidir. Gerekirse bu interface'i geniþletecek yeni bir sýnýf türütmektir.



---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------20.01.2018 CUMARTESÝ--------------------------------------------------------------------

	- kalýtým : 
		1-) 1. amacý eskiden olan kodlarýn bir daha kullanýlmasý deðildir.
		2-) Kod yazmayý çok daha kolay hale getirmektedir. Ayrýca eski kodlarýn yeni kodlarý kullanabiliyor olabilmesidir.
	
	- Kalýtým'da interface'i tamamen devralacaðýz.
	- Kalýtýmýn kullanýldýðý sýnýfa super class yada parent class denir. 
	- Kalýtým ile elde edeceðimiz sýnýfa sub class, yada child class denir.
	- C++'da kullanýlan terimler de parent class yerine Base class nedir. child class yerine de derived class denir.
	- Yani base class denildiði zaman is  a iliþkisi olmak zorunda deðildir.(public, protected - private(composition tarzý)).
	- Genelde kalýtým bir hiyerarþi sistemi üzerinde olacak.
	- Kullandýðýnýz programlama dili ne olursa olsun, base class'ýn member function'larý tipik olarak üç kategoriye ayrýlýr.
		1-) interface veren ve implementasyon verecek(Yani benim verdiðim interface'i ve implementasyonu kullanacak.)
		
		2-) interface veren ve default implementasyon veren(Yani beinm interface'i verecek ve implementasyon olarak kendi verdiði implementasyonu kullanýp kullanma
		    masý tamamen client'e baðlý olacaktýr.(overrride->ezmek))
	polyformic class : eðer bir sýnýfýn 2. kategoride bir sýnýfý varsa buna çok biçimli class denir. 
		
		3-) interface veriyor ama implementasyonu hiç vermiyor(Eðer parent class'tan kalýtým ile elde edilecek sýnýflar implementasyonu tamamen kendi yapacaktýr.)
			abstruct class->soyut sýnýftýr.
	
	- C++'da bir class ya soyut class'týr. Ya da somut class'dýr.
	- Sýnýflarýn protected bölümleri kendi client'lara kapalý ama o sýnýftn kalýtým yolu ile  elde edilmiþ sýnýflarýna açýktýr.
	
	
	- C++'da kalýtým sentaksý : 
		- kalýtým da super(base) class olarak kullanýlacak sýnýfýn mutlaka complete type olmalýdýr.
	
	- class Der : public Base {};(14568) --> burada public türetme sözcüðüdür. burada kullanýlan sözcüðe göre public, private, yada protected keyword'u inheritance'ý kullanýlmýtýr.
	
	- Hiç bir keyword kullanýlmaz ise default'u private inheritance'týr.(14581)

	- C'de ki struct'lar C++'da class'dýr. struct anahtar sözcüðü kullanýrsak default eriþim bölgesi public'tir.(struct Der : Base{})
	  struct anahtar sözcüðü ile kalýtým yapýlýrsa default'ý public inheritance'týr.
	- Yukarýdaki  özelliklerin aynýsý multiple inheritance içinde geçerlidir.

	- kalýtým da isim arama : 
		- immediate base class : doðrudan tabanlý bir sýnýf D sýnýfý C'den, C sýnýfý B'den, B sýnýfý A'dan türetilmiþtir. 
		  C sýnýfý D sýnýfý için base class'týr.
		
		- D sýnýfý türünden bir nesne için isim arama ilk olarak D sýnýfý içinde yapýlýr. D' de bulunamazsa C'de bulunamazsa B'de bulanamazsa 
		  A'da aranacaktýr.
		
		- türemiþ sýnýf nesneleri taban sýnýftaki bir nesneyi kullanabilir.
		
		- taban sýnýfýn ismi ile türemiþ sýnýfýn ismi ayný scope içinde deðildir. Yani doðrudan function overloading yoktur.
		- taban sýnýfýn ayný isimli fonjksiyonu ile türemiþ sýnýfýn ayný isimli fonksiyonu birbirini overload etmez.
		- class Base{
		public:
			void func(int);
		}
		class Der : public Base{
			void func();
		}

		int main(){
			Der myder;
			myder.func(23) // sentaks hatasý
		}

	- access kontrolü her zaman en sonda yapýlýr.

	- C++'da inheritance'da  function overload'ý yapabilme imkanýmýzý saðlayan using bildirimi aracý ile yapabiliriz.
	
	- üye fonksiyonunun içinde isim arama ise isim ilk önce blokta, aranan isim daha sonra kapsayan bloklarda eðer gene bulunamazsa
      türemiþ sýnýfýn içinde gene bulunamazsa taban sýnýflarda arayacaktýr.	
		
	- Fiziksel olarak kalýtýmda bir sýnýfýn içinde baþka bir sýnýf türünden nesne vardýr.
		class Base{
			int mx, my, mz;
		public:
		};
	
		class Der : public Base{
			int mx;
		public:
		
		};

		int main(){
			using namespace std;
			cout << "sizeof(Base) = "<< sizeof(Base) << endl;//8
			cout << "sizeof(Der) = "<< sizeof(Der) << endl;//12
		}

	- composition'da da ayný durum vardýr.
	
	- Böyle durumlarda composition söz konusu ise B sýnýfýnýn A türünden bir öðesi vardýr.(embedded object denir) 
	  A'nýn interface'i B'ye eklenmemiþtir.

	- Kalýtým söz konusu ise B sýnýfý A türünden türetilmiþtir.(base class object denir)
	  A'nýn interface'i B'ye eklenmiþtir.
	
	- Her zaman composition'ý kalýtýma tercih edin.

	- upcasting : yukarý doðru dönüþüm. türemiþ sýnýftan taban sýnýfa doðru yapýlacaktýr.

	- herhangi bir neden ile A'dan B'ye dönüþüm yapýlmak isteniyorsa down casting denir.

	- taban sýnýfýn private kýsmý her durumda diðer sýnýflara kapalýdýr. Herhangi bir þekilde kalýtým yapýlmýþ ise bile.
	
	- public kalýtýmýnda taban sýnýfýn  public interface'i tamamen bizim sýnýfýn interface'ine dahil edilmiþtir.

	class Base{
		void pri_func(){};
	public:
		void pub_func(){};
	protected:
		void pro_func(){};
	};

	class Der : public Base{
		public:
		void derfoo(){
		pro_func();
		pub_func();
		}
	};
	
	int main(){
		Der myder;
		myder.pub_func();
		myder.pro_func();//geçersiz
		myder.pri_func();//gecersiz
	}(14715)


	- Yani public kalýtým yoluyla elde edilmiþ bir sýnýf türü protected bölümüne eriþim vardýr. public kýsmýna zaten vardýr.
	  private kýsmýna zaten yoktur.
	- client'ler sadece türetilmiþ sýnýf türünden bir nesne ile sadece taban sýnýfýn public bölümüne eriþim yapýlabilir.
	- türetilmiþ sýnýf ise taban sýnýfýn protected bölümüne eriþim yapýlabilir.
	
	- bir kalýtým yolu ile türetilmiþ bir sýnýftan bir nesne ile taban sýnýfýndan bir nesneye atama yapýlabilir.referans yada pointer atamasý yapýlabilir.(upcasting.)(14751)

	- her ne kadar bu durum geçerli olsa da ileride anlayacaðýmýz nedenlerden taban sýnýfýndan bir nesneye doðrudan türemiþ sýnýf türünden bir nesneye atama istenen bir atama
	  deðildir.object sliding(nesne dilimlenmesi). hemen her zaman bu aktarýmlar pointer yada referans yoluyla yapýlýr.(mybase = myder//ama legal deðil)(14772
	  )

	- taban sýnýf nesnesinden türemiþ sýnýf nesnesi türüne aktarým doðrudan, pointer ve referans semantiði ile yasaklanmýþtýr.

	- türemiþ sýnýf nesnesi ile taban sýnýfýn bir fonksiyonu çaðýrýlýr ise derleyici türemiþ sýnýf nesnesinin içindeki taban sýnýf türünden nesnesinin
	  fonksiyonunu çaðýracaktýr.

	class Base{
		int mx, my;
	public:
		void setbase(int x, int y){
			mx = x, my = y;
		}
	};

	class Der : public Base{
		int ma;
	public:
	
	};
	
	int main(){
		Der myder;
		myder.setbase(); // ile Der nesnesi içindeki Base nesnesi'nin adresidir. setbase fonksiyon'a gelen this adresi de bu türemiþ sýnýf'ýnýn içinden taban 
		//nesnesi gelecektir.
	}

	- baseptr = derptr// ile derleyici baseptr'ye derptr'nin içindeki der nesnesinin adresini gösterecektir.

	- void carGame(Car * ptr); // ile burada Car *ptr yerine Car sýnýfý türünden türetilmiþ bir nesne de gönderilmiþtir.

	- ok operatoru yada nokta operatoru ile ilgili nesne'nin bir fonksiyonu çaðýrýlýrsa mutlaka isim arama o class scope'da aranacaktýr.(14845)

	---- Kalýtýmda özel iþlevlerin durumu----

	- eðer kalýtýmda olsa composition da olsa bir sýnýf nesnesi içinde baþka bir sýnýf vardýr.
	
	- önce taban sýnýf alt nesnesi hayata gelecektir. ondan sonra türemiþ sýnýfýn constructor'ý hayata gelecektir.
	
	- türemiþ sýnýf türünden bir nesne yapýldýðýnda iþi derleyiciye býrakma durumunda derleyici her zaman taban sýnýfýn constructor'ýna býracaktýr.(14911'den önceki örnek)

	-  eðer base sýnýfýnýn default constructor'ý yoksa Der sýnýfý türünden bir nesne oluþturulmasý sentaks hatasý olacktýr.(14911)

	- class Base{
	public:
		Base(){
		std::cout<<"Base::Base()"<< endl;
		}
		Base(int ){
		std::cout<<"Base::Base(int)"<< endl;
		}
		Base(double){
		std::cout<<"Base::Base(double)"<< endl;
		}
		Base(int, int ){
		std::cout<<"Base::Base(int, int)"<< endl;
		}
	};

	class DerA : public Base{
	//default ctor
	};
	class DerB : public Base{
		DerB() : Base(0)//int ctor
		{
		

		}
	};
	class DerC : public Base{
		DerC() : Base(1.)//double ctor
		{
		

		}
	};
	class DerD: public Base{
		DerD() : Base(1, 5)//double ctor
		{
		

		}
	};

	int main(){
		DerA x;// default ctor çaðrýldýr
		DerB x;// int param. ctor çaðrýldýr
		DerC x;// double param. ctor çaðrýldýr
		DerD x;// int, int param. ctor çaðrýldýr

	}

	- bir sýnýf nesnesinin hayatý bittiðinde onun içindeki taban sýnýfýnýn nesnesi de hayata bitecektir.
	- önce türemiþ sýnýf türünden sýnýfýn nesnesi hayatý bitecektir. sonra taban sýnýfýnýn ki bitecektir.
	- türemiþ sýnýfýn nesnesi destroy edildiðinde taban sýnýfýn alt nesnesini kullalýyor olabilir. 

	- önce taban sýnýf alt nesneleri sonra member'lar hayata gelecektir.
	---- copy ctor for inheritance----

	- eðer türemiþ sýnýf copy construct ile elde edilmiþ ise derleyici taban sýnýf için copy ctor'u çaðýrýr.
	- eðer türemiþ sýnýfýnýn copy ctor'ýný kendimiz yazýyor isek taban sýnýfýnýn copy ctor'ýný kendimiz yazmalýyýz.
	
	- eðer türemiþ sýnýfýn copy ctor'ý yazýlýp mil sentaksý kullanýlmamýþ ise taban sýnýf için default ctor çaðýrýlacaktýr.(15090)
	
	- eðer türemiþ sýnýfýn copy ctor'ý yazýlýp mil sentaksý kullanýlýr ise taban sýnýf için copy ctor çaðýrýlacaktýr.(15131)

	- eðer iki türemiþ sýnýfýndan biri hayatta ise ve biri diðerine atama yapýlýyorsa türemiþ sýnýf için ve taban sýnýf için atama operator fonksiyonu
	  çaðýrýlacak.
	
	- eðer türemiþ sýnýfýn copy assignment ctor'u yazýlmýþ ise taban sýnýf için atama iþlemi tamamen programcýnýn sorumluluðundadýr.()

	- derleyici hiç bir zaman atama operator fonksiyonlarýna kod eklemez.
	
	- derleyiciye taban nesnenin atama operator fonksiyonunu çaðýrma iþlemini programcý yaptýrmalýdýr.(15180, 15214)

---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------21.01.2018 PAZAR--------------------------------------------------------------------
	
	- Derleyicinin ürettiði kodda hangi sýnýfýn fonksiyonunun çaðýrýlacaðýnýn run time da belli olmasýdýr.Derleyicinin derleme zamanýnda
	  hangi kodun çalýþacaðýný bilmemesidir. runtime poliformizmi denilen özellik kabaca budur. 
	
	- Derleyici hangi fonksiyonun çaðýrýlacaðýný derleme  zamanýnda biliniyorsa erken yada statik baðlama, bilmiyorsa   geç ya da dinamik baðlamadýr.

	- virtual anahtar sözcüðü ile geç baðlama denilen olay gerçekleþir. Fonksiyona hangi sýnýf nesnesinin adresi geldiðini run time
	  da o sýnýfýn fonksiyonlarý çaðýrýr.

	- virtual anahtar sözcüðü : bir fonksiyonun bildirimin de taban sýnýf da virtual anahtar sözcüðünü ekleyerek  bunu kalýtýmýn ikinci kategorisini yapmýþ oluruz.(interface veren default implementasyon var.)

	- virtual void start(){
		//default implementasyon verilmiþtir. Taban sýnýfta olmalýdýr.
	}
	
	- taban sýnýfýnýn virtual anahtar sözcüðü ile bildirilen fonksiyonlarýna taban sýnýfýnýn sanal fonksiyonlarý denir.

	- C++'da base class'ýn fonksiyonlarýnýn kategorizasyonu þöyledir.
		class Base{
		public:
			void f1(); //1.kategori
			virtual void f2();//2. kategori. virutal function denir. ya f2'nin benim saðladýðým implementasyonu kabul edeceksin. yada yazýdðýmýz sýnýftaki fonksiyon ile bunu override edebiliriz.
			virutal void f3() = 0; //3. kategori. pure virutal function denir. Burada  override etmeye mecbur býrakýyordur.
		}
	
	- eðer taban sýnýftaki fonksiyon sanal fonksiyon ise eðer türemiþ sýnýftaki ayný parametrik yapýda ayný imza ya sahip bir fonkyion bildirilirse taban sýnýfýn fonksiyonunu  override(ezilimþ) edilmiþ olur.

	- eðer taban sýnýftaki sana lfonksiyondan farklý imzalý bir fonksiyon bildirirsek bu override yada function overload ile hiç bir alakasý yoktur. Ama legaldir.
	
	- eðer imzasý ayný olup geri dönüþ deðeri farklý bir fonksiyon bildirirsek bu sentaks hatasý olur.

	- ayný imza ayný geri dönüþ deðeri override etmek.
	- farklý imza ayný geri dönüþ deðeri yeni bir fonksiyon.
	- ayný imza farklý geri dönüþ deðeri sentaks hatasý.
	
	- bir taban sýnýf pointer'ý yada referansý yoluyla taban sýnýfýn sanal bir fonksiyonu çaðýrýldýðýnda sanallýk mekanizmasý devreye girer. run time'a yönelik bir mekanizmadýr.(15415)
	  
	- sanallýk mekanizmasýnýn devreye girebilmesi için çaðrýnýn mutlaka taban sýnýfýn  referansý yada pointerý yoluyla yapýlmasý gerekmektedir.(15460)

	- türemiþ sýnýf taban sýnýfýn sanal fonksiyonunu override ettiðinde ister virtual anahtar sözcüðü kullanýlmýþ olsun ister kullanýlmasýn türemiþ sýnýfýn fonkiyonu da sanaldýr.
	
	- class Base{
	public:
		virtual void func(int);
	}

	class Der : public Base{
	public:
		virtual void func(int);//burada virtual yazýlmasa bile bu fonksiyon sanal fonksiyondur.
	}

	class SDer : public Der{
	public:
		void func(int); // bu fonksiyon da Der fonksiyonun func fonksiyonunu override etmiþtir.
	}

	- virtual anahtar sözcüðü türemiþ sýnýflar için virtual anahtar sözcüðünü yazmama eylemi daha fazladýr.

	- 1. tipik hata seneryaso override edilmek istenirken yeni bir fonksiyon yazmýþtýr.

	- 2. tipik hata senaryosu taban sýnýfta sanal olmayan bir fonksiyonunu sanal zannedip override etmeye çalýþmaktýr.

	- 3. tipik hata ise taban sýnýfta yapýlan bir imza deðiþikliði bütün override deðiþikliði yapýlan fonksiyonlar düzenlenip yeniden derlenmelidir.

	- C++ 11 ile gelen override keywordu ile bu üç hataya da çözümü olmuþtýr.türetilmiþ sýnýflarda kullanýlýr.

	  class Car{
	  public:
		  virtual void collide(int);
	  }

	  class Mercedes : public Car{
	  public:
		  void collide(int)override;//
	  }
	 
	 - bir taban sýnýfýn sanal  fonksiyonu override ediyorsak  override sözcüðünü eklemenin hatalardan kaçýnmak için eklenmesi çok önemlidir .

	 - baðlamsal anahtar sözcük(context join keyword) : belirli bir baðlamda kullanýldýðýnda keyword özelliði taþýyan sözcüklerdir.override böyle bir keyword'dur.

	 - nesne yoluyla çaðrý yapýldýðýnda sanallýk mekanizmasý devreye girmez. Sanallýk mekanizmasýnýn özellikle devreye girmesini istemiyorsak çözünürlük operatörlüðü 
	   ile sanal fonksiyonu çaðrý yapmaktýr(15689).

	 - Bir kalýtým hiyerarþisin de her hangi bir kademe de bir fonksiyonu override edebiliriz.
		  
     - türemiþ sýnýf nesnesi taban sýnýfýn sanal olmayan bir üye fonksiyonu ile  sýnýfýn sanal olan bir üye fonksiyonunu çaðýrdýðý zaman  türemiþ sýnýf nesnesinin adresi ile çaðrýldýðý için
	   türemiþ sýnýfýn sanal fonksiyonunu çaðýrýlýr.Ama sýnýfýn sanal olmayan fonksiyonu ctor ise taban sýnýfýn sanal fonksiyonu çaðýrýlýr.
	   Bunun nedeni de taban sýnýfýn ctor'ý türetilmiþ sýnýftan daha önce hayata geldiðinden dolayýdýr. 
	 
	 - C++'da ctor içinde yapýlan sanallýk mekanizmasýný devreye sokacak çaðrýlar sanallýk mekanizmasýný tetiklemez. nedeni ise türemiþ sýnýfýn nesnesi hayata gelmeden türemiþ sýnýf nesnesinin 
	 override'ý türemiþ sýnýfýn nesneleri hayata gelmeden  onlarý kullanarak rte'ye neden olacaðýndýr.
	 - bu destructor için de geçerlidir. nedeni de türemiþ sýnýf nesnesinin sanal fonksiyonu taban sýnýfýn nesnelerini kullanabileceðinden dolayýdýr. Buda rte'ye neden olur
	 
	 - sanallýk mekanizmasý tamamen non-satic member function'larý için geçerlidir.

	 ------Sanallýk mekanizmasýnýn devreye girmediði yerler

	 1-) Sanal iþleve çaðrý taban sýnýf nesnesi ile yapýlýrsa(object sliding)
	 2-) Sanal iþleve çaðrý çözünürlük operatörü ile yapýlýrsa
	 3-) Sanal iþleve çaðrý taban  sýnýf ctor'u  içinde yapýlýrsa
	 4-) Sanal iþleve çaðrý taban sýnýf destructor'ý içinde yapýlýrsa

	 - ctor hariç sýnýfýn non-static üye fonksiyonlarý  sanal olabilir.

	 - hangi türden nesnenin hayata gelmesi gerektiðini run time'da belirli olmasý durumunda (15830)

	 - clone idiom or virtual ctor idiom: taban sýnýfýn bir sanal fonksiyonu ile hangi türden nesne gelirse o türden dinamik bir nesne oluþturmaktýr.

	- #include <string> 
	 class Car{
		std::string m_color;
		int m_age;
	public:
		Car(const std::string &color, int age): m_color{color}, m_age{age}
		{}
		virtual Car *clone() = 0; // implementasyon verilmeyecek.
		virtual void *speed()const = 0;
		void display()const
		{
			std::cout << "renk : " << m_color << std::endl;
			std::cout << "yas : " << m_age << std::endl;

		}

	 };
	class Bmw : public Car{
	public:
		Bmw(const std::string &color, int age): Car::{color, age}
		{}
		Car *clone()override
		{
			return new Bmw{*this};
		}

	 };
	class Mercedes: public Car{
	public:
		Mercedes(const std::string &color, int age): Car::{color, age}
		{}
		Car *clone()override
		{
			return new Mercedes{*this};
		}

	 };	   	   
	class Volvo: public Car{
	public:
		Volvo(const std::string &color, int age): Car::{color, age}
		{}
		Car *clone()override
		{
			return new Volvo{*this};
		}

	 };()

	- davranýþa esas tür dinmaik tür, 

	- bir sanal fonksiyonu sýnýfýn private bölümünde override etmenin herhangi bir access kontrolü içermez.(dinamik türler için)

	-  varsayýlan argüman kontrolü tamamen statik türe göre yapýlýr.

	- access kontrolü her zaman statik türe göre yapýlýr.(15914)

	- typeid operatoru hem dinamik türe göre hemde statik türe göre çalýþýr.
	- polyformic bir tür ise dinamik türe göre deðilse statik türe göre çaðýrýlýr.

	- bir türün polyformic tür olmasý için ya kendisinin  en az bir sanal fonksiyonu yada bir baþka türden kalýtým yolu elde edilmiþ bir sýnýf olmasý gerekir.


---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------27.01.2018 CUMARTESÝ--------------------------------------------------------------------
	
	- Bir sýnýfýn en az bir tane saf sanal fonksiyonu varsa, yada abstract bir sýnýftan kalýtým yoluyla edecek ya da taban sýnýf olarak kullanýlan sýnýftan en az bir abstract fonksiyonunu override etmeyecek
	  böyle sýnýflara abstract class(soyut sýnýf) denir. Bunlar polyformic iþlemlerde kullanýlýrken bu sýnýf türünden  nesne tanýmlanamýyor. 
	
	- statik yada global fonksiyonlar doðrudan override etmenin bir aracý yoktur.
	
	- operator fonksiyonunun, constructor'ýn sanal olmasýna sentaks izin vermez. Ama sanal constructora ihtiyaç çok fazladýr.

	- destructor sanal bir fonksiyon olabilir. Ve bir kalýtým hiyerarþisinde çoðu zaman kullanýlýr.

	- bir sýnýf türünden nesne oluþturmaya instantiate denir.
	
	- kalýtým da istisnasýz bütün sanal fonksiyonlarý override etmesi gerekmektedir. Yoksa türemiþ sýnýf abstract sýnýf olur. Sadece o türden pointer yada referans tanýmlayabiliriz.

	- polymorfic olmayan sýnýflarda sýnýf nesnesinin sizeof'u öðelerinin sizeof'una eþittir. polymorfic sýnýflarda  4 byte kadar fazladýr.

	- virtual table pointer : Bir polyformic sýnýf nesnesinin hangi türden olduðunu gösteren pointer'dýr.

	- (carptr->vfunc()); 
		1-) derleyici burada ilk baþta vfunc() statik tür mü deðil mi kontrolü yapýyor.
		2-) sanal fonksiyonu olduðunu anlarsa bu fonksiyonun adresinden bir index elde ediyor.
	
	- virtual destructor : ctor sanal olamazken destructor sanal olabilir.	
		
	- Sanallýk mekanizmasýnýn devreye girebilmesi için bir referans ya da pointer gerekmektedir.

	- elimizde bir taban sýnýf pointer'ý yada referansý varsa, taban sýnýf pointer'ý yada referans'ý yoluyla bir sanal fonksiyon çaðýrýlýr ise
	  sanallýk mekanizmasý devreye girer.

	- runtime polymorphismminde türemiþ sýnýf nesnelerine taban sýnýf pointer'ý ile manipüle ederiz.

	- Dinamik bir türemiþ sýnýf nesnesini taban sýnýfýyla kontrol edersek sanal destroctur burada gereklidir.

	- delete operatoru ile sýnýfýn statik türüne iliþkin destructor çaðýrýlýr.

	- eðer  polyformic davranýþ gösterecek bir sýnýf hiyerarþisi var ise  destructor'ýný sanal yapmamýz gerekir.

	- derleyici delete ifadesinde kullanýlan adres taban türünden ise burada hangi sýnýfýn destructor'ýnýn çaðýrýlacaðýný taban sýnýfýn pointer yada refereansýnýn
	  gösterdiði nesneye göre belirli olacaktýr. Buda run time da belirli olur.

	- eðer destructor sanal deðilse pointer'ýn statik türü ne ise her zaman  o destructor'ý çaðýracaktýr. Eðer dinamik türün destructor'ýný çaðýrmak istiyorsak mutlaka 
	  destructor'ý sanal yapmamýz gerekir.

    - eðer polyformic bir hiyerarþi gösterecek sýnýf var ise destructor'ý mutlaka sanal yapýlmalýdýr.

	- eðer bir sýnýfýn destructor'ý sanal yapýlmýþ ise dökümantasyonuna bakýlmaksýzýn polyformic bir yapý için yazýlmýþ bir sýnýftýr.

	- Bir sýnýfýn kalýtým için oluþturulduðunu sýnýfýn protected bölümünü olmasýndan(olmak zorunda deðil), yada destructor'ýn sanal olduðundan anlayabiliriz.

	- 

	- taban sýnýfýn protected bölümünü kendi public bölümümüze using bildirimi ile katabiliriz. ama private için bu geçerli deðildir.

	- final keyword : Kalýtým hiyerarþisi içinde kalýtým yolu elde edilmiþ sýnýftan artýk yeni bir sýnýfý kalýtým yolu elde etmeyeceðimiz
	  için kullanýlýr.
	
	- iki farklý kullanýmý var :
		1-) sýnýfýn kendisini final yapmak : bu sýnýftan bir daha kalýtým ile baþka bir sýnýf elde edilemeyeceði 
		2-) sýnýfýn sanal fonksiyonunu final yapmak : final yapýlan fonksiyonun bir daha override edilemeyeceðini gösterir.
	
	- sentaksý  
		1-) sýnýf için ---> class Der final: public Base {}();
		2-) sanal fonksiyon için ---> void func() final override;
	
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------28.01.2018 PAZAR--------------------------------------------------------------------
	
	
----------- multiple inheritance -----------
	
	- Birden çok sýnýftan kalýtým yoluyla elde edilmiþ bir sýnýf durumudur.
	
		class Base1{
		public:
			void func1();
			void foo1();
			void g1();
		}
		class Base2{
		public:
			void func2();
			void foo2();
			void g2();
		}

		class Der : public Base1, public Base2{
	
		};
	
	-  taban sýnýfýn private bölümü her zaman türemiþ sýnýflara da kapalýdýr.

	-  taban sýnýf alt nesneleri kalýtýmda belirttiðimiz sýra ile hayata gelecektir.

	- çoklu türetmede isim arama ilk baþta class türünden nesne içinde alýnýr. çoklu türetme de fonksiyonlar için sýnýf niteleyecisini
	  kullanmalýyýz.
	
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------03.02.2018 CUMARTESÝ--------------------------------------------------------------------
	
	- Normalde bir türemiþ sýnýf nesnesinin sadece directive base class'ýný construct edebiliriz. indirect base class'ýný construct etmek sentaks hatasýdýr.
	
	- Bu durumun bir istisnasý vardýr.Sýnýfýn çoklu türetmesi ile ilgilidir. Yani sanal türetmeden kaynaklýdýr.
	
	- Böyle bir durumda En alttaki sýnýf(Yani en türemiþ sýnýf). En yüksekteki(türetilmenin yapýldýðý ilk base class)'ý initialize etmelidir.

	- Bu durum default constructor olmadýðý durumunda gerçekleþir.
	
	------ exception handling -------

	- run time da program çalýþýrken programýn iþini yapmasýný engelleyen bazý durumlarýn oluþmasýnda bu durumlarýn ele alýnmasýna exception handling denir.

	- programýn kaynak kodundan kaynaklanmayan, çalýþma zamanýnda  beklenmedik bir hata  nedeniyle oluþmasý durumundadýr.

	- hataya karar verilmesi tamamen projenin baþýnda karar verilmelidir.

	- throw statement --> Hatayý tespit eden kodun daha yukarýdaki kodlara bir nesne hazýrlayýp bunu göndermesi
	
	- hataya müdahele edecek kodlarýn bu blok içinde çalýþacak kodlar bir hata nesnesi gönderilirse ben hatayý yakalamaya hazýrým anlamýndadýr.

	- eðer bir hata nesnesi gönderilip  yakalanmaz ise program'ý sonlandýrýlýr.(C'deki abort gibi)

	- eðer programý devama zorlayacak isek bütün hata nesnelerini yakalamak zorundayýz.

	- exception safe: run time da ne olursa olsun programýn çalýþmaya devam etmesidir.

	- C++'da exception safety'yi saðlamak çok daha zordur(C#, Java gibi dillere göre).

	- throw exp; return'e çok benzemektedir.

	- tek baþýna throw ile oluþturulan statement'ta vardýr. throw; þeklindedir. bu özel bir durumdur.

	- throw ifadesi olarak bir nesne kullanýlýrsak derleyici bu nesneden bir temporary object üretir.

	- hata nesnesinin türü hatanýn ne olduðu konusunda bilgi verir. örneðin her 0'a bölme hatasý bir matematiksel hatadýr.

	- hata nesnesinde kullanýlan sýnýflar ayrý bir hiyerarþisindedir.

	- throw MathError{}; 

	 void f4(int x){
		cout << "f4 cagrildi" << endl;
		if(x > 10)
			throw 2.3; // derleyici double'türden bir hata nesnesi oluþturup bu nesneye 2.3 ile ilk deðer verecek.
		 cout << "f4 sona erdi" << endl;
	 }

	- uncaught exception : Herhangi bir hata nesnesi yakalanmamasý durumudur. abort fonksiyonu çaðýrýlacaktýr. 

	- Hatayý yakalamak C++ için çok önemli bir olaydýr.

	 void f4(int x){
		cout << "f4 cagrildi" << endl;
		if(x > 10)
			throw out_of_range; // C++'ýn 
		 cout << "f4 sona erdi" << endl;
	 }

	 try block : hatayý yakalamaya aday blok
	 catch block: hatayý iþleyen blok


	 void f4(int x){
		cout << "f4 cagrildi" << endl;
		if(x > 10)
			throw out_of_range; // 
			cout << "f4 sona erdi" << endl;
	 }
	
	try {
		f4(47);
	}
	catch(int){ 
		//Gönderilen hata nesnesinin türü ile catch bloðunun paremetresi ayný ise buraya girecektir.
			
	}

	- try bloðunu zorunlu olarak minimal bir catch bloðu izlemelidir. burada catch bloðu olmaz ise sentaks hatasýdýr.
	- catch bloðunun bir tane catch parametresi olmalýdýr.

	void f4(int x){
		cout << "f4 cagrildi" << endl;
		if(x > 10)
			throw out_of_range; // 
			cout << "f4 sona erdi" << endl;
	 }
	
	int main(){
		try {
			f4(47);
		}
		catch(int x ){ 
			cout << "hata main islevi icinde yakalandi x = " << x << endl; //throw ifadesinin deðeri burada x nesnesi ile aynýdýr.	
		}
	}

	- Gönderilen hata nesnesinin bir catch tarafýndan yakalanmasý isteniyorsa mutlaka parametre ile nesnenin deðeri aynyý olmalýdýr.
	  Tek istisnasý runtime polymorphismin'den dolayýdýr.
	
	- özel bir catch bloðu vardýr. Hangi türden nesne gönderilirse gönderilsin yakalanmasý içindir.ellipses atomu kulalnýlýr.(catch all)

	- syntaksý (17376)
	catch(...){
		
	}

	- eðer birden fazla catch bloðu var ise bunun tümevarým þeklinde yazmalýyýz.(özelden genele)

	- main'in tamamýný try bloðu içerisine alýnmasý durumunda bile global nesnelerin hatasýný yakalayamayýz.

	- exception handling neden kullanýlmaz
		1-) Gerek olmadýðýndan dolayýdýr.
		2-) O kadar kritiktir ki exception throw'a haracayacak kaynaðý yoktur.
		3-) programýn sadece kendi içindeki çalýþan kodlara yöneliktir.asynchrn programlarda kullanýlmaz.
	
	- Çok sayýda kullanýlan kütüphanelerde kullanýlýr.
	

--- exception yakalandiðinda neler yapabiliriz ---
		
--- stack unwinding!!! ---
	- Exception mekanizmasýnýn en önemli mekanizmalarýndan biridir.
	- stack unwinding denilen mekanizma ile hatayý gönderen kod ile hatayý iþleyecek kod arasýndaki bütün nesneler stack edilirler.(Yani hayatlarý son bulurlar)

Not : Rai object --> constructor'î ile kaynak elde edilmiþ destructor'ý ile kaynaklar geri verilen nesnelerdir.
	
	- hata nesnesi yakalanmaz ise  nesneler'in hayatýna son verilmez.
	
	- hata nesnesinin yakalanmasý durumunda catch bloðunun içine girilmeden bu nesnelerin hayatý son bulur.
	- Bu özellikle Sýnýf türünden nesneler için çok önemli bir mekanizmadýr.

	- C++'da dinamik nesneler için stack unwinding mekanizmasý  normal pointer kullanýldýðý zaman devreye girmez.
	- Eðer akýllý pointer kullanýlýr ise stack unwinding mekanizmasý devreye girer.
	
	-  


--- rethrow iþlemi ---
--- constructors & exceptions ---
--- destructors & exceptions ---
--- standard exception hiyerarþisi ---
--- operator seviyesindeki exceptionlar ---

-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------04.02.2018 PAZAR--------------------------------------------------------------------
	
	- rehtrow etmek ile ayný hata nesnesini göndermek arasýnda ciddi fark vardýr.
	- rethrow ettiðinde ayný dinamik tür korunurken , ayný hata nesnesini gönderirken derleyici copy constructor çaðýrýp geçiçi nesne üretirken
	  kendi hata nesnesini destructor edip, geçici nesneyi gönderir.
		  
	- rethrow etmek yerine ayný nesneyi gönderirsek derleyici copy constructor ile oluþturduðu geçici nesneyi throw eder.
      tipik olarak böyle bir ihtiyaç yoktur.
	
---- constructors & exceptions ----
	
	- en fazla exception gönderme ihtiyacý olan durumlardan biri constructor'lar için geçerlidir.

	- yani bir constructor'dam exception göndermenin en fazla ihtiyacý olduðu yerdir.

	- bir constructor'ýn kodunun içinden exception yolu ile çýkýlýrsa nesne  hayata gelemez. 
	  ve hayata gelememiþ nesne için kesinlikle destructor çaðrýlmayacaktýr.
	
	- dinamik bir nesnenin constructor'ýnda exception throw edilirse nesne için  bellek alanýnda yer ayrýldýðýndan dolayý bu nesne için ayrýlan yer destructor çaðýrýlmamasýna raðmen
	  bu bellek bloðu geri verilecektir. Derleyici bu bellek bloðunu geri verileceðini garanti eder.(17920)
	
	- ama constructor'da throw edilmeden önce herhangi bir kaynak elde edilmesi gerekiyorsa bu kaynaklarýn geri verilmesi tamamen bizim sorumluluðumuzdadýr.
	
	- Bunlarý delete etmek istyorsak throw edilmeden önceden kaynaklarý geri verilmesi gerekmektedir.
	
	- Böyle durumlarda normal pointer yerine smart pointer kullanmamýz bizim çok önemlidir.

	- constructor'dan exception gönderme konusunda herhangi bir tereddüte gerek yoktur.
	
	- function try block :  bir sýnýfýn member'larýn gönderdiði exception'ý ona sahip olan sýnýfýn yakalamasýnýn tek yolu bu þekildedir.
	- Asýl bulunma amacý member'larýndan biri sýnýf olan ve bu memberýn constructor'ýnda throw etmesinden dolayýdýr.
	- bir fonksiyonun bütün kodunu try bloðu içine almamýzý saðlar. Fonksiyonun ana bloðu ile try bloðu tamamen aynýdýr.
	- void func()
	  try{
	  
	  
	  }
	  catch(int){
		
	  }

	- constructor için sentaksý ise 
		Owner(int val) try : mx{val}//önemli nokta bu satýrdýr.
		{
		}
		catch(int x){
			cout << "hata Owner ctor içinde yakalandi...." << endl;
			throw;
		}()
	
---- destructors & exceptions ----
	
	- Destructor kesinlikle dýþarýya exception göndermemelidir.
	- Destructor'ýn exception gönderme ihtimali çok azdýr.
	- standart kütüphane'nin hiç birinin destructor'ý exception göndermez. 
	no except  keywordu : exception göndermediðini anlamýna gelir.
//////////////////////////////////////////////////////////////////////////////////////////////////////////
	
------- R.T.T.I(run time type identification) -------
	
	- bir nesnenin dinamik türünün runtime da check etmeye yönelik araçlar vardýr.
		1-) dynamic_cast // operator 
		2-) typeid ----> //operator
		3-) 
	
	- dynamic_cast operatoru :
		dynamic_cast<Target Type>(operand)
		dynamic_cast<Audi *>(carptr) --> Audi *'a dönüþüm yapýlmýþ.
	
	- tamamen down_cast ile alakalýdýr.
	- 


	---- namespace ----
	
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------10.02.2018 CUMARTESÝ--------------------------------------------------------------------

----R.T.T.I------(run time type identification);
	
	- dynamic cast operatoru : programýn çalýþma zamanýnda bir down casting'in güvenli yapýlýp yapýlamayacaðýný belirtir.
	- dynamic cast operatörünün operandý mutlaka polymorfic bir türlü olmalýdýr.
	- scope linkage durumunu engellemek için if 'in içinde bildirmeyi mümkün kulan durumlar vardýr.Sadece lojik sorgulamalar için kullanýlýr.
		if(Der1 *der1ptr = dynamic_cast<Der1 *>(baseptr)
			der1ptr->f3();	
	- 2017 ile birlikte if deyimine yeni bir sentaks eklediler.Yeni sentaks ile birlikte sadece lojik sorgulamalar için deðil tüm durumlar için geçerli bir hal kýlmasýný saðlamýþtýr.
		if(int retval = func(); retval %5 == 0) þeklindedir.
	
--- dynamic_cast on reference -----
	- dynamic_cast referans üzerinden yapýldýðýnda baþarýsýzlýk durumunda bad_cast sýnýfý türünden exception gönderecektir.
	
-- type.id operatoru --
	- sentaksý typeid(exp) þeklindedir.
	
	- bu ifade derleyicinin oluþturduðu kod ile bir sýnýf türünden bir nesneye referanstýr..Bu sýnýfýn ismi type_info'dur. Bu reference const bir reference'týr. typeid(exp)-->typeinfo x; const typeinfo &r = x;

	- type_info sýnýfý türünden bir nesne oluþturma imkaný yoktur.(default yada copy construcotr'ý yaktýr.)

	- derleyicinin yazdýðý sýnýf
		class type_info{
		public:
			type_info(const type_info &) = delete;
		}
	
	- bu nedenle client tarafýndan bir nesne oluþturulma imkaný yoktur.oluþturulmanýn tek yönü typeid operatörüdür.

	- typeid operatörünün sizeof ile benzer bir yaný daha vardýr. Oda sizeof'daki gibi içerisine tür bilgisi verebiliriz. typeid(int) þeklinde.

	- operandý olan ifade ile gerçekleþmez. gene sizeof gibi

	- typeid'nin operandýnýn bir polymorfic bir tür olma zorunluluðu yoktur.

	- Bu geri dönüþ yazýsý tamamen derleyiciye göre deðiþmektedir.

	- typeid de runtime'a yönelik bir fonksiyon olduðu için 

	- iki sýnýfýn ayný sýnýf hiyerarþi içinde olup olmadýðýný static_cast ile yapabiliriz. eðer static_cast ile dönüþüm legal ise ayný hiyerarþidir.

	
-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------11.02.2018 PAZAR------------------------------------------------------------------------

----- namespace -------
	- global isim alanlarýdaki birbirinden gizlemek yani çakýþmasýný engellemek için kullanýlan bir mekanizmadýr.
	- Bir kütüphanennin isimlerini taþýyan bir container'dýr.
	
	- namespace bir keyword'dur. C++'ýn standart kütüphanesi std namespace'i içindedir.
	
	- napespace Neco {
		// içinde deðiþkenin, fonksiyonun,sýnýfýn tanýmý veya bildirimi bulunabilir.
	} sentaksý bu þekildedir. Noktalý virgül kullanýlmaz. Kullanýlýrsa bir sentaks hatasý deðil null statement olur.
	
	- nested namespace imkaný da vardýr.
	
	- C++'ýn standart kütüphanesinde de nested namespace'i olabilir.
	
	- namespace bir scope'tur. yani namespace içindeki isimlerde birbirinden ayrý olmalýdýr.
	
	- derleyici bir namespace tanýmý üzerinden geçtikten sonra ayný isimden bir namespace tanýmý daha görürse bunlarý birleþtirir. Bunun nedeni birden çok baþlýk dosyasý ekleme durumunda olur.
	
	- namespace içindeki isimlerin kullanýmý konusunda access control diye bir þey yoktur. Yani private protected public bölümü yoktur.

	- Bir ismi bir namespace içerisinde aratmak için çözünürlük operatörü kullanýlýr. (Omer::x;)

	- derleyici namespace ismini de bulmaya çalýþacaktýr.
	
	- std::cout << "lorem ipsum"; eðer iostrem baþlýk dosyasý eklenmeden aramaya çalýþýlýrsa std namespace'ini bulamadýðý için sentaks hatasý verir.(bulunmadýðý durumda kodun doðru çalýþmasý standart olarak belirlenmiþtir.)

	- namespace Neco {
		int x, y, z;
	}

	int main(){
		Neco::x = 12; 
	}
 
	- namespace içindeki ismi, namespace'i nitelemeden kullanmaya yöenelik araçlar baþlýk dosyasý içinde kullanýlmamalýdýr.

	- bir namespace içindeki ismi, namespace ismi ile  nitelemeden kullanmaya yönelik 3 araç vardýr  
		1-) using declaration 
		2-) using namespace 
		3-) ADL(Argument dependant lookup) veya Koenig Lookup
	
	- namespace Neco{
		int x = 10;
		class Myclass{
		
		};
	  }
	using Neco::x;
	int main(){
		x =	12 // dersek Neco namespace'i içinde kullanabiliriz. 
	}

	- using Neco::x using bildirimlerinin'de scope'u vardýr. yani using bildirimini bir fonksiyon içinde yaparsak scope'u sadece
	  o using bildirimini sadece fonksiyonu içinde o namespace ait ismi nitelemeden kullanabiliriz.(18748)
	
	- using bildirimi ile tanýtýlan isin o anki yapýlan yere o ismi oraya tanýmlamýþ gibi oluruz. o isimden ayný isim ile baþka bir deðiþken tanýmlayamayýz.(18772)

	- using bildirimi ile tanýtýlan bir program içinde isimler farklý scope'taki isimler gene birbirini gizleyebilir.

	- using Neco::x, Neco::y gibi bir sentaks hatasý yoktur.

	- birden fazla ismi isim alanýna enjekte etmek istiyorsak her birini ayrý ayrý yapmalýyýz.(18835)

	- namespace'ler her zaman global'dir. Namespace içindeki bildirimlerin hepsi de global alandýdýr.

	- using namespace bildirimi ile using bildirimi arasýnda fark vardýr.
		1-) bu bildirinde bir scope vardýr. týpki using bildirimindeki gibi
		2-) using namespace bildirimi isim alana enjekte etmemektedir.(18857)
		3-) Tek bir isim için deðil sýnýf içindeki bütün isimleri dahil ediyor.
	- namespace Neco{
	int x = 10;
	class Myclass{
		
		};
		}
	using namespace Neco;
	
	int x = 548; //geçerlidir.
	
	- Ama burada bir kod x'i kullandýðýnda ambigiouty hatasý verir(18857, 18876)
Not : Bazý durumlarda özellikle namespace bildirimini yapmayýz.
	
	- using bildirimi ne kadar dar olursa her zaman daha iyidir.

----- ADL(Argumant dependant lookup)------

	- ADL eðer bir fonksiyona gönderilen argümanlardan herhangi biri bir namespace içindeki user-defined türden ise
	  bu fonksiyonun ismi normal aramanýn dýþýnda bu namespace içinde de aranacaktýr.(19001)
	
	- std::cout << s;
	
	- operator<<(std::cout, s); // operator << 'i std sýnýfý içinde bulur eðer ADL olmaz ise std::operator<<(std::cout, s);
	
	- bir isim normal olarak görülürken bir baþka isim ADL ile görülür ise bu iki isim seçicilik yoktur.
	  ismin ADL ile bulunmasý o isim için bir ayrýcalýk olmamaktadýr.

		- namespace Huso {
			class Myclass(){};
			void func(Myclass &){}

		}
		void func(Huso::Myclass &){}

		int main(){
			Huso::Myclass m;
			- eðer sýnýfýn içindeki fonksiyon yorum satýrýna alýnýrsa derleyici global func fonksiyonuna çaðýrýlýr.
			- eðer global alandaki fonksiyon yorum satýrýna alýnýrsa derleyici Huso sýnýfý içindeki func fonksiyonuna çaðýrýlýr.
			- ikiside açýk olursa derleyici ambiguity hatasý verir.(19030)

		}
	
	- farklý sýnýflarýn using namespace bildirimi ile function overloading oluþturur.

	- user-defined türlere iliþkin giriþ yada çýkýþ iþlemlerine iliþkin fonksiyonlar o türün  baþlýk dosyasnda olmalýdýr.

---- unnamed namespace(isimsiz isim alaný) ----
	- sentaksý 
		namespace {
			int x,y;
			// buraya sýnýf yada  fonksiyonlar da koyabiliriz.
		}
	þeklindedir.
	
	- Bunlar C'deki statik global deðiþkenler gibidir. Yani dýþarý modüllere kapalýdýr.

	- namespace'in kendi ismi de çakýþma riski vardýr.(çok küçük bir ihtimal)
		- dilin buna yönelik bir aracýda vardýr. 
		- sentaksý 
			namespace Lorem = CSD_Project_ Group;(19091)
	-Ýsim alanlarýnýn nested olmasý durumunda da bunun bir avantajý vardýr.(19111)
	
-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------17.02.2018 CUMARTESÝ------------------------------------------------------------------------
	
	- fonksiyon þablonlarýnda genel sentaks þudur.
	template <typename T>
	void Swap(T &r1, T &r2){
		T temp{r1};
		r1 = r2;
		r2 = temp;
	}
	- swap fonksiyonlarý için gönderilen parametrelere  göre derleyici compile time da kod üretir.
	
	- þablonlar üzeirnde derleyici üç farklý kontrol yapar.
		1-) Derleyici kendi þablon sentaksýný kontrol eder.
		2-) 
		3-) 

	- template argumant deduction : derleyicinin bir template söz konusu olduðunda fonksiyon çaðrýsý ifadesine bakarak , 
	  fonksiyonun yazýlacaðý þablonun parametrelerinin ne olacaðýný anlama sürecidir.
	
	- derleyici 1. error senaryosunda template parametrenin türünü çýkarým yapamadýðýndan dolayý hata verecektir.
		template <typename T>
		T func(){
			return 1;
		}

		int main(){
			func();//error
		}
	
	- derleyici þablonlarda 2. error senaryosunda ambiguoty hatasý verebilir.
		template <typename T>
		void func(T x, T y){
		}
		int main(){
			func(10, 2.9);//error ambigious hatasý.
		}
	
	- Template'ler hemen hemen her zaman baþlýk dosyasýnda bulunacaklardýr.
	- template'ler iç içe template'lere çaðrýda bulunabilir.
	- iki tane ayrý fonskiyon template'i olacaksa bunlar mutlaka ayrý ayrý template'ler ile belirtilmelidir.
	- template tanýmýnýndan sonra ya bir fonksiyon tanýmý yada sýnýf bildirimi gelir.

	- template type deduction : 

	Not : template tür parametresi ile fonksiyon þablonlarýnýn parametresi ayný olmak zorunda deðildir.
		template <typename T>
		void func(T *x)
		{
		}// T int ise fonksiyon parametresinin türü int *'dýr.
	
	
	- derleyici þablonun parametrik yapýsýnýn, 
		
		1-)template <typename T>
		   void f1(T x)
		   {} 
		
		2-)template <typename T>
		   void f2(T &x)
		   {} 
		
		3-)template <typename T>
		   void f3(T &&x)
		   {
		   }
	 olmasýnda farklý farklý çýkarýmlar yaparlar.

	- 1. kategoride 
		template <typename T>
		void func(T x);
	
	- normal gönderdiðimiz argümanýn türü ne ise þablonun parametresi de o türdendir.
	  func(10) // ile T'nin türü int tir.

	- eðer func'ý const bir nesne ile çaðýrýrsak derleyici const'luðu gözardý eder.
	  const int x = 23;
	  func(x); // T'nin türü inttir.

	-  reference'ta ele alýnmaz
	- adresin const olmasý ile nesnenin const olmasý arasýnda fark vardýr. adres const ise aynen aktarýlýr.

	func("neco"); // T türü const char * 'dýr.

	template <typename T>
	void func(T *ptr);

	int main(){
		int x = 10;
		func(&x); ptr is int * so T is int;
	}
	  int x = 10;
	  int &r = x;
	  func(r);// T'nin türü int'tir.
	
	- þablonlar constluk ve  reference'lýðý göz ardý edilir.

	- ikisi birden olduðu durumlarda ikisi de göz ardý edilir.
		
---- 2. categoride -----
	template <typename T>
	void func(T &r){
	}
	int main(){
		const int x = 10;
		func(x);//T is const int, r is const int &;
	}

	template <typename T>
	void func(T &r1, T &r2)
	{
		
	}

	int main(){
	func("ali", "veli"); // ambigious hatasý çünkü const char * olan diziler biri 4 elemanlý diziyi gösterirken biri 5 elemanlý diziyi göstermektedir.
    }
	
	-
	template <typname T, size_t size>
	constexpr size_t asize(T &r){
			return size;
	}

	int main(){
	int b[] = {2,3,5,6}
		
	}

	- 3.kategoride universal reference denir. sol taraf deðeri ile çaðýrýlýrsa sol taraf referansý, sað taraf deðeri ile çaðýrýlýrsa sað taraf referansýdýr.

		template <typename T>
		void func(T &&x){
		
		}
	// ileride göreceðiz. Çok sýk kullanýlan bir özelliktir.

	- STL'de parametrik yapýsý bu þekilde olan bir çok fonksiyon vardýr.

	- hangi durumda hangi template'i seçeceðimiz konusunda çýkarým ne kadar kompleks olursa o seçilecektir. Konu çok karmaþýktýr. Böyle öðrenmemiz yeterlidir.

	- varsayýlan template tür parametresi vardýr.
		template <typename T = int>
		class Myclass{
		public:
			Myclass(){
				std::cout << "type T is " << typeid(T).name() << std::endl;
			}
		}
		int main(){
		Myclass<> mx; // T is int
		}
-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------18.02.2018 PAZAR------------------------------------------------------------------------
	
----- class template -----
	
	- template <typename t>
	  class SmartPtr{

	  public:
		SmartPtr(T *p);
		T &operator*();
		T *operator->();
	  }; 

	  

	- Ayný template'ten farklý türler için açýlýmý farklý sýnýf türleridir. Yani smartptr'nin int ve double açýlýmý  farklý sýnýf türlerindendir.
		Myclass<double> m1;
		Myclass<int> m2;
		m1 = m2 // sentaks hatasýdýr.

	- Bir fonksiyon þablonu bir sýnýf þablonunu tür çýkarýmýnda kullanabilir.
		vector<list<string>> xvec;
	
	- Sýnýf þablonlarýnda deduction(çýkarým) yoktur. Ama bunu fonksiyon þablonu ile sarmalayarak yapabiliriz.
		template <typename T>
		std::vector<T> gvec(T x, size_t n){
			return vector<T>(n, x);
		}()
	
	- deduction :  bir nesne göndererek derleyiciye hangi türden nesne olduðunu kendisinin çýkarým yapmasýdýr.
	
	- STL'in neredeyse bütün container'larýnda default template argümanlarýný kullanýr.
	
	- template sentaksýný yazmak zor olduðundan typedef bildirimlerini sýkça kullanýrýz.
	
	- modern c++'da typedef yerine using kullanýlýr.
		typedef int word;
		using word= int;
	
	- using ile yapýlýp typedef ile yapýlamayan bazý bildirimleri vardýr.
		-typedef bildirimleri template olarak yapýlamýyorken using bildirimleri yapýlabilir.
	
	- template <typename T>
		using Spair std::pair<string, T>;
	
		int main(){
			Spair<int> x; ---> pair<string,int>//bunun typedef eþleneði yoktur.
		}
	- bir template sýnýftan açýlan sýnýf, o template'in baþka türünden açýlan sýnýf ile farklý türlerdir. Ve birbirine atanamazlar.
	- Ama bunlar member template olarak yazýlýrsa bu template'ler birbirine atabilir.

------ template'lerin özelleþtirilmesi -------
	- belirli türdeki template'ler için bir template yerine baþka türden bir template kullanýlmasýný gösterir.
	- sentaksý : 
		template <typename T>
		class Myclass {
			Myclass(){}
		}
		template<> 
		class Myclass<int> {
		public:
			Myclass(){}
		}
	- int türü için ikinci tür açýlacakken diðer türler için 

	- begin fonksiyonunda özellikle dizi adresleri için veya herhangi bir pointer açýlýmý için aþaðýdaki pointer kullanýlacaktýr.
		template<typename T>
		class Myclass<T *>{
		public:
			Myclass(){}
		}

	- iki template tür parametresi ayný ise 1. template'i farklý ise 2. template'i çaðýracaktýr.
		template <typename T, typename U>
		class Myclass<T,U>{
		public:
			
		}
		template <typename T, typename U>
		class Myclass{
		public:
			
		}

	- normal  bir sýnýfýn bir template member function'ý olabilir.
	
	- non-type parametre --> stl'in bir iki önemli sýnýfý kullanýr. template'e herhangi bir tür bildirmez. 

-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------24.02.2018 CUMARTESÝ------------------------------------------------------------------------
	
	---------------------------------------------------- STL ---------------------------------------
	
	- Bu kütüphane veri yapýlarý ve algoritmalara yöneliktir. veri yapýlarý ve algoritmalar kod þekline getirilip standartlaþtýrýlmýþtýr.
	- STL'in en temel öðeleri þunlardýr.
		- Containers
		- Algorithms
		- Iterators
			
	- ayrýca baþka öðeleride vardýr.
		- adapters
		- lambdas
		- functors
	
----- containers -----
	- vector : 
		- hangi konuda hangi container'ý seçemediðimiz zaman vector'u kullanmalýyýz.Sondan ekleme iþlemi sabittir.
	
	- list(çifte baðlý liste sýnýfý)
	- deque : dinamik dizilerin dizisi. Ekleme ve silme iþlemleri baþtan ve sondan yapýlýyorsa ve konum bilgisine eriþim sabit zamanda'dýr.
	- forward_list (C++11)
	- string : STL'in tüm koþullarýný saðlamaktadýr. aslýnda vector ile string týpatýp aynýdýr. String sadece yazý iþlemleri için özelleþtirilmiþtir.
	- array(C++11)

	- Buraya kadar olan container'lara sequence container denir. Bunlarda ki ekleme silme iþlemleri bir konuma göre yapýlmaktadýr.

	- aþaðýdaki container'lara ise associative containers denir. Bunlar arka planda ikili arama aðacýndan baþka bir þey deðildir. Container'da ekleme iþlemini herhangi bir 
	  iterator'e göre yapamayýz. Neye göre daha az maaliyet oluþrutacak sa oraya ekler.
		
	- set
	- multiset
	- map
	- multimap

	- set ile map arasýndaki fark : set anahtar deðerli tutar. Yani varmý yokmu 
	- multiset : 
	- map'te ise : map içinde pair içerir.pair'in first'i anahtar second'ý ise value'ye içerir.
	- multiset'te ise  : ayný key'den birden fazla olabilir.
	
	- geriye kalan 4 tane container, bunlar hash sýnýfýdýr.unordered associative containers.
		- unordered_set
		- unordered_map
		- unordered_multiset
		- unordered_multimap
	
	- hash sýnýflarý tamamen ikili arama aðaçlarýna alternatiftir.
	- hashing : anahtar'ý index'e dönüþtürüp direk index'e eriþir. 
	- hashing ikili arama aracýnýn çok aðýr kaldýðý yerlerde kullanýlýr.

	- container'lar her zaman kopyalama semantiði ile çalýþýr.
	- svec.push_back(str); // örneðin burada str'nin kendisini deðil bunun bir kopyasýný çýkarýp onu koyarýz.
	- vector'de tutulacak olan nesnenin kopyasýdýr.Gerçek nesneyi biz construct ediyoruz.
	- container'lar her zaman kopyalama semantiði ile çalýþýr.
		- 11 ile taþýma fonksiyonlarý da vardýr.
	
	- Bir nedenden dolayý öðenin kendisini tutmak istiyorsak eskiden pointer kullanýrken þimdi akýllý pointer'larý kullanabiliriz.
	- container'larda reference'lar tutan bir container kavramý yoktur. onun yerine reference'larý sarmalayan bir sýnýf yapabiliriz. Bu standarttýr.
      reference_wrapper
	
	- container'dan ekleme veya silme yapmak direk olarak container'ýn üye fonksiyonlarýndan yapýlýr.

--- stl'in ikinci öneli ayaðý iterator'lerdir----
	- bir container'daki öðenin konumunu tutar.
	- pointer benzeri bir interface'i vardýr. içerik operatörünün operandý odluðunda o konumdaki nesneye eriþmesi. 
	- ++ operatörünün operandý iterator'un deðerini bir artýrýrýz.
	- eðer adres'ler ardýþýk olmasaydý pointer'ý kullanabilirdik her zaman.

	- her container sýnýfýnýn bir begin ve end fonksiyonu vardýr. Geri dönüþ deðeri iterator türündendir.
		iterator begin(); //container boþ deðilse container'da bulunan ilk öðenin konumudur.
		iterator end(); // container'larýn end fonksiyonun döndürdüðü iterator bir nesneyi göstermez. son öðeden bir sonraki öðenin konumu
	- STL'de ki  container'larýn range'i begin'i end fonksiyonlarý arasýndadýr. [begin,end)	

--- algorithms ----
	- Fonksiyon template'leridir.
	template<typename Iter>
	void display(Iter beg, Iter end){
		while(beg != end){
			std::cout << *beg << " ";
			++beg;
		}
	}

	- Burada Iter hangi sýnýf türünden ise o sýnýfýn !=, *, ++ operatörü overload edilmelidir. Burada iter sýnýfý da iterator türündendir.
	- STL'deki algorithm baþlýk dosyalarý böyle fonksiyonlarý içerir.
	- algoritmalar'ýn iteratorlere göre yazýlma nedeni 
		1-) container'ýn tamamý üzerinde iþlem yapmayý engeller
		2-) iterator parametreli template, function'larýn karþýlýklý farklý veri yapýlarýný kullanmak için kullanýlýr(Örneðin list'ten vector'e kopyalama yapmak için).
	
	- template kütüphaneler kodun kendisidir

-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------25.02.2018 PAZAR------------------------------------------------------------------------

	- hem iterator hemde container interface'inin generic programlamada ortak bileþenleri ortak typedef isimleridir.
	- bir template içinde C'yi  template tür parametresi olarak kullanýrken container içindeki(vector<int> içindeki int gibi)
	  bilgi yi göstermek için value_type kullanýlýr. Yada bu türün pointer'ýný göstermek için bu türün (çözünürlük operatörü)::pointer
	  gibi kullanýmlar vardýr.
	
	- iterator döndüren bir fonksiyon þablonu yazmak istersek
		template <typename Con>	
	
	
	- bütün iteratorler struct iterator denilen bir yapýdan kalýtým yolu ile elde edilmiþtir.
	- Kalýtým özellikle template'ler söz konusu olduðunda base sýnýfýmýzýn, public üyeleri kalýtým yolu ile elde edilmiþ der sýnýfý da dahildir.
	- STL'deki kalýtýmýn kullanýldýðý yerler tamamen statik mekanizma olarak kullanýlýr.
	- bir sýnýf þablonundan direk olarak türetme yapamayýz. Ama bir sýnýf þablonu açýlýmýndan türetme yapabiliriz.

	- ortada bir iterator var ise bu iterator'un kategorisi
		- input iterator
		- output_iterator
		- forward iterator
		- bidirectional iterator
		- random access iterator



-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------03.03.2018 CUMARTESÝ--------------------------------------------------------------------

---------------------------------------------------------------------------- 1. DERS ------------------------------------------------------------------
	

	- STL'de örnekler ile fazla zaman kaybetmemek için tnutil baþlýk dosyasýnda bazý fonksiyon þablonlarý yazdýk.

	template<typename C, typename F>
	C &fc(C &c, size_t n,  F fn){
		//1. parametre
		//2. parametre
		//3. parametre (böyle template tür paremetreleri fonksiyon çaðrý operandý olacak. )

		while(n--){
			c.insert(c.end(),fn());
		}
	
	- STL'deki bazý algoritmalarýn sonunda if son eki vardýr.countif, removeif gibi
	- sonunda if son eki olan algoritmalarýn ortak özelliði bir iþi koþula göre, koþul saðlanýrsa ona göre iþlemi yapacaktýr.
	
	
	- predicate : bir fonksiyonun geri dönüþ deðeri bool ise o fonksiyona predicate denir. Yada bir sýnýfýn bool'a geri dönen operator()() fonksiyonunada denir.
	
	 template <typename InIter, typename OutIter, typename Pred>
		OutIter CopyIf(InIter beg, InIter end, OutIter destbeg, Pred fn){
			
		}
	}
	
	- functor  : fonksiyon çaðrý operatörünü overload eden fonksiyonlarýna  denir.

	- functor class : fonksiyon çaðrý operatörünü overload etmek amacý ile kullanýlan sýnýflara denir.

	- lambda expressions : functor class'larý derleyiciye oluþturan ifadelerdir. 

	- programlamada böyle oluþturulan içsel sýnýflara closer type denir. oluþan nesneye closer object denir. 

	- lampda sentaksý : 
	- köþeli parentez sentaksýn zorunlu öðesidir. ihtiyaç varsa içine bir þeyler konulabilir.[]
	- fonksiyonun parametre parentezi vardýr. ve kullanýmý zorunlu deðildir.(2.parantez)--> [](){}
	- bu ifadeyi fonksiyon çaðrý operatörünün operandý haline getirebiliriz. []{}()

	- derleyici lampda ifadesini CompilerGeneratedClass{} türünden bir geçici nesne oluþturur. 

	- lambda'larýn en fazla kullanýldýðý yer algoritmalara argüman olarak geçmektir.
	
	-  [](int x){return x % 2 == 0} --> derleyici burada operator() operatörünün fonksiyonun return ifadesinden bool döndürdüðünü anlayýp ona göre fonksiyonu yazar.
	 [](int x){return x %2 == 0}(19) // false ifadesi döndürür.

	 auto x = [](int x ){return x % 2 == 0}(19);

	 copy_if() // algoritmasý yazýldý.()

	 - sýnýfa istediðimiz türden bir veri elemaný koymak istiyorsak bunu [len](const string &s){return s.length() == len;});()

	 - global'ler ve static ömürlü nesneler capture etmeye gerek yoktur.

	 - eðer scope'taki tüm öðeleri capture etmek istiyorsak 
		int x = 10, y = 20, z = 30;

		auto f = [=]//Buraya eþittir atomu koymak ile o local'daki bütün atomlarý eklemiþ oluruz.(int a ){return ( a + x + y) * z;}
	
	- capture olan ifadeyi derleyici sýnýfýn veri elemaný initialize etmekte kullanmaktadýr.

	- derleyicinin yazdýðý lambda'lar da default olarak operatör fonksiyonlarý const'tur.

	- lambda'da [] içine & koyarsak bu reference capture yapmak'týr.

	- kopyalamaya kapatýlmýþ bir sýnýfta lambdalarda reference kullanýlmasý zorunludur.

	Not : bir veri elemaný mutable olduðunda o veri elemanýný const fonksiyonlar deðiþtirebilir. 

	- yazma algoritmalarý hem override modunda hem de push_back modunda çalýþýr.

-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------04.03.2018 PAZAR--------------------------------------------------------------------

	- Algoritmalar iterator parametreli fonksiyon olduðu için ve  bir algoritma generic template kod olduðu için exception throw edemez. bunu sadece algoritmaya çaðrý yapacak kod yapabilir.
	- STL verim odaklý bir kütüphane olduðu içinde exception throw etmez. çünkü exception mekanizmasý tamamen runtime'a yönelik bir mekanizmadýr.
	
	- Bir iteratoru deðiþtirmek için kullanýlan iter fonksiyonunu yazacaðýz.
		template <typename Iter>
		void Advance(Iter &iter){
			
		}
	
	- random access iterator'lerde direk bir tamsayý ile toplama iþlemi yapabiliriz. eðer random access deðil ise de döngüsel bir yapý içerisinde iteratorun konumunu ++ operatörü ile dðeiþtirebiliriz.
	
	- exception runtime'a yönelik bir þeydir. Yani compile time da exception diye bir þey olmaz.

	---- distance 2.iterator fonksiyonu'dur ----- 
	
	- iki iterator arasýndaki farký verir. distance(c.begin(), iter); ifadesi ile iter'in gösterdiði iterator ile container'ýn begin fonksiyonunun döndürdüðü iterator arasýndaki farký verir.

	- eðer random access iterator olursa sadece bir çýkarma iþlemi ile bunu bulabiliriz. iter - c.begin();
	
	- 
	int main(){
		vector<string> svec;
		randomize();
		display(fc(svec,10,rs));
		auto riter = find(svec.rbegin(),svec.rend(),"huseyin");
		cout << *riter << endl;
	}
		
	
	- normal bir iteratoru reverse bir iterator  ile construct etmek normal þartlar altýnda sentaks hatasýdýr. normal iteratoru construct reverse iterator ile construct etmek için reverse iteratorunun
	  base fonksiyonunu çaðýrabiliriz.

	- rbegin fonksiyonu ile son öðenin adresi ile end'in geri dönüþ deðeridir.
	- reverse iteratorunun içerik operatörü kendi konumunu deðil bir önceki öðenin konumunu gösterir.
	- base fonksiyonu ise reverse iteratorunun gerçek konumunu vermektedir.() 
	- base fonksiyonu dönüþtürme iþlemi yaparken gerçek konumu vermesi terstende düzden de ayný range'i veriyor.
	
	
	- non-modifying algorithm : range'de ki öðeleri hiç bir þekilde deðiþtirmeyen algoritmalardýr.
	- modifying alogirthm : belirli konumdaki öðeleri deðiþtiren algoritmalardýr.

	- removing algorithm : silme algoritmalarý yaptýðý iþ container'daki düzeni deðiþtirmektir. fiilen bir silme iþlemi yoktur.
	  2 3 4 6 4 3 5 2 5 6 3 container'ýndaki 4'leri silme iþlemi yapýldýðýnda 2 3 6 3 5 2 5 6 3 ? ? þekline gelir.
	
	- remove_if algoritmasýnýn geri dönüþ deðeri logic_end konumu dur. logic olarak bir silme iþlemi yapýlmamaktadýr.

	- gerçek silme iþlemi yapmak için bütün container'larýn sahip olduðu erase fonksiyonuna çaðrý yaparak silebiliriz.()

	svec.erase(logic_end, svec.end());

	- remove erase idiomu ile gerçek silme iþlemini tek bir satýrda halletmiþ oluruz.

	svec.erase(remove_if(svec.begin(),svec.end(),[len](const string &str){return str.size() == len;}),svec.end());

	- container'larýn erase fonksiyonlarý silinen öðeden bir sonraki öðenin konumunu gönderir. 
	- container'larýn insert fonksiyonlarý eklenen öðenin konumunu döndürür.
	
	- veri yapýsýndaki eþdeðer ardýþýk öðelerin sayýsýný bire indirme olayýna unique iþlemi denir.
	- 3 4 4 3 8 7 7 1 7 9 9 9 ------> 3 4 3 8 7 1 7 9 þekline getirmedir.

	- unique algoritmasýda silmeye yönelik bir algoritmadýr.

	- bir range sort edilip unique edilirse her bir öðe unique hale getirilmiþ olur.

	- STL algoritmalarýnýn bir çoðunda predicate parametreli overload'larý vardýr.

	- string bir container olduðu için herhangi bir STL iþlemini de string ile yapabiliriz.
	
	- algoritma silme iþlemini yapamaz. silme iþlemini container'ýn kendi üye fonksiyonu yapabilir.
	
	- foreach algoritmasý bizden bir range alýp o range'i bizim gönderdiðimiz bir functor'ý argüman olarak gönderir.
	
	- for_each(svec.begin(), svec.end(), [](const string &s){ s += "can"});

	- for_each ile yapmak yerine iþlemlerimizi range based for loop ile  yapabiliriz.

	- transform algorithm : 
		template <typename InIter, typename OutIter, typename Func>
		OutIter Transform(InIter beg, InIter end, OutIter destbeg, Func f){
			while(beg != end){
				*detbeg = f(*beg);
				++beg, ++destbeg;
			}
			return destbeg;
		}

		// bir range'i bir fonksiyona gönderip  fonksiyonun geri dçnüþ deðerini baþka bir range'e yazarýz.

	- transform(svec.begin(),svec.end(),back_inserter(lenlist), [](const string &r){return r.size();)(21949)// burada back_inserter fonksiyonunun kullanýlmasýnýn nedeni container'ýn list olmasý olmadýr.
	  list fonksiyonlarýnýn random access iterator kullanýmýndan dolayý back_inserter kullanýlýr.

	- container'larýn erase fonksiyonlarýnýn reverse iterator overload'ý yoktur.
	
	- rfind fonksiyonlarý string container'ý içindir. bütün container'lar için geçerlidir.

	- eðer bir iterator gereken yere reverse iterator atarsak error olur. Çünkü farklý iki türden sýnýf nesnesini bir birine atamak sentaks hatasýna yol açacaktýr.

	------ ostream ve isteram iteratörleri ------

	- algoritmalar ostream iterator sýnýfýný kullanarak herhangi bir yere yazan algoritmayý çýkýþ akýmýna yazdýrabiliriz.


	- özellikle sýralama algoritmalarý çok önemlidir.


	--------------- containers -------------------

	- forward_list
	- deque
	- list
	- vector
	- string
	- array 

	- bunlara sequence container denir.

	- set
	- multiset
	- map
	- multimap

	- associative container denir.

	- undordered_set
	- undordered_multiset
	- undordered_map
	- undordered_multimap

	- unordered associative container denir.

	- bir contanier'ý öðrenirken onlarýn ilk baþta veri yapýsýný öðrenmemiz gerekmektedir.

	- ikili arama aðacýnda deðer arandýðý silindiði zaman logaritmik karmaþýklýk ile yapýlýr.

	-  hash_table  eriþimi sabit ile logaritmik karþýlýklý ile yapýlýr.

	- hash'leme : key'i indexe dönüþtürme iþlevidir.

	- 

-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------10.03.2018 CUMARTESÝ--------------------------------------------------------------------
	- initializer list: basit bir compiler hilesinden baþka bir þey deðildir. derleyici bunun karþýlýnda const bir dizi oluþturacaktýr. yani ayný türden n tane öðenin kullanýlmasýna izin vermektedir.
	- bir insert ekleme iþlemini tek tek yapmak ile toplu halde yapmak arasýnda her zaman bir performans farký vardýr.
	
	- modern C++'ýn STL'inin hep bir parçasýda initializer list'tir.
	
	- container sýnýflarýnýn initializer list parametreli sýnýflarý vardýr.

	- initializer_list'in öðeleri const olarak tanýmlamasak bile derleyici arka planda her zaman öðelerini const olarak kabul eder.
	- initializer_list nesneleri kopyalandýðý zaman ayný öðeyi kullanacaktýr. zaten ayný öðeyi kopyalacaktýr.

	- initializer_list'in tek bir öðeye üstünlüðü vardýr.(22324)

	- seuqlence container'lar da küme parantezi kullanmak ile normal parantezi kullanmanýn constructor açýsýndan farklýlýklarý vardýr. 
		vector<int> x(20); //burada int parametreli constructor çaðýrýlýrken
		vector<int> x{20}; // burada initializer_list parametreli constructor çaðýrýlýr.
	
- sýnýf türündense default constructor'ý çaðrýlýr. primitive türden ise sýfýr deðere çekilir--> buna value initialized nedir.(container'lar için);
	
	- eðer value initialized yapýldýðýnda sýnýf türleri için default constructor yoksa sentaks hatasý'dýr.

	- container'lar için en önemli constructor'dan biri range parametreli constructor'dýr.

	- farklý sýnýf türlerinden birbirine ilk deðer veremeyiz. vector<int> x{5}; vector<double> y {x} sentaks hatasýdýr. Bu yüzden range parametreli constructor
	  alýnýr.
	
	- vector'un bool açýlýmý STL'in en fazla eleþtirilen noktalarýndan biridir.
	- bir çok programcý vector'un bool açýlýmný kullanmak yerine deque'nin bool açýlmýný kullanýr.
	- taþýma semantiði devreye girdiðinden beri container'a geri dönen fonksiyon yazmak sorun deðildir.
	
	- STL'de forward_list'in size'ý yoktur.	 
	
	- vector, deque'nin ve string'in köþeli parentez operatörleri ve at fonksiyonlarý vardýr.(at exception'a tabidir.)
	
	- eðer range based for loop'ta kopyalama istemyorsak mutlaka referans koymalýyýz.

	- iterator invalidation--> bir iterator2un belirli bir iþlemden sonra geçersiz hale gelmesi.

	- insert : gösterilen konumda o nesnenin olacaðýdýr.

	- insert konumunda eðer reallocation durumu olmaz ise önceki öðelerin iteratorunu derefererence etmesi sorun olmazken. sonrasýndakiler sýkýntý olur.

	- iterator invalidation söz konusu olduðunda iterator'u dereference etmemeliyiz.

	- vector de list'te string'te ve deque'da sondan ekleme yapma vardýr.
	- vector'de baþtan ekleme silme 
	- sequence container'larda ekleme her zaman bir konumla yapýlýr.

	- insert fonksiyonlarýnda yapýlan iþlem kopya nesne vector'deki yere 
	- emplace functions : emplace fonksiyonlarý bize hiç bir kopyalama olmadan nesneyi o konumda oluþturur.


	- emplace fonksiyonlarýna argüman olarak doðrudan container'ýn constructor'ýna doðrudan o adres için çaðrý yapacaktýr.Yani nesne'nin hangi adreste construct edilmesi belliyken
	  bu adresi this adresinde bir defada sýnýfýn constructor'ý çaðýrýlarak nesne orada hayata gelmiþtir.
	
	- emplace kopyalamanýn ilave maaliyet yarattýðý durumlarda eðer sýnýfa geçeceðimiz argümanlar belli ise doðrudan nesneyi compiler'ýn ayarladýðý belli bir alanda construct edebilir.


	---------------------- sequence container'larýn assing fonksiyonu -----------------------------------

	- range, fill ve initializer_list assign edilebilir.
	
	- assign fonksiyonu ile bir list'ten vector'e ayný parametreye sahip assign edilebilir. operator= fonksiyonu ile bunu yapmamýz mümkün deðildir.

	- 
	
-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------11.03.2018 PAZAR------------------------------------------------------------------------
	
	- Ayný türden container'larý karþlýlaþtýrma operatörü ile karþýlaþtýrma yapabiliriz.

	- buradaki karþýlaþtýrma lexicographical_compare ile karþýlaþtýrabilir.

	- vector default kullanýlan container sýnýfýdýr.
	
	- vector'un bool açýlýmý içinde bool tutan bir vector deðil ayrý bir template kodudur. STL uyumlu bir container deðildir.
	  bir bitsel implementasyondur.

	
	------------ deque container'ý---------
	
	- deque içinde iki ayrý dinamik dizi tutan bir veri yapýsýdýr.
	- üç tane temel iþlemi constant time'a çeker.
	- baþtan, sondan ekleme, köþeli parentez ile eriþim
	- vector'un interface'ine çok benzemektedir.
	- vector'un bool açýlýmý yerine STL algoritmalarýna uymasý için deque'nin bool açýlýmý kullanýlýr.

	
	---------------- baðlý liste -----------------
	
	- list çifte baðlý liste sýnýfý iken forward_list tek'te baðlý listedir.

	- baðlý liste  vector'den sonra en çok kullanýlan veri yapýsýdýr.

	- bu veri yapýsýnýn neredeyse tek neden konumunu bildiðimiz bir öðe'ye ekleme ve silme iþlemi sabit zamanda olmasýdýr.

	- STL' de ki en önemli konulardan biri bir iþlemi hem algoritma hem de sýnýfýn üye fonksiyonlarý ayný iþlemi yapýyorsa, sýnýfýn üye fonksiyonlarýný seçmeliyiz.

	- baðlý listeyi istesekte sort yapamayýz. çünkü sort yapmak için mutlaka random access iterator gerekir.

	- baðlý liste memory overhead'i daha fazladýr.

	- bidirectional iterator : 
	  1-)iki yönde dolaþýlabilir.
	  2-) random access iterator isteyen algoritmalarda kullanamayýz.
	  3-)
	
	- list container'ýnýn üye fonksiyonlarýndan remove logic silme yapmaz. logic silme yapan fonksiyonlar algorithm baþlýk dosyasýna aittir.
	
	
	- list::merge function'ý --> sýralý birleþtirme.
	- merge ile iki listeyi birleþtirmek istiyorsak bu listeleri önceden sýralamalýyýz.

-------- splice(member function) ----------
	
	- bir listeden diðer listeye eleman taþýr.

------ forward_list -------
	
	- çifte baðlý liste sýnýfýnda düðümler iki tane pointer içerdiði için elimiz de bir düðümün adresi varsa onun önceki ce sonraki öðresine eriþebiliriz.

	- bir konuma ekleme yapmak demek o konumdan önceki düðümün  next'ini deðiþtirmeliyizdir.

	- forward_list'te bir ekleme yapmak için insert deðil, insert_after fonksiyonu vardýr. hangi konumu verirsek onun sonrasýna verir.

	- forward_list'te baþa eklemek mümkün deðilken bunu before_begin adlý fonksiyon'un gösterdiði konuma ekleme yaparak kullanabiliriz.(ilist.insert_after(ilist.before_begin());)

	- iteratoru forward iteratoru'dur.;

----- standart functor sýnýflarý(functors) -----
	
	- STL'in en fazla kullanýlan sýnýflarýndan biriydi. lambda'larýn gelmesi ile kullaným alaný çok azaldý.

	- plus toplama iþlemi yapan þablon
	- less küçüktür iþlemi yapan þablondur.
	- bunlar standart'týr.


---------associative containers------
	- set, multiset, map, multimap'tir.

--- set ---
	- sentaksý set<T, less<T>,allocator<T>>;
	- set<int> iset;//
	- set ayný deðeri bir kere insert eder.yani 41, 41 te sadece bir kere eklenir.
	- multiset'te ise ayný anahtardan birden fazla koyulur.
	
	- set ekleme silme ve arama iþlemlerini logaritmik olarak yapar.

	- strick  

	
-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------17.03.2018 CUMARTESÝ--------------------------------------------------------------------
	
	----- set ------
	- set ile multiset'in farký set bir keyi bir kez bulundururken multiset ayný keyden bir den fala bulundurur.
	- multiset te ise ayný key'den birden fazla olabilir.
	
	- set, multiset, map, multimap container'larýn hepsinin üye fonksiyonlarýný çaðrýrýz. çok özel durumlar dýþýnda algoritmalarý kullanmak çoðunlukla bizim için daha maaliyetlidir.
	
	- set'in ve map'in insert fonkisyonunun geri dönüþ deðeri pair'in iterator, ve bool deðeridir. pair'in second'ý ekleme yapýlmýþ ise true yapýlamamýþ ise false
	  
	  pair'in first'i ise ekleme yapýlmýþ ise yapýlan öðenin konumu ekleme yapýlamamýþ ise de ayný key'den var olan öðenin konumu.

		 -set<int> iset{2,6,12,45};
			int x;
			cin >> x;
			cout << iset.size() << endl;
			auto p = myset.insert(x);
			// burada o konumu bir yerde daha kullanmayacaksak 
			//if(myset.isert(x).second) // ilede yapýlabiliriz.
			if(p.second){
			cout << "ekleme yapildi" << endl;
			cout << *p.first << endl;
			}
			else {
			cout << " ekleme yapilamadi" << endl;
			cout << *p.first << endl; // var olan öðenin konumunu döndürür.
			}			
			cout << iset.size() << endl;
	
	- set'teki bir karþýlaþtýrma için STL kitabý sayfa 319 'daki kriterleri saðlamalýdýr.	
	
	- set'in int açýlýmý derken anahtar her zaman const'tur. yani const int olarak alýr. 

	- set'te iterator dýþýnda deðer ile silme de vardýr.
	- set'te ekleme, silme, arama logaritmik karmaþýklýktadýr.

	- lower_bound verilen bir konumdan >= olan ilk konumdur.
	- upper_bound verilen bir konumdan > olan ilk konumdur.

	- lower_bound ile upper_bound'un oluþturduðu range'e equal range denir.
	- bir multiset'te sizin anahtarýnýza eþit bütün deðerleri gezmek istersek bunu upper_bound ve lower_bound'ý ile birer iterator olarak kullanarak onlarýn range'ini alacaðýz.
	- lower_bound'ý biz equal range için istiyorsak bunu equal_range fonksiyonu vardýr. bu fonksiyon iterator pair çifti döndürür.first'i lower_bound second'ý  upper bound döndürür.
	  aranan deðer key olarak container'da yoksa onun equal range'i empty range olacak.
	
	- lower_bound upper_bound bir çok iþlemde kullanýlýr.

	- eðer set'te karþýlaþtýrma kriteri olarak lambda kullanacak isek lambda'nýn default constructor'ý olmadýðý için  set'in karþýlaþtýrma nesnesini kopyalarak belli eden constructor'ýný kullanmalýyýz.
		auto f = [](int a, int b){return a < b;};
		set<int,decltype(f)> myset(f); 
	
	----- map ------

	- map ile set'in farký map'e insert iþlemi yapýlýrken bunu sadece pair olarak yaparýz. map'in amacý aradýðýmýz anahtara karþý bir anahtar deðil deðer buluyoruz.

	- map'in köþeli parentez operatör fonksiyonu vardýr.(multi-map'in deðil);

		mymap[120] = "ali";
		burada map'te 120 key'i yoksa onu "ali" value'si ile birlikte oluþturacak.
		eðer 120 key'i varsa onun value'sini ali olarak deðiþtirecek.
	
	- primitive türler için default constructor yerine sýfýr deðeri atanýr.

	- vector<string< svec;

		randomize();
		fc(svec,3000,rs);
		map<string,int> mymap;

		for(const auto &i : svec){
			++mymap[i];
		}

		// burada bir container'da kaç tane ayný türden deðer olduðunu anlarýz.

	
	-------- sýralama iþlemleri -----------(STL'deki algorithm kütüphanesindeki sýralama algoritmalarýdýr.)
	
	- uygulamada en sýk kullanýlan algoritmalar sort grubudur.
	- associative container'larý sort etmeye çalýþmamalýyýz. onlarýn kendi içinde bir sýralama algoritmalarý vardýr.
	- random access iterator veren her container'ý dipslay fonksiyonu ile sýralayabiliriz.
		sort(svec.begin(),svec.end());
	
	- sort(svec.begin(),svec.end(),greater<int>); ile büyükten küçüðe sýralama yaparýz.

	- stable_sort : iþlemden önce ki izafi konumu korur.
	
	- partial_sort : bir vector'un belirli ilk 20 öðesini sýralayýp diðerlerini sýralamaz.
		
		partial_sort(svec.begin(),svec.bgin() + 5, svec.end());//burada tamamý sýralansaydý ilk 5 'i bu olacaktý anlamýna gelir.
		geri dönüþ deðeri yoktur.

	
	- partial_sort_copy : sonu copy ile biten algoritmalar yapýlan iþlemi baþka bir range'e kopyalarak yapar.
		

-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------18.03.2018 PAZAR------------------------------------------------------------------------

	- Hash table : arama anahtar ile yapýlýrken bu aramayý constant time'da yapmaktýr.
	
	- set multiset map multimap kullanmak yerine bunlarýn unordered olanlarýný kullanabiliriz. Deðerle eriþme setten bile daha hýzlýdýr.
	
	- Hash table'ý en çok kullanan kodlardan biri iþletim sistemidir.

	- anahtarý index'e dönüþtürme iþlemine hashing denir.

	- eðer hash fonksiyosunun kalitesi ne kadar yüksek ise farklý anahtarlarý o kadar farklý deðere dönüþtürmektedir.

	- collusion = anahtarýn ayný deðere hash edilmesi

	- yine ayný þekilde map grubu içinde key value pair tutuyor.

	- set grubu ise sadece key'e tutar.

	- burada sýra iliþkisi yoktur. yani eklenme sýrasýnýn bir önemi yoktur.

	- set fonksiyonlarýnýn 3 tane template paremetresi vardýr. bunlardan birincisi tür bilgisi ikincisi karþýlaþtýrma functor'ý üçüncüsü de hash function'ý.

	- bizim anahtar olarak kullanacaðýmýz deðer standart kütüphanenin bildiði bir deðer ise bunun hashing fonksiyonlarý zaten vardýr.
	- bizim hash table'da tuttuðumuz türler kendi türlerimiz ise burada hashing iþlemi baþlar.

	- hash fonksiyonu ayný anahtarý tekrar hashlendiðinde yine ayný deðeri vermesi lazým.

	- hash'in bucket count fonksiyonu kaç tane bucket  olduðunu döndürür.

	- load_factor bucket baþýna düþen deðer.

	- max_load_factor : öyle load factor deðeriki load_factor deðeri bu deðere eþit olduðu zaman re-hashing yapýlacaðýdýr. max_load_factor'un 0,70-0,80 arasý almalýyýz.

	- bucket count artýrýldýðý zaman bucket içerisinde ki nesnenin teke düþmesi þansý giderek artacaktýr.

	- bütün container'larda 6 tane bkarþýlaþtýrma operatörü varken burada sadece eþit ve eþit deðil operatörleri vardýr.



----------------- giriþ çýkýþ iþlemleri ---------------------
	
	- giriþ çýkýþ iþlemlerinde sýk sýk taban sýnýf olan ios_base sýnýfýnýn static veri elemanlarýna eriþeceðizdir.

	- ios_base sýnýfý bir template deðildir.

	- ios_base'den üretilmiþ basic_ios bir template'tir.

	- basic_ios akýmýn karakter türüne baðlýdýr. ama akýmýn giriþ mi çýkýþ mý akýmý olduðuna baðlý deðildir. basic_ios'dan giriþ akýmlarýný yönetmek için basic_istream (typedef ismi istream)
	 sýnýfýný çýkýþ akýmlarýný üretmek için basic_ostream(typedef ismi ostream) sýnýfý türetilmiþtir. 
	
	- basic_istream ve basic_ostream sýnýfýndan multiple inheritance ile basic_iostream(typedef ismi iostream'dir.) sýnýfý türetilmiþtir.
	
	- basic_istringstream sýnýfý basic_istream sýnýfýndan türetilmiþ 

	- formatlama ile ilgili bilgiler akým nesnesinin içinde bulunur.

	- formatlama bilgilerinin bir kýsmý bool'in türündendir.

	- bool alpha iose_base'in bir static veri elemaný olup bu fonksiyon format'ý deðiþtirmek için kullanýlýr.

	- cout.flags fonksiyonun iki tane overload'ý vardýr.
		- cout.flags();//get function
		- cout.flags(x);// set function
	
	
	- showbase = sayý sisteminin tabýnýný göstersinmi göstermesin mi
	  uppercase = sayý sistemini büyük harflerle gösterir.
	
	- bool'in bayraklarý en tepe sýnýfýn const static veri elemanýdýr.

	- setf ve unsetf fonksiyonlarý bir cout içerisindeki bütün nesneleri etkiler.

	- cout << endl; dediðimizde 
		ostream &endl(ostream &os){
			return os << "\n*********************\n";
		}
	
	- endl bir manipülatördür.

	- bir satýr atlarken birde buffer'ý flash eder.
	
	- cout << boolalpha << (10< 340) << noboolalpha << (10>654) << endl; //manipülatör'ü kullanacaktýr.

	- iomanip ---> input output manipülatör'üdür.

		- paremetreli manipülatörler vardýr.
	
	- yazma alaný geniþliðini set eden fonksiyon cout.width(23) fonksiyonudur.

-------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------17.03.2018 CUMARTESÝ--------------------------------------------------------------------

	- structural-binding (C++17 derleyiciler þu an desteklemeyebilir.) : 
		
		auto func()
		{
			return make_tuple(23,string{"akin"}, 3.4);
		}

		int main()
		{
			auto [a,b,c,d] = func();//Burada gereksiz kopyalama yoktur. Construct edilecektir.

		}
	
	- structural binding'in en büyük özelliði stl'in bir çok aracý ile kombine edilebilmesidir.
	
	- vector ivec{12,45,98,23};// C++17 ile gelmiþtir. derleyici kendisi çýkarým yapmaktadýr.

	- pair x{23,2.4}; // bu sadece constructor için geçerlidir.

	
	
	- reinterpret_cast elimideki bir nesne adresini baþka bir nesnenin adresini dönüþtürmek için kullanýlýr. eðer bunu static_cast ile kullanýrsak bu bir error'dur.


	- int x = 12321423;

	- unsigned char *pbuf = reinterpret_cast<unsigned char *>(&x);

	- abstract datatype : nasýl implemente edildiði ilgilenmez. sadece interface'e bakýlýr.

	- stl'de üç tane sýnýf þablonu vardýr. bunlar containerlar denir. bunlar container'larý 
		stack(son giren ilk çýkar)
		queue(ilk giren ilk çýkar)
		priraty_queue(bir öncelik ilkesi vardýr.kuyruða girerken normal girer. çýkarken de bir sýra ile çýkýlýr.)
	
	- C++'da const initializer_list & diye bir þey yoktur. 

	 - typename tür parametresine baðlý bir nested type kullanýlýrken typename kullanýmý zorunludur. typename C::size_type size(){}

	 - array<int,5> x = {1,2,3,4,5}; // burada array sýnýfýnýn initializer list parametreli bir constructor'ý yapmaktadýr. bunlar POD type'týr.

	 - structure ile class arasýndaki fark array nesnesi gibidir. 


	 - STL genel olarak extendable karakterindedir. STL'in temel öðeleri containerlar,iteratorler, algoritmalar, functor'lardýr.

	 - abstract sýnýflar türünden nesne oluþturamayýz. ama bunlar bize interface veren komutlardýr.
	  